[ { "title": "2022년 1월 회고", "url": "/2022/02/04/2022%EB%85%84-1%EC%9B%94-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2022-02-04 07:26:33 +0000", "snippet": "코드 리뷰어2022 공채 신입 코드리뷰어 로 활동하고 있다. 조직에 합류하기 전 인턴 때 코드 리뷰를 받으면서 많이 성장했다고 느꼈기에 나도 되돌려주고 싶었다. 코드 리뷰는 대부분 업무시간을 할애하긴 하지만, 새벽에 리뷰를 하는 경우도 있어 체력적으로 힘이 들었는데, 뉴크루가 성장하는 모습이 너무 대놓고 보여서 뿌듯함을 느낀다. 리뷰이가 앞으로 조직에서 함께할 동료이기에 더 중요하게 생각한 것 같다. 리뷰이가 다른 조직이었다면 시간을 이만큼 들일 수 있었을까 싶기도 하다. 이번에 활동을 하면서 남긴 리뷰들을 잘 정리해서 템플릿 처럼 활용할 수도 있을 것 같다. (너무 공장 마인드인가 ?)평온한 리뷰어였던 나에게 긴장감을 주는 활동이었다. 코드 리뷰어 활동은 좋은 경험인 것 같아, 조직 내 후기를 공유할 예정이다.업무 고민코드 리뷰어를 통해 누군가의 성장을 도왔지만, 정작 본인의 일은 잘 쳐내지 못했다. 이슈 하나 처리하는데 너무 오래 걸리고 있다. 피로도가 쌓여서 업무 집중도 가 많이 떨어진 탓일까. 내가 일에 몰입하지 못한 것도 원인이겠지만, 조직 내 코드 리뷰 도 한 몫한 것 같다. 공채 코드 리뷰어를 진행하던 습관 때문인지, 조직 내 코드 리뷰에 시간이 많이 소모했던 것 같다. 심한 날은 ‘내 직업은 코드 리뷰어 인가?’ 하는 생각도 들었다. 물론 해당 코드는 더 좋아지긴 하지만서도.. 가성비(?) 가 안 맞는 것 같다. 코드 리뷰에 노하우가 더 필요한 걸까. 트레이드 오프가 필요해 보인다.어쨌든! 2월에는 일에 더 몰입을 할 수 있었으면 좋겠다.도메인파트원과 코드 리뷰를 하다가 내가 도메인 이라는 용어 개념을 명확하게 알지 못하구나 라는 것을 깨달았다. 그래서 도메인 용어에 대해 준비해서 50분간 발표했다. 도메인에 대해서 조사하다보니 우리 소프트웨어는 정말 문제의 영역과 기술적인 부분을 분리해서 생각해야 할 필요성을 느꼈다. 도메인을 주제로 이야기하다가 자연스럽게 유지보수 / 도메인 모델 까지 언급이 있었다.그렇다. 사실 이건 DDD 스터디를 팔기 위한 빌드업이었던 것(?)사내 스터디대용량 서비스를 위한 아키텍처 with Redis (패캠)위 강의를 듣고 토론하는 식으로 조직 내에서 스터디를 했다. 강의는 이론과 실습을 병행하는 식으로 이루어져 있는데, 스터디가 끝날 때 대용량 서비스를 위한 전문가가 되지는 못했다. 단지 어떠한 것들이 있는지 굵직한 것들에 대한 버킷이 생겼다고나 할까. 다음에 해당 내용을 접하면 다시 찾아볼 법한 레퍼런스 정도 얻어간 것 같다. 실습을 따라 하면서 막히는 부분도 있었는데, 커뮤니티가 없는 패캠의 구조도 아쉬웠다. (인프런에는 강의마다 질문하는 곳이 있음. 패캠에서는 내가 못 찾은 걸까?)읽은 책1. 만들면서 배우는 아키텍처 계기 작년에 클린아키텍처 서적 스터디 를 했었는데, 아쉬운 부분이 있었다. 개념적으로는 알겠는데, 실질적인 코드의 부재가 아쉬웠었다. 조직의 아키텍처와도 약간 거리가 있어 차츰차츰 머리속에서 잊혀지고 있었다. 그러다 작년 말에 아는 형의 소개로 만들면서 배우는 아키텍처 책을 알게 되었고, 읽게 되었다. 내용 이 책의 내용은 간단하다. 헥사고날 아키텍처를 직접 코드로 만들어나간다. 도메인 모델 부터 시작해서 유스케이스 구현. 유효성 검증 도 다루고 있으며, 웹/영속성 어댑터 도 in/out 포트 를 구분하여 구현한다. 각 경계 별로 테스트 코드 짜는 것도 있고, 마지막에는 만든 것들을 조합해서 실행 가능한 프로그램을 완성시킨다. 이 책에서는 도메인 Entity 와 영속성 Entity 를 완벽하게 분리한 점이 인상 깊었다. 나는 책을 읽으면서 하나하나씩 직접 타이핑을 했는데, 이 편이 훨씬 좋은 것 같다. (당연한소리?) 직접 타이핑을 하면서 책을 보다보니 책이 나에게 조언을 해주는 것으로 들렸다. 이 경험은 그냥 책을 읽었을 때보다는 훨씬 얻는 것이 많지 않을까 싶다. 한가지 아쉬운 점이 있다면, 여러 도메인 사이에서는 어떤식으로 교류를 하는지에 대해서는 나와있지 않았다. 이 부분은 책을 읽은 이후에 오히려 갈증으로 남게되었다. 그래도 너무 좋은 책이라고 생각한다. 어쩌면 지금 클린아키텍처를 다시 읽어야 하는 타이밍이 아닐까 싶다. 추천하는지? 100% 추천하고 싶다. 헥사고날 아키텍처를 도입할 예정이 없더라도, 유지보수를 해야하는 서비스를 개발하는 개발자 라면 읽어서 나쁠 건 없다고 생각한다. 아래는 조영호 님의 추천사이다. 2. 이펙티브 코틀린 계기 나는 코틀린을 이용하여 개발은 하고 있지만, 잘 사용하고 있는건지 확인이 필요했다. 코틀린 인액션 을 완독하지 않은 입장에서 이펙티브 코틀린 을 보는 것이 순서가 맞을까 싶기도 했지만, 자바의 정석 을 완독하지 않은 내가 이펙티브 자바 에서 많은 깨달음을 얻은 경험이 있으니 이번에도 괜찮지 않을까 싶었다. 이펙티브 코틀린 번역본이 출간되었다는 소식을 듣고 바로 구매했다. 책을 읽고 나면 코틀린을 좀 더 코틀린답게 사용하기를 바라며 책을 읽었다. 내용 책 구성은 이펙티브 자바와 비슷하다. 여러 Item 으로 구성되어 있다. 이 책은 코틀린 이외에도 클래스 설계 / 추상화 에 대해서도 다루고 있다. 해당 내용은 다른 책에서도 많이 다루고 있기에 불필요하다고 생각했으나, 결코 그렇지 않았다. 개념을 다시 익힐 수 있어 좋았고, 그 안에서도 코틀린스러운 코드들을 볼 수가 있었다. 내가 평소에 sealed class, sequence 공변성 에 대한 고민이 부족했음을 느꼈다. 이 책을 한번 읽는 것 만으로 안에 내용을 다 익혔다고 생각하지 않아서 2월 중에 한번 더 읽을 예정이다. 추천하는가? 코틀린을 조금이라도 써보았고, 조금 더 잘 쓰고싶다면 무조건 추천하고 싶다. 코틀린을 써보지 않았다면 이 책보다는 코틀린 인액션 이 맞지 않을까 싶다. 2월에는… 일 빨리빨리 잘하자 조직 내 DDD Study 조직 내에서 2월에는 DDD 스터디를 참가했다. 조직에 DDD 를 정착시키기 위함은 아니지만, 함께 도메인 레이어에 대한 필요성을 느끼며 조금씩 개선해 나갈 수 있지 않을까 싶다. DDD 스터디를 통해서 우리 현 아키텍처에서 문제가 무엇인지. 그것은 정말 문제인지. 문제라면 어디부터 손대는게 좋을지. 에 대한 이야기를 나누는 계기가 되었으면 한다. 조직 내 JPA Study DDD 뿐만 아니라 김영한님 인프런 강의를 이용해서 스터디도 참가했다. 인턴 때 JPA 1차/2차 캐시 에 대해 발표를 하면서 JPA에 대해 친숙해졌었는데, 조직에 합류하고서는 JPA를 사용하지 않아 거의 까먹었다. 다시 학습하고자 강의를 구매하여 스터디를 참가했다. 회사에서 비싼 강의료를 지원해 준 만큼, 조직에서도 잘 정착하는 기술이 될 수 있으면 좋겠다. 조직 내 이펙티브 코틀린 약팔기 이펙티브 코틀린 2회독" }, { "title": "2021년 회고", "url": "/2022/01/02/2021%EB%85%84-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2022-01-02 21:07:38 +0000", "snippet": "2021년 나의 상황들을 되돌아보았다.2021년의 취미생활2020년에는 취미가 없었다. 그래서 누군가가 “취미가 뭐에요?” 라고 물어보면 답하기가 정말 곤란했다.그런데 올해에는 취미라고 말 할 수 있는 것들이 생겼다.취미: 백패킹나는 집 밖을 잘 안나가지만, 액티비티는 좋아하는 모순된 사람이다.집에서 재택근무만 하다보니 너무 집 안에만 있어 건강이 나빠지는 것을 느꼈고, 이에 하반기에 백패킹을 3차례 다녀왔다. 노고산 인원: 2 총 7km 장봉도 인원: 2 총 19km 강릉 인원: 1 총 16km 백패킹 장비를 사느라 예상치 못한 지출이 생기기는 했지만, 역시 하길 잘했다.집구석에서만 지내다가 밖에서 자연을 보고, 텐트도 치고 1박을 한다는게 신선했다.낮에는 아무 생각 없이 걷기만 하다가 밤에는 텐트 안에서 두발 펴고 누울 때면 개발자가 아닌 다른 정체성이 있다는 느낌도 받을 수 있어 좋았다.강릉에서 다리를 다친 이후 아직도 회복되지 않아 더 다니지 못했는데, 2022년에는 더 다양한 곳들을 돌아다니고 싶다.취미: 폴가이즈이 게임을 너무 하고싶어서 윈도우PC를 구매했다. 60명에서 1등을 가리는 게임인데, 꽤 재미있다.지금은 가끔 생각날 때마다 하는데, 한번 시작하면 무조건 1등을 할 때까지 계속 하게 되는 묘한 재미가 있다.취미: 노래듣기음향기기에 관심이 있어 2021년 초부터 하나씩 구매했다.노래 듣는게 즐겁다는 것이 무슨 말인지 알게 되었다.한동안 퇴근하고 나면 눈감고 노래만 듣다가 잠을 자기도 했었는데 노래듣기가 취미 생활이 될 수 있다는 말은 진짜인 것 같다.조직에서의 개발자2021년에는 2년차 개발자로서 한해를 보냈다.원격근무2021년의 조직 생활을 뒤돌아보면 가장 먼저 떠오르는 것은 원격근무 이다.2021년에는 모두 원격근무를 했다. 2020년에 이미 조직에 적응한 상태라, 조직 적응에 대한 어려움은 없었다.하지만 업무와 생활의 분리는 쉽지 않았으며, 업무에 대한 집중도는 떨어질 수 밖에 없었다.출근하기 10분 전에 일어나는 경우도 많았고, 저녁에 퇴근하고 그냥 업무를 하는 경우도 다반사였다.원격근무를 하니 집 밖에 나갈 일도 줄어들고, 건강도 많이 나빠졌다. 원격근무 라는 상황이 여러모로 나에게는 독이었다.이를 해결하고자 몇차례 출근을 하기도 했는데, 국내 코로나 확진자 1000명이 넘은 이후로 다시 원격근무를 하고있어 아쉬웠다.PR 리뷰우리 조직의 좋은 문화중에 하나가 리뷰 문화라고 생각 했었다. 이유는 다음과 같다. 버그가 될 부분들을 캐치해내는 경우가 많다. 더 좋은 코드로 개선되는 경우가 많다. 리뷰 시 상대방이 싫어할만한 뉘양스의 리뷰는 한번도 보지 못했다.주변 다른 개발자들의 조직에서의 리뷰문화를 들어보았을 때도 우리 조직보다 좋은 사례를 들어보지도 못했다.그런데 연말에 조직 내에서 ‘우리 조직의 코드리뷰가 형식적인 것 같다’ 는 말이 나오게 되면서, 나의 코드리뷰에 나쁜 습관도 되돌아보게 되었다. 리뷰어가 많으면 리뷰어로서 관심이 낮아짐.우리 조직의 구성원은 12명이다. 어떨 때는 PR에 8명 이상씩 리뷰어로 달리는 것도 있는데 이럴 때는 관심도가 낮아지더라. 조직 내에서 리뷰를 8명 이상씩 다는 경우는 보통 공유용 PR이 많았던 것 같다. 리뷰를 받기 위해서 PR을 만든거라기 보다는 공유목적으로 한건가 라는 생각이 더 먼저 들 때가 있다. 이럴 때는 코드를 훑어보는 느낌으로 하는 것 같고, 이에 좋은 리뷰를 다는 경우가 없었던 것 같다. 리뷰를 빠른 시간 내에 시작하지 않음.좋은 리뷰문화와 관련된 글을 보면 리뷰는 최대한 빨리 시작하라고 한다. 주된 이유는 리뷰받는 동료는 리뷰가 완료될 때 까지 Block상태가 되기 때문이다. 이에 리뷰어는 코딩하던 것을 잠깐 중단하고 리뷰를 시작할지 잘 판단해야 한다. 나는 이부분에서 이기적인 면이 있었던 것 같다. 코딩하던 것을 중단하고 코드리뷰를 하고 오면, 다시 작업을 이어가기가 어렵다. 집중도 떨어지고, 문맥도 까먹는 경우가 많았다. 그래서 작업하던 것을 다시 살펴보는 경우가 많았다. 이런 경험들이 나는 싫어서 현재 하던 것을 마무리 짓고 리뷰를 시작하는 편이었다. 그러다보니 리뷰 시작하는 시간이 길어지는 경우가 있고, 심지어는 리뷰를 해야한다는 사실조차 까먹고 퇴근할 때가 더러 있었다. 조직 내에서는 워킹데이 1일 이내로 리뷰를 남기자. 조직에서 새로운 룰이 생겼다. 다행히도 나의 잘못된 습관을 2022년에는 개선하는데 도움이 될 것 같다. 점심시간 이후 / 화장실 다녀온 후 와 같이 리프레시가 되는 시간 에는 리뷰를 시작할 수 있는 포인트인 것 같다. 나의 조직 영향력개발자로서 조직 문화를 개선하는 것은 누구나 당연히 해야할 일이다. 올해 나의 조직 영향력은 적었다고 생각한다. 내가 팀문화를 개선시킨 부분이 적었다. 자동화하여 팀 생산성을 높인게 적었다. 신입크루를 신경쓰지 못했다.왜 적었나.1) 팀문화변화시킬 자신이 없었다. 우선 아래와 같은 이유로 우리 조직이 거대한 바위처럼 느껴졌다. 조직에는 연차가 오래된 된 경력자분들이 많이 계신다. 조직은 12명이나 된다. 나는 이번 회사가 첫 회사다. (무엇이 문제인지조차 알기 어렵다.)나는 이미 마음에서부터 안될 것이라고 단정지어버리고 있었다.2) 자동화 자동화와 관련되서 생산성을 향상시킬 아이디어는 몇개 있었다. 하지만 실천을 하지 못했다. 2022년에는 생각해둔 것들을 구현하고 조직내 공유를 해야겠다.3) 신입크루 내가 입사한지 3개월 뒤에 2021 공채신입으로 한분이 들어왔다. 당시 나는 뉴크루의 조직 적응에 적합한 사람이었다. 뉴크루 가이드 문서를 내가 작성하기도 했고, 해당 문서에 부족한 부분도 내가 잘 알기에. 보완하거나 직접 알려줄 수 있는 부분들도 많았다. 하지만 내 업무에 신경쓰느라 챙겨주지 못했던 것 같다. (그래도 시니어분들 덕분에 조직적응은 잘 하신 것 같아 다행이다.)2022년에는 책이나 좋은 글들을 많이 찾아 읽어야 하겠다.공채 코드리뷰어2022년에는 조직에 신입공채 한분이 합류하신다. 나는 2022 공채신입 코드리뷰어로 활동하고 있다.코드리뷰어로 지원한 동기는 뉴크루의 역량을 향상시켜줄 수 있을 것이라는 자신이 있었다. 성장은 결국 본인 몫이긴 하지만, 무엇을 알아야하는지에 대해서는 최소한 다른 리뷰어에 꿀리지 않게. 뉴크루가 자랑스러워 할 수 있게 할 자신은 있었다.코드리뷰 할 때는 코드를 개선하기 위한 목적보다는, 정말 교육 목적으로 리뷰를 진행하고 있다.앞으로 한달 이상 리뷰어로 활동을 할 예정인데, 어쩌면 이것이 조직에 영향력을 불어넣는 시발점이 될지도 모르겠다.목적조직과 기능조직개발자는 두가지 마인드셋으로 나눌 수 있을 것 같다. 개발자는 개발을 하는 사람이다. 개발자는 서비스를 만드는 사람이다.나는 자소서 쓸 때 개발자는 서비스를 개발하는 사람이라고 적었던 것 같다. 그리고 대부분의 개발자가 나와 비슷할거라 생각했는데, 내 경험으로는 전혀 반대였다.우리 조직이 기능조직 이라서 그런건지는 모르겠지만, 개발자가 이 프로젝트를 하는 이유에 대해서 필요성을 느껴서 하기보다는, 기획에서 내려진 과제를 그냥 구현하는 사람인가 하는 생각이 든다.다음번에는 규모가 적은 목적조직에서 서비스 개발을 해보고 싶다.조직 밖에서의 개발자2021년에는 무엇을 학습했나 서적: 엘레강트 오브젝트 서적: 자바 코딩의 기술 NextStep - 이펙티브 코틀린 스터디: 클린 아키텍처 서적 스터디: 대용량 서비스를 위한 아키텍처 강의 (ing)2021년에는 상반기에는 학습을 하다가, 하반기에는 개발공부를 손놓았던 것 같다. 깃헙 잔디가 그걸 증명해주고 있다.몇년 뒤엔 CTO를 해봐야하지 않을까..처음 입사했을 때는 스스로 경쟁력 있는 신입이라고 생각을 했었다.그런데 지금의 나는 경쟁력 있는 경력자 가 아닌 것 같다.현재로써는 이렇다 할 나만의 강점이 없는 것 같다고 생각하기 때문이다.지금 나에게 가장 필요한건 내적동기 이다.나는 동기 없이는 잘 행동하지 않는 타입이고, 2021년에는 공부를 해야하는 동기가 턱없이 부족했다.구체적인 목표 와 그 목표를 이루겠다는 전략 이 필요한 것 같아 고민하다가, CTO 를 해야겠다. 라고 생각했다.CTO가 되기 위한 구체적인 목표를 세우기에는 너무 이르지만, 이 목표는 오늘 하루를 그냥 흘려보내면 안될 것 같다 는 생각을 갖게 해준다. 올해 말에 다시 학습을 시작한 것도 이 목표 덕분이었으니 지금은 이걸로 동기는 충분하지 않을까 싶다.어쨌거나 2021년은 앞으로의 개발자 커리어 통틀어 최악의 해로 선정되지 않을까 싶다.ㅋㅋ 이런 부끄러운 기록들이 발목잡는 날이 올지도 모르겠으나, 2022년에는 그만큼 2021년에 쌓아두었던 학습부채를 청산하기를 바란다." }, { "title": "고양시 노고산 백패킹", "url": "/2021/08/15/%EA%B3%A0%EC%96%91%EC%8B%9C-%EB%85%B8%EA%B3%A0%EC%82%B0-%EB%B0%B1%ED%8C%A8%ED%82%B9/", "categories": "백패킹", "tags": "", "date": "2021-08-15 16:45:38 +0000", "snippet": "장소: 고양시 노고산일시: 2021/08/14 ~ 15인원: 2 출발첫 백패킹이다 보니 친구와 함께 갔다.(사실 가방도, 텐트도 없어서 같이 가야했다. ㅋㅋㅋ)가방 무게를 재보니 10kg. 이정도면 할만한 듯!가는길에 종로5가에 있는 마이기어 에서 맥주 쿨러 Get.지하철/버스 를 타고 등산로 입구인 흥국사까지 갔다. 흥국사 가는 길엔 emart24가 있는데, 문이 닫혀있다. 안에 물건도 거의 없어 보이던데 장사를 안하는 듯. 흥국사에 도착하니 16시 40분쯤 되었다. 등산모기기피제 를 온몸에 도포하고서는 등산을 시작했다.모기가 굉장히 많았는데 신기하게 한방도 물리지 않았다. 그동안 폭염이라 걱정했었는데, 등산가는 날 딱 폭염주의보가 해제되었다.실제로 산에서는 바람도 선선하니 불어서 초가을 같은 느낌이라 너무 좋았다. 등산길에 곱등이들이 많이 보였다.처음에는 놀라서 소리를 지르다가 등산스틱을 이용해 쪼까보내려고 했는데 꿈쩍도 하지 않는다.난 소갈딱지인데 너네는 그릇이 크구나.. 정상까지 도착하기 위해서는 3개의 표지판을 마주해야 한다. 드디어 도착.인터넷으론 1시간 30분 ~ 2시간 걸린다고 하였는데, 1시간 20분이 걸렸다. 아무도 없어서 전세캠인줄 알았으나, 텐트를 치고나니 4팀이 더 왔다. 😭 야영여긴 LTE가 안되더라. 3G도 잘 안되고.. 한번씩 알람이 울리긴 하는데, 인터넷 검색 같은건 못한다고 보면 될 것 같았다.텐트 안에서 누워있다가 해가 완전히 질때 쯤 저녁을 준비했다.산이라서 당연히 비화식만 가능할 줄 알았는데, 어디선가 이소가스 소리가 들렸다.총 5팀 중에 3팀이 화식이었다.산에서도 화식 이 가능한가보다. 우리는 화식 부럽지 않게 양껏 먹었다. 먹을거: 족발 600g + 우동(+어묵) 2인분 + 부대찌개 + 육포 마실거: 위스키 + 소주야들야들한 족발에 소주를 부르는 부대찌개 국물. 크… 👍👍👍다음에 백패킹가면 또 족발과 부대찌개는 꼭 가져가려고. 9시가 되니 주변에 다른 텐트들의 불이 꺼지길래 우리도 정리했다.10시 전에 잠든 듯 하다. 기상5시 조금 넘어서 일어났다. 주변에 사람들 말소리 / 바스락 소리에 저절로 눈이 떠지더라.자는동안 어떤 생물이 계속 울어대서 이어플러그를 끼고 잤다. 곧 해가 뜰 기미가 보여 의자에 앉아 있었다. 여름인데도 꽤 쌀쌀하여 침낭라이너를 걸쳤다.해가 떠오른다. 다들 찍길래 나도 친구폰으로 찍음.고양시 일출 시간은 5시 49분 이었으나, 앞에 산이 있다보니 6시가 되어서야 일출을 볼 수 있었다. 해 뜨는걸 보고는 바로 하산을 준비했다.등산객들을 위해 텐트를 빨리 철거하는게 좋다고 한다.실제로 해를 보기 전에 등산객 한팀이 도착해있어서 당황했다.. LNT(Leave No Trace) 실천 ! 하산하산할 때는 물, 음식의 무게가 줄어드니 가방이 훨씬 가볍다.쓰레기는 클린백에 담아서 가방에 매달아왔다. 무릎 방지를 위해 등산스틱을 이용해 조심조심 내려왔다.나는 숙련도가 낮아서 등산스틱을 이용해도 무릎이 보호되는 느낌이 전혀 없었다.내려오고 나니 다리가 후들후들… 왜, why? 🤔 마무리버스 / 지하철을 타고 2시간 정도 이동하여 집으로 왔다.집에 와서 친구와 떡튀순을 먹는데 꿀맛!샤워하고 나니 나른나른하니 기분이 너무 좋다.가방에서 씻을 건 씻고, 페브리즈 뿌리는 등 후처리(?) 를 했다.그리곤 이 글을 쓰는 중이다. 또 가고싶다아아아.다음 백패킹은 어디로 !? 아쉬운 점 먹을 것을 너무 많이 챙겼다. 먹지 않고 도로 들고온 것들이 많았다. 물을 2L 씩 가져갔는데 부족한 느낌이었다. 난 물먹는 하마인가 친구와 같이가니 혼자 생각하는 시간이 거의 없었다. 백패킹의 매력이 반감된 것 같아 아쉬웠다. 하산할 떄 무릎보호대가 필요해 보였음. 하나 구매해야겠다. 애플워치로 등산 기록을 남기려 했는데, 깜빡하여 집에 놔두고 갔다. 다음엔 꼭 챙겨야지. 휴대폰 카메라가 고장나서 사진을 하나도 못찍었다. 폰 새로 사면 많이 찍어야지" }, { "title": "2021년 25주차 회고", "url": "/2021/07/11/2021%EB%85%84-27%EC%A3%BC%EC%B0%A8/", "categories": "회고", "tags": "", "date": "2021-07-11 23:39:38 +0000", "snippet": "스스로 칭찬 주도적으로 하고 싶은게 생김. 사내서비스의 통계 시스템의 성능 개선을 위해 하둡을 익히고 있다. 주어진 업무가 아니라서 좀 더 여유롭게 학습하는 중. 돈 관리 저축용 돈을 따로 분리함. 앞으로의 지출이 줄어들기를 기대하며. 아쉬웠던 점 헬스 등록 하지 않은 것 다이어트/건강 을 위해 헬스를 계획했었다. 출근하기 전 오전에 헬스를 해야겠다는 생각만 하다 지금까지도 등록하지 않았다. 현재 코로나 확진자 1200명을 생각하면 등록하지 않은게 오히려 잘된 것 같기도 하다. 1년차 개발자 인턴까지 포함하면 입사한지 벌써 1년이 지났다. 난 지금껄 뭘 했나.. 하는 생각이 계속 머릿속에 맴돈다. 다음주 나에게 바라는 점 1년차 회고를 적으면 좋겠음. 사내에서 상반기 회고를 했는데, 1년차 회고를 해보면 좋겠다. 주회고 양식을 없애는 것을 고려해보자. 너무 양식에 맞게 적으려니 많은 것들을 기록하지 못하는 것 같다. " }, { "title": "2021년 25주차 회고", "url": "/2021/06/27/2021%EB%85%84-25%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-06-27 23:56:24 +0000", "snippet": "스스로 칭찬 폴가이즈 1등 드디어 이번주에 폴가이즈 1등을 하게 되었다. 1번 하고나니 2번부터는 쉬웠다. 피부 개선 요새 피부가 안좋아서 관리를 하고있는데 평소보다 많이 좋아진 것 같다. 아쉬웠던 점 학습한 것 딱히 학습한 게 없는 것 같다. 저녁에 혼자 술을 먹다보니 학습이 뒷전이 된 것 같다. 늦은 취침 / 늦은 기상 자연스럽게 취침시간과 기상시간이 늦어지고 있다. 요새 출근도 10시에 했다. 에어컨 배송 6월 7일에 주문한 에어컨이 아직도 도착을 하지 않았다. 주말에 너무 더워서 아무것도 하기가 싫은 느낌이 들어 아쉽다. 과한 지출 요새 돈을 너무 많이 쓰는 것 같다. 쇼핑은 언제나 재밌고, 통장잔고를 볼 때마다 놀라게 된다. 건강검진 결과 건강검진 결과가 나왔는데 내가 비만이라고 한다. 슬슬 운동을 해야하지 않을까 하는 생각이 들었다. 다음주 나에게 바라는 점 25주차 회고를 작성하면 좋겠음 진행중인 프로젝트 집중하기 헬스 등록" }, { "title": "2021년 24주차 회고", "url": "/2021/06/20/2021%EB%85%84-24%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-06-20 23:44:32 +0000", "snippet": "스스로 칭찬 클린 아키텍처가 긴 시간 끝으로 마무리지었다. 스터디를 진행하면서 아키텍처적인 부분에서 사고를 할 수 있는 계기가 된 것 같아 좋다. 이해되지 않는 내용도 많았기에, 6개월 뒤에 또 읽어본다면 느낌이 색다르지 않을까 싶다.   학습한 것 클린 아키텍처 스터디 오래 걸렸지만, 끝까지 마무리짓게 되어 좋았다.   아쉬웠던 점 늦은 취침 / 늦은 기상 이번주에는 늦게 자는 날이 많아진 것 같다. 더운 방 밤에 자면서도 더워서 깨곤 했다. 더위가 숙면을 방해하고 있다. 에어컨을 구매한지 12일이 지났는데 파업때문에 아직도 택배가 도착하지 않은게 너무 아쉽다. 23주차 회고를 하지 않음 주말에 중학생 때 친구들과 만나서 노느라 귀찮음을 핑계로 회고를 하지 않았다. 일주일의 계획을 지키지 않는 것 같다. 22주차 계획했던 헥사고날 아키텍처를 하지 않음 22주차 계획했던 쿠버네티스 컨트롤러 정리를 하지 않음 폴가이즈 심심할 때마다 폴가이즈를 하곤 한다. 아직 우승을 1번도 하지 못한점이 아쉽다. 지라 이슈 몇달 전에 사내 서비스에 버그성 이슈를 발견하곤 지라 티켓을 만들어놓은 적이 있다. 오늘 보니 아직도 처리하지 않은 것을 알게되었다. 현재 진행중인 프로젝트에 집중하는게 맞는 것 같아 처리하지 않았는데, 너무 오래동안 방치해뒀던 것은 아쉽다. 버그 개선을 사이드 프로젝트라고 생각하고 심심할 때 처리하면 어떨까 싶다. 이럴 때 클린아키텍처적인 고민도 함께 할 수 있지 않을까   다음주의 나에게 바라는 점 25주차 회고를 작성하면 좋겠음 스터디도 끝났는데, 다음 학습은 MySQL이 좋을 것 같다. 사실 다 해야한다. 할게 너무 많이 밀려있다. 슬기로운 의사생활 챙겨보기" }, { "title": "2021년 22주차 회고", "url": "/2021/06/06/2021%EB%85%84-22%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-06-06 23:59:01 +0000", "snippet": "스스로 칭찬 8시 출근 / 17시 퇴근 8시 ~ 8시30분에 출근을 하니 업무효율이 좋은 것 같다. 저녁시간대에 집중렬이 흐트러지는 문제가 해결된 것 같다. 덕분에 출근 시 이용하는 대중교통도 쾌적하다. 요새 업무할 때 맥북 화면에는 모니터링툴을 켜두곤 하는데, 모니터링하다가 버그를 찾았다. 버그의 정확한 원인은 파악하지 못했지만, 모니터링툴을 켜놓음으로 인해 버그를 찾아서 뿌듯했다.   학습한 것 클린 아키텍처 스터디 24, 25, 26, 27, 28장 스터디   아쉬웠던 점 무의미한 토요일 무의미하게 집에서 하루종일 누워서 시간을 보냈다. 원인은 수면부족 / 피로가 쌓였던 탓인 것 같다. 뚝딱뚝딱 학습법 부재 학습한 것을 기록하는 공간에 추가로 기록된 것이 없다. TODOLIST만 계속 늘어만 갔다… 헬스 헬스를 다니고 싶지만, 코로나 때문에 고민이다. 헬스를 하다가 코로나에 걸리면 출근하는 것은 민폐를 끼치는 것이라, 헬스와 출근 중 양자택일을 해야 한다.   다음주의 나에게 바라는 점 23주차 회고를 작성하면 좋겠음 헥사고날 아키텍처 학습/정리 쿠버네티스 컨트롤러 정리" }, { "title": "2021년 21주차 회고", "url": "/2021/05/30/2021%EB%85%84-21%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-05-30 23:38:01 +0000", "snippet": "스스로 칭찬 빠른 취침 &amp;amp; 빠른 기상 을 했다 이미 몸이 적응한 상태인 것 같다 근무 몰입도 개선 오피스 근무가 시간가는 줄도 모르게 업무를 하는 것 같다 재택 근무와 너무 비교된다 주말에 싸피 친구들과 모각코한 것 학습과 안부묻기를 함께 하니 좋았다 아침밥을 잘 챙겨먹은 것 쌀밥은 아니더라도 뭐라도 챙겨먹었다 정 먹을것이 없을 때는 회사에서 토마토주스 / 두유라도 먹었다   학습한 것 클린 아키텍처 스터디 22, 23장 에 대해 토론함 24, 25, 26, 27, 28장 읽음 포트 &amp;amp; 어댑터 아키텍처 Html Escape vue에서는 어떻게 Html Entity로 escape 처리하는지 스프링 배치 ItemReader (Cursor와 Paging)   아쉬웠던 점 적은 학습량 여전히 학습량이 만족스럽지 않다 학습량 개선을 위해 환경을 이것저것 바꿔보고있다 스터디카페를 가지 않음 이번주도 스터디카페를 한번도 가지 않았다 클린아키텍처 스터디 느린 진도 일정에 부담가지지 않기 위해 서로 공부한만큼만 스터디하기로 했지만, 너무 오랫동안 붙잡고 있는 것 같다고 느낌 다음번에 스터디할 때는 미리 일정을 산정해보는 것도 좋겠다 회고할만한 소재들을 간단하게라도 미리 적으면 좋겠다 일주일동안 있었던 일들을 갑자기 생각하려니 놓치는 것들이 많은 듯 하다   다음주의 나에게 바라는 점 22주차 회고를 작성하면 좋겠음 빠른 출근 &amp;amp; 빠른 퇴근 &amp;amp; 저녁에는 스터디카페로 출근 출근할 때 빠르면서도 버스에 앉아서 갈 수 있는 시간대/경로 구하기 고민하지 말고 그냥 학습하기 평소에 회고할만한 것들은 간단하게(단어라도) 기록해두기 헥사고날 아키텍처 학습/정리 쿠버네티스 컨트롤러 정리" }, { "title": "2021년 20주차 회고", "url": "/2021/05/23/2021%EB%85%84-20%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-05-23 23:42:56 +0000", "snippet": "스스로 칭찬 평소보다 일찍 일어난 것 기상시간이 2시간정도 빨라졌다 근무 몰입도 개선 집에서 근무하는데 일이 잘 안되서 회사로 출근했다 인턴 때 느낌도 나고, 일하는데 몰입이 훨씬 잘 된다 활동량 증가 회사 출근하면서 걷는시간도 늘었다 회사 점심먹은 이후 10-20분 정도 걸었다 토/일 에는 거리가 좀 떨어진 카페로 걸어서 다녀왔음 집에서 팔굽혀펴기를 틈틈히 했다 유튜브 시청 시간 줄이기 지난주 유튜브 시청시간을 줄이고 싶었고, 일부러 유튜브를 키지 않으려고 했다 시청 시간이 많이 줄었다   학습한 것 클린 아키텍처 스터디 19, 20, 21장 에 대해 토론함 쿠버네티스 파드 정리  아쉬웠던 점 얼또 여전히 얼또를 하지 않았다. 회사에 빨리 출근을 할지 / 얼또를 할지 고민만 하다가.. 둘 다 하지 못함 적은 학습량 학습량이 늘지 않았다. 몸을 어디에 가둬놓아야 할 듯 적었던 업무 처리량 이번주에 처리한 업무량이 너무 적다. 스터디카페를 가지 않음 스터디카페를 100시간 등록해놨었는데, 이번주에는 한번도 가지 않았다.    다음주의 나에게 바라는 점 21주차 회고를 작성하면 좋겠음. 건강검진 잘 받기 오피스로 처음 출근하시는 셀분 가이드 잘하기 아침밥 잘 챙겨먹기 얼또 하기!! 스터디카페 가기 출근전/퇴근후 책읽으러 가면 좋을 듯하다. " }, { "title": "2021년 19주차 회고", "url": "/2021/05/16/2021%EB%85%84-19%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-05-16 22:58:56 +0000", "snippet": "스스로 칭찬 매일 한번씩은 식후 산책한 것 매 끼니마다 산책하지는 못했지만, 활동량을 높이는데 도움이 된 것 같다. 저녁먹고 걸으니 산책하는 사람들이 엄청 많음을 알게 되었다. 식습관 개선하고자 하는 의지 밀가루/매운음식/과식 을 꺼려하게 되었다. 평소보다 일찍 잠든 것 평소에는 새벽2시쯤에 자곤 했었는데, 10~11시 쯤에 잠을 자게 되었다. 소주 대신 맥주를 마신 것 토요일에 친구 결혼식이 있어, 뒷풀이로 술을 먹었다. 묘기증 때문에 소주 대신 맥주를 조금 마셨다. 나무 대신 숲 기존: 출근 시 나의 지라 이슈를 확인한다 이번주: 출근 시 나의 지라 이슈 및 프로젝트 에픽의 이슈들을 확인했다 한약을 빼먹지 않고 챙겨먹은 것  학습한 것 클린 아키텍처 스터디 17, 18장 에 대해 토론함 클린 아키텍처 독서 다음주 스터디를 위해 19, 20, 21장 읽음   아쉬웠던 점 얼또 계획: 10~11시 쯤에 자서 6시에 일어나기. 6시~9시 까지 얼또하기 8시까지 잠을 자는 바람에 얼또를 하지 않았다. 성장의 기회를 놓쳤다. ㅜ 적은 학습량 학습량을 늘릴 필요가 있어보인다. 적었던 업무 처리량 이번주에 처리한 업무량이 너무 적다. 사내 테스트환경 / 쿠버네티스 배포 등 처음 접하는 것들에 시간을 많이 소비하게되면서 이슈를 처리하는데 지연된 것 같다. 유튜브 시간이 너무 많다 뭐 할거없거나 심심하면 유튜브를 봤다. 취업 이후 유튜브 시청시간이 매우 늘어난 것 같다. 앞으로의 성장을 방해하는 요소 1순위인 듯   다음주의 나에게 바라는 점 20주차 회고를 작성하면 좋겠음. 묘기증 개선을 위해 아래 3가지를 지켰으면 좋겠음. 점심먹고 10분 걷기, 저녁먹고 30분 걷기 11시 이전에 잠자리에 들기 닭고기 / 밀가루 / 음주 없이 살아가기 아침밥 잘 챙겨먹기 얼또 하기!! 유튜브 시청시간 줄이기" }, { "title": "2021년 18주차 회고", "url": "/2021/05/09/2021%EB%85%84-18%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2021-05-09 17:58:56 +0000", "snippet": "스스로 칭찬 회고를 다시 시작한 것 스스로를 판단하고 평가하여 더 나은 내가 되기 위해 스스로를 칭찬하는 것도 자존감을 높여주는 것 같아 굿굿 중학교 친구와 매주 스스로를 회고하여 서로 공유하기로 함 먹는 것의 중요성에 대해 느끼기 시작한 것 몸이 망가지다보니, 먹을 것에 대한 중요성을 느끼게 되었다. 부산에 내려온 후 비교적 밥을 잘 챙겨먹고 있음. 부산에 내려와 가족과 시간을 보내는 시간이 늘어난 것 부산에서 재택을 하고 있다. 혼자 생활하는 것보다, 누군가와 함께 지낸다는 것에 대한 소중함을 느끼고 있다. 동네 친구들을 만나 시간을 보낸 것 오랫만에 동네 친구들과 시간을 보낼 수 있어서 좋았다. 옛날에는 함께 만나서 이야기 나누는 시간들의 소중함을 몰랐는데, 오랫만에 만나서 그런지 친구들과 함께 보내는 시간들이 너무 좋았다. 한의원에 진료를 받으러 간 것 원장님에게 잔소리를 많이 들었지만, 그 덕분에 건강 개선 필요성에 대해 스스로 느끼게 되어서 좋았다. 뚝딱뚝딱 저장소를 만든 것 학습하는 것에 대한 단일 저장소를 만들어 잘 관리하기 위해 깃 레파지토리를 만들었다. 앞으로 체계적으로 학습하는데 도움이 되면 좋겠다.   학습한 것 클린 아키텍처 독서 다음주 스터디를 위해 17, 18장 정리 이벤트 기반 마이크로서비스 구축 독서 챕터1 읽고 정리 주관적인 의견이 없는 단순히 책을 내용을 정리한 것 같아 아쉬움이 남음. 이벤트에 대한 지식이 부족해서인 듯. 아직 ‘이럴 때 이벤트로 처리하면 좋겠다’ 하는 개념이 없음.   아쉬웠던 점 건강하지 못한 몸의 상태 묘가증이 3개월 째 이어지고 있다. 3개월 째 항히스타민제에 의존하고 있음. 손과 발이 쉽게 저리고, 주먹을 쥐고 힘을 주어도 힘이 안들어감. 불규칙한 수면시간 한의원에서는 간이 몸을 해독하도록 11시 이전에 숙면에 들어가는 것이 좋다고 했다. 하지만 아직 11시 이전에 자본 적이 없다. 마음도 건강하지 못한 상태 몸이 건강하지 않다보니 마음도 건강하지 않은 것 같음. 업무 할 때 시간을 알차게 보내고자 하는 의지가 없음. 일의 우선순위 일의 우선순위를 잘못 판단하여 급히 처리해야 하는 이슈를 늦게 처리함. 앞으로 무엇을 학습하면 좋을지, 커리어에 대한 확신이 없음. 1년차 개발자로써 무엇을 학습하면 좋을지에 대한 우선순위가 없음. 그냥 할 뿐임. 피드백이 있으면 좋겠지만, 딱히 커리어에 대해 조언을 구하는 관계를 가진 사람이 없음. 멘토가 있으면 좋겠다. 현재 진행중인 프로젝트를 크게 보려고 하지 않았다. 개별 이슈에 대해서만 관심을 가졌고, 전체 프로젝트는 얼마나 진행되었는지, 장애물은 어떤 것들이 있는지에 대해 생각을 하지 않은 것이 아쉽다. 헤드폰으로 노래를 듣지 못하고 있다. 헤드폰으로 노래를 듣곤 했었는데, 부산에서는 그러지 못해 아쉽다. 들고오기엔 부피가 너무 커서 아쉽다.   다음주의 나에게 바라는 점 19주차 회고를 작성하면 좋겠음. 묘기증 개선을 위해 아래 3가지를 지켰으면 좋겠음. 식후 30분 걷기 11시 이전에 잠자리에 들기 닭고기 / 밀가루 / 음주 가 없이 살아가기 얼또 하기 얼또를 하면 11시 이전에 잠드는데 도움이 될 것 같음. 출근 시 지라 이슈를 보면서 일의 우선순위 조정해보면 좋겠음. 일을 좀 더 체계적으로 했으면 좋겠음. 프로젝트를 좀 더 큰 시각으로 바라보면 좋겠음. ‘나무’만 보지 말고 ‘숲’도 보기" }, { "title": "스프링 예외처리 (핸들러, 인터셉터, 필터)", "url": "/2021/02/12/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-(%ED%95%B8%EB%93%A4%EB%9F%AC,-%EC%9D%B8%ED%84%B0%EC%85%89%ED%84%B0,-%ED%95%84%ED%84%B0)/", "categories": "Spring", "tags": "", "date": "2021-02-12 16:36:39 +0000", "snippet": "스프링을 공부하다보면 위와 같은 사진을 자주 접한다.특이점은 Handler 에서 발생하는 예외를 HandlerExceptionResolver에서 catch한다는 것을 알 수 있다. 그럼 이런 궁금증이 생긴다. 1) HandlerInterceptor 에서 예외가 발생하면 어떻게 될까? 2) Filter 에서 예외가 발생하면 어떻게 될까? 이 글은 다음 내용을 다루고자 한다. 핸들러 안에서 예외가 발생하는 경우 어떻게 처리할까 ? 핸들러 밖에서 예외가 발생하는 경우 어떻게 처리할까 ? HandlerInterceptor에서 예외 발생 Filter에서 예외 발생  (용어정리)핸들러 는 컨트롤러(controller) 에서 @RequestMapping 어노테이션이 붙은 메서드를 의미로 사용했음. 핸들링 은 에러를 회복한다는 의미로 사용했음.1. 핸들러 안에서 예외가 발생하는 경우 어떻게 처리할까 ?핸들러 안에서 비즈니스 로직 을 수행하다보면 다양한 예외( DB 요청 / 다른 API 요청 / 외부 라이브러리 사용 등) 가 발생할 수 있다. 1) 비즈니스 로직에서 발생하는 예외 예시@Service@AllArgsConstructorpublic class ChannelService { // ... public Channel getChannel(String channelId) { return channelRepository.findById(channelId).orElseThrow(ChannelNotFoundException::new); // channelId로 채널을 찾지 못하면 예외 발생 }}public interface ChannelRepository extends JpaRepository&amp;lt;Channel, String&amp;gt; { Optional&amp;lt;Channel&amp;gt; findById(String id);}어떻게 처리할까?클라이언트가 API서버에 채널id로 채널정보를 요청하는 부분이라고 가정해보자.그렇다면 사용자가 요청한 채널id가 존재하지 않는 경우 이를 잘 표현하는 HTTP 상태코드와 본문을 반환하는 것이 이상적일 것이다. 2) 외부 라이브러리 에서 예외를 발생하는 예외 예시package org.apache.commons.lang.math;import ...public class NumberUtils { public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(&quot;A blank string is not a valid number&quot;); } // ... } // ...}createNumber(String str) 는 문자열 타입의 숫자를 Number 타입으로 변경시켜주는 라이브러리이다.(eg. NumberUtils.createNumber(&quot;12345&quot;))숫자로 변형이 불가능한 값이 오는 경우(NumberUtils.createNumber(&quot;abcde&quot;)) NumberFormatException 이 발생한다. 어떻게 처리할까?먼저, 위 1) 비즈니스 로직에서 발생하는 예외의 경우 에서 언급한 것과 같이 적절한 HTTP 상태코드와 본문을 반환하여 처리할 수 있다. 두번째로는, 아래의 방법으로 처리하는 것도 가능하다. // ... 비즈니스로직 private int parseInt(String number) { int result = 0; try { result = NumberUtils.createNumber(number); // Apache Commons Library } catch (NumberFormatException e) { log.error(e.getMessage(), e); } return result; } 외부 라이브러리(NumberUtils)에서 예외를 발생시키지만, parseInt(String number) 메서드)는 예외가 발생하면 0 값으로 처리하고 있다.val numberA = parseInt(&quot;abc&quot;) // numberA는 0이다.위의 경우 잘못된 숫자(abc) 를 입력하여 예외가 발생하지만, 0으로 회복된다.따라서 parseInt(String number) 를 사용하는 곳에서는 내부에서 예외가 발생했었는지도 알지 못하고 알 필요도 없다. 두 방법 중 어떤것이 적절한가는 비즈니스 상황에 따라 적절한 것을 선택하면 될 것이다.    2. 핸들러 밖에서 예외가 발생하는 경우 어떻게 처리할까 ?1) HandlerInterceptor 에서 예외가 발생하면 어떻게 될까?HandlerInterceptor 는 구현할 수 있는 메서드가 총 3가지다. preHandle postHandle afterCompletion 클라이언트의 요청 흐름은 다음과 같다. (DispatcherServlet 참고)Interceptor(preHandle) -&amp;gt; Handler -&amp;gt; Interceptor(postHandle) -&amp;gt;HandlerExceptionResolver(예외 복구) -&amp;gt; View 렌더링 -&amp;gt; Interceptor(afterCompletion) 따라서 Interceptor(preHandle), Interceptor(postHandle) 에서 예외가 발생할 때 @ExceptionHandler 로 핸들링할 수 있다. 여기서 궁금증이 하나 더 생긴다. Interceptor(afterCompletion) 에서 예외가 발생하면 어떻게 처리될까?=&amp;gt; @ExceptionHandler 로 예외를 핸들링할 수 없고, 로그를 남길 뿐 이다. (클라이언트로 응답은 이루어진다)HandlerExecutionChain.java // ... try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable ex2) { logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2); }  2) Filter 에서 예외가 발생하면 어떻게 될까?필터에서 예외를 던지면 핸들링은 어디서 어떻게 할까.=&amp;gt; 아래와 같이 HTTP 상태코드 500 으로 응답한다.java.org.apache.catalina.core.StandardWrapperValve.java private void exception(Request request, Response response, Throwable exception) { request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, exception); response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); // 상태코드 500 response.setError(); }단, 필터에서 예외를 던지더라도 500 상태코드로 응답하지 않는 경우가 있다. Response 객체가 이미 commit된 경우에는 상태코드/헤더 변경이 불가능하기 때문이다.(핸들러에서 @ResponseBody로 응답하는 경우 해당 객체를 응답 본문으로 변경이 필요하다. 이는 MessageConverter가 처리하게 되는데, OutputStream에 객체를 write하여 처리한다. 즉, 사용자에게 바로 응답이 가게되고 이 과정에서 Response는 commit이 이루어진다.)(대부분의 API는 HTTP 본문에 응답하는 경우가 많으니, Interceptor(postHandle) 에서 상태코드/헤더를 변경이 불가능할 수 있다는 점은 기억하고 싶다.)  이 글은 조사했던 부분을 기록하기 위해 작성하였으며 독자에게 도움이 됬을지 모르겠다.만약 도움이 안됬다면 스프링 프로젝트에 Filter/Interceptor 를 추가하여 직접 디버깅 해보는 것을 추천한다." }, { "title": "NextStep JWP 2기를 시작하며", "url": "/2020/06/05/NextStep-JWP-2%EA%B8%B0%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0/", "categories": "회고", "tags": "", "date": "2020-06-05 23:55:39 +0000", "snippet": "삼성 청년 소프트웨어 아카데미(SSAFY) 2기를 그만둔 지 한 달이 지났다. 그만둔 이유에 대해서는… 훗날 작성할 예정이다.지난 15일에 SSAFY 마지막 교육 지원금 100만원을 받았고, 5일 후에 100만원 중 99만원을 NextStep JWP 2기 를 신청하는 데 사용했다. 값비싼 교육 과정을 듣는 데는 나름대로 이유가 있다.본 교육을 진행하시는 분(aka.자바지기)은 우아한 테크 코스(우테코) 의 교육 책임자이기도 한데, 나는 지난 우테코 1기 지원자였다. 우테코는 교육생 선별 과정에서 3주간 프리코스를 진행한다. 프리코스는 매 주 간단한 미션을 구현하고 피드백을 받는 방식인데 매일 밤낮으로 좋은 코드에 대해 깊이 고민 하는 시간을 가지면서 많은 것을 느끼고 배웠었다. 3주차 때는 클래스를 나누는 기준이 너무 어렵게 느껴져서 객체지향의 사실과 오해 서적을 구매해 읽으면서 궁금증을 풀어나가기도 했다.프리코스를 3주간 진행한 후 오프라인으로 모여 4시간 동안 마지막 미션을 진행하게 되는데, 설계에 대한 고민만 계속하다가 동작하는 기능조차 만들지 못했다. 마감 시간 1시간이 남았을 때는 너무 갑갑하고 속상한 마음에 뒤로 나가서 몰래 펑펑 울었었다. 이때 나는 아무 코드도 제출하지 못했었다.당시 자바지기님이 여기서 떨어지더라도 낙담하지 말고 성공해서 나중에 복수하러 오라고 지원자들에게 말씀하셨었던 것이 아직도 기억에 남는다.이후 SSAFY를 활동하면서 우테코 2기를 지원했었는데 서류에서 통과하지 못했다. 그렇다고 3기를 기다리다니 너무 먼 시간처럼 느껴졌다. NextStep JWP 2기를 신청한 것도 아마 한이 많이 쌓였기에 신청하지 않았을까 싶다.NextStep JWP 1기 의 경우 약 2분 20초 만에 마감되었다고 한다. 혹여나 신청을 하지 못하면 어쩌나 하는 걱정도 있었으나 다행히도 신청할 수 있었다. 이틀 전 NextStep JWP 2기 과정이 시작되었다. 강남에서 오프라인 강의가 있었고 약간의 정신교육(?)과 첫 번째 미션의 Step1 을 진행했다.직장인분들이 많이 계신 것 같았는데, 업무 시간 이외에도 시간을 쏟아붓는 열정이 너무나도 멋있었다. 그리고 나는 그런 멋진 분들과 함께 있다고 생각하니 입꼬리가 올라가더라. 자바지기님도 일년만에 뵙게 됬는데 기분이 묘했다. 어제 Step2를 구현하면서 Http 완벽가이드를 읽기 시작했는데, 생각보다 내가 HTTP/1.1 에 대해서 잘 알고 있지 않았음을 느꼈다. Content-Length 를 Body의 byte 사이즈만큼 보내줘야 한다는 것을 알게 됨. Header 의 마지막 줄에는 빈 줄이 1개 있어야 함을 알게 됨. GET / HTTP/1.1 은 requestLine이고, HTTP/1.1 200 OK 는 responseLine 라는 용어를 명확히 알게 됨. 이 글을 쓰기 시작한 이유는 내가 NextStep JWP에 대해서 어떻게 생각하는지 한번 정리하는 시간이 필요했기 때문이다. 현재 나에게 주어진 환경은 너무나도 완벽하다. 성장을 위한 길은 잘 포장되어 있다. 이 길을 몇 걸음을 걸을지는 내 마음먹기에 따라 달렸다. 스스로 만족하는 기준점을 높게 잡아야 먼 길을 가지 않을까 싶다. 미션을 완수하는 것을 목적으로 두기 보다는, 미션을 수행하면서 느끼는 것들, 얻어갈 수 있는 것들, 무심코 지나칠 수 있는 것들에도 고민하며 정리하는 것이 나에게 더 도움이 될 것 같다. 물론 미션 완수는 Default 이다. 앞으로 7주간의 시간들로 개발 역량 뿐만 아니라 개발자로서의 가치관이나 다짐도 성장했으면 좋겠다." }, { "title": "마스크 구매 알리미 서비스 후기", "url": "/2020/04/19/%EB%A7%88%EC%8A%A4%ED%81%AC-%EA%B5%AC%EB%A7%A4-%EC%95%8C%EB%A6%AC%EB%AF%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%9B%84%EA%B8%B0/", "categories": "회고", "tags": "", "date": "2020-04-19 13:21:39 +0000", "snippet": "최근 개인 프로젝트를 하나 했다.마스크 구매 알리미 이다.각 커머스(네이버 스토어, 카카오 스토어, 쿠팡, 기타 마스크 쇼핑몰) 에 등록된 마스크 상품의 품절 여부를 주기적으로 확인하고, 해당 상품이 품절이 아닐 때는 링크를 보내는 서비스 이다. 사용자는 알람을 받으면 해당 링크를 눌러 구매를 하면 된다.  계기 코로나 때문에 SSAFY를 재택 학습으로 하고 있었다. 그런데 집에만 있어 보니 너무 우울해지더라.하지만 밖에서 밥도 사 먹고, 카페에서 공부도 하고, 친구들도 만나려면 마스크가 꼭 필요했다. 마스크를 구매하려고 휴대폰으로 알아보다가 비싼 가격에 깜짝 놀랐다.값싼 KF-94 마스크들은 항상 품절이었으며, 구매 가능한 상품은 개당 3~4천 원의 가격대가 형성되어 있었다.구매를 망설이다 급한 대로 편의점에서 면 마스크를 사다 쓰고, 아는 형에게 받은 KF-94 마스크 5장으로 연명하고 있었다. 그러다 뙇!!!!! 뇌리를 스치는 생각이 들었다.값싼 KF-94 마스크가 품절인데… ‘구매 가능할 때 바로 알 수 있다면 얼마나 좋을까?’나와 내 주변 사람들이 마스크 구매 걱정 없이 살아갈 수 있는 아름다운 아이디어였다.그래서 되든 안 되든 일단 시도해보기로 했다.  기억력이 나쁜 탓에 우여곡절을 글로 남기고 싶어 시작했는데, 이제 본론으로 들어가 보겠다.크게 개발, 배포, 운영, 한계 네 단락으로 나누었다. 개발 로직은 간단하다.상품의 품절 여부를 주기적으로 확인하고, 품절이 아닐 경우 알람을 보낸다. 품절 여부 확인품절 여부를 확인하기 위해서는 상품의 현재 상태 정보가 필요하다. Server Side Rendering 사이트의 경우에는 웹 스크래핑을 하였고,API가 따로 존재하는 경우에는 API로 HTTP Request를 날렸다.쿠키나 User-Agent를 별도로 추가해주어야 하는 경우도 있었다. 처음에는 하나의 스레드로 모든 상품을 돌렸는데, 한 상품의 주기가 너무 길어서 구매 확률이 낮아질 것 같았다.또한, 어떤 사이트는 1초에 1번의 요청만 허용하기도 했기에 각 상품을 1초 간격으로 돌린다면 구매 확률은 더욱 더 낮아진다.이에 각 사이트별 스레드를 생성하였으며, 각 스레드는 재고 상태 확인부터 알람 전송까지 담당하도록 하였다. 변수를 변경해야 할 때 추가적인 코드 배포 작업를 하지 않기 위해 각 사이트별 상품의 번호, 재고 상태를 체크하는 문자열, 요청 시간 간격 등의 변경될 가능성이 큰 변수들을 .env 로 관리했다. 알람사용자들이 알람을 어떻게 받는 것이 좋을까 ..처음 든 생각은 이메일과 카카오톡 이었다. 허나, 이 두 방법 모두 이 프로젝트에 적합하지 않은 방법이었다.이메일과 카카오톡은 즉각적으로 받아볼 수 없다고 판단했다.데이터를 긁어온 시점부터 알람이 도착하는 데까지 지연 시간이 길수록 구매 확률은 낮아진다.이 프로젝트에서는 1초도 매우 큰 시간이다. 구매 여부를 결정할 수 있기 때문이다. 슬랙은 테스트해보니 즉각적으로 받아볼 수 있었다.허나, 슬랙은 일반적인 사용자들에게 범용적이지 않은 플랫폼이었다. 개발자가 아닌 친구들에게 ‘슬랙을 아느냐’ 고 물어보면 모두 처음 들어본다는 답변을 받았다.하지만 마스크를 싸게 구매할 수 있다면 슬랙을 깔아서라도 사용하지 않을까? 하는 마음으로 슬랙을 선택했다.  배포 이제 개발한 프로그램을 온종일 실행시켜놓을 환경이 필요하다.처음 떠올린 것은 AWS EC2였다. 왜냐면 무료니까!! 그러나 치명적인 문제가 있었는데, AWS EC2 인스턴스에서 쿠팡에 접근되지 않았다.( !!!!! 맥북이랑 그램에서는 잘 됐는데.. ..? ) 혹시나 우연일까? 하는 생각에 다른 EC2 인스턴스로 시도해보았지만, 모두 접근이 되지 않았다. AWS EC2가 가질 수 있는 IP가 막혀있는 것일까…EC2에서 무료 VPN을 사용하는 게 어떻겠냐는 친구의 조언이 있었지만, 지연 속도 때문에 다른 방법을 고민해보았다.집에 놀고 있는 그램 노트북이 있다.5년을 함께 해준 노트북인데 고장이 나면 너무 슬플 것 같아서 다시 덮어두었다. 라즈베리파이를 고민했다.작년에 램이 4G가 탑재된 라즈베리파이4 모델이 나온 것을 보고는 구매했다.배보다 배꼽이 더 크다는 생각이 들긴 했지만, 추후에 개인 블로그를 라즈베리파이4에서 운영하는 계획으로 구매했다. 기본적으로 방열판이 제공되어서 붙여놨었는데, 방열판으로도 CPU 발열이 해결될 것 같지 않아서 알리에서 쿨링 팬을 구매했다.( 쿨링 팬이 씽씽 도는 라즈베리파이4 모습 - 소음은 없지만, 빛이 숙면을 방해하는 단점이… )  운영 배포까지 마치고 난 후 사용자를 모아야 했다.마스크 커뮤니티에 서비스를 홍보하면 사용자를 수천 명을 데려올 수 있을 것 같았다.사용자가 많으면 구매 확률이 낮아진다. 하지만 여기서 경쟁하면서 또 하나의 커뮤니티로 키워갈 수 있을 것 같다는 생각을 했다.하지만 외부에 공개하지 않기로 했다. 나와 내 주변 지인들이 마스크 구매 걱정 없이 살게 하고 싶은 욕심 때문이었다. 주변 사람들에게 서비스를 알리며 초대했다.약 한 달간 운영하면서 그들에게 받은 피드백 및 개선 사항으로는 다음과 같다. 1. “알람이 와서 들어갔는데 품절인 경우가 많더라”가장 많이 들었던 피드백이다. 심지어 내가 구매했던 알람을 품절이라고 말하는 경우도 있었다. 그 원인으로는 여러 가지가 있다.1) 매일 10~11시 게릴라를 하는 사이트의 경우에는 유저 트래픽이 많아 접속이 어려움.2) 재고가 1개인 경우(반품/취소 하는 경우) 에도 알람이 전송됨.3) 알람을 눌렀더니, 구매하기 위해서는 회원가입을 해야 함. (기타 쇼핑몰) 위의 상황들로 받는 알람은 구매까지 이어질 확률은 매우 낮다. 이 판단으로 인해 서비스의 신뢰도가 낮아졌다.위의 상황에서 알람을 보내는 것이 유의미하다고 판단했었는데, 알람이 올 때마다 품절이더라고 하면서 떠난 사용자도 있었다. 사용자들은 모든 상품의 알람을 받는 것 보다, 구매할 수 있는 확률이 높은 상품의 알람을 받는 것을 원한다는 것을 배웠다. 이에, 서비스에는 다음과 같은 변화가 있었다. 정해진 시간에 상품을 올리는 사이트 제거 (ex. 매일 오전 10 ~ 11시 랜덤 게릴라 / 오전 9시 판매) 품절 임박인 상품은 알람 전송 X (ex. 재고 3개) 회원가입을 해야하는 기타 쇼핑몰 제외 2. “회사에서 슬랙을 사내 메신저로 사용하는데, 회사 슬랙과 알람 구분이 안 된다. 다른 플랫폼이 필요”나는 슬랙 알람을 마스크 알람만 켜놓는다. 즉, 슬랙 알람 소리 = 마스크 알람 소리 였다.하지만 슬랙을 회사에서 업무 메신저로 사용하는 사람들에게는 입장이 다르다.업무를 보다가 회사 알람이 오면 ‘혹시나 마스크 알람이 아닐까?’ 하는 마음에 모니터 오른쪽 위를 자꾸 보게 되는 것이다. 이에 다른 플랫폼을 추가하기로 했다.검색해보니 텔레그램, 디스코드가 있었는데, 텔레그램의 경우에는 최근 N번방의 이슈로 인해 껄끄러워 디스코드를 추가하였다.디스코드 알람을 추가하면서, 디스코드를 사용하던 몇몇 지인이 유입되는 뽀나스가 생겼다.  한계 이 알리미만 있으면 마스크를 아주 쉽게 가질 수 있을 것 같지만, 전혀 그렇지 않다. 1) 점점 짧아지는 구매 가능 시간운영 초기에는 마스크를 구매하기 쉬웠지만, 지금 상황은 다르다. 30분 동안 구매가 가능했던 카카오톡 스토어 상품은 현재 1분도 채 안되서 품절 5분 동안 구매가 가능했던 쿠팡 상품은 바로 클릭해도 품절인 경우 다반사 내가 생각하는 원인은 다음과 같다. 나와 같이 알리미를 만드는 사람이 있을 수도 있다. 마스크 커뮤니티에서 실시간으로 정보 공유하는 영향도 있을 것 같다. 커머스 사이트에서 여러 상품을 장바구니에 넣어 놓고 새로고침을 반복해서 누르는 분들이 많아졌을 수도 있다. 현시점에서 상품 구매는 전적으로 개개인의 상황과 손에 달려있게 되었다. 2) 느린 네트워크 속도한번씩 Http 응답받는 시간이 오래걸리는 경우가 있었다. 모든 스레드가 함께 들쑥날쑥하여 네트워크 문제라고 판단하였다.고시원에 공유기의 모델이 문제인지, 여러 세대가 공유하기 때문인지는 모르겠다.Http 요청 timeout을 2000ms 로 잡아놨는데, 어떤 때는 매번 2초를 초과하는 때도 있었다.아무리 느려도 2초는 ..ㅠ 3) 앱 로딩 시간 - preWarm 필요슬랙 / 디스코드로 알람을 받는 시점부터 상품 페이지를 확인하는 시점 까지 생각해보자.슬랙 푸쉬 클릭 - 링크 클릭 이라는 간단한 것만 하면 된다.그런데 슬랙 / 디스코드를 실행하는 데 걸리는 로딩 시간은 매우 길다.쿠팡 앱 로딩 시간까지 고려하면 더 커진다. 위와 같은 이유로 슬랙 / 디스코드 / 쿠팡 앱을 주기적으로 켜놓는 꼼수가 필요하다.   끝으로 현재 마스크 구매 알리미는 총 20여 명의 사용자들이 이용하고 있다.부모님이 걱정하면서 보내줬던 마스크가 이제는 내가 집으로 보낼 수 있었다. 또한, 친구들을 만날 때면 마스크를 나눠주기도 했다.마스크 걱정을 덜어내려고 시작했던 이 프로젝트는 어느정도 목표 달성을 한 것 같다. 마스크가 부족할 때는 면마스크를 빨아서 쓰거나, KF-94 마스크 하나를 2 ~ 3일 씩 사용했었다.지금도 한 장으로 2 ~ 3일 사용하고 있다. 저렴하게 구매했지만, 새것 뜯을 때마다 돈 아깝다는 마음은 떨칠 수 없다. 프로젝트는 아직 개선할 점이 많다. 라즈베리파이 고정 아이피 셋팅 알리미 스레드/프로세스 죽을 때 알람 지연 속도 최적화 고민 마스크 구매자랑 채널 ( 서비스 신뢰도 문제 해결 )하지만, 나는 지금 이 상태로도 만족한다. 한가지 신경이 쓰이는 점이 있다면 이것이 불법적인 서비스인지의 여부이다.매크로로 마스크를 결제하는 프로그램을 만든 사람은 업무방해 혐의로 불구속 입건되었다고 하던데, 혹시 이 글을 읽으시는 분 중에 잘 아시는 분 계신다면 메일이나 댓글로 남겨주시면 감사하겠습니다. (_ _) - 코로나19의 종식을 바라며.. 끗 -" }, { "title": "로그스태시 mutate filter plugin 파헤치기", "url": "/2020/04/12/%EB%A1%9C%EA%B7%B8%EC%8A%A4%ED%83%9C%EC%8B%9C-mutate-filter-plugin-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/", "categories": "Elasticsearch", "tags": "", "date": "2020-04-12 04:20:12 +0000", "snippet": "raw data를 Elasticsearch로 밀어넣기 전에, 사용하기 편하도록 가공이 필요하다.이는 Logstash의 filter로 해결할 수 있는데, 특정 필드를 가공하는 방법 중에 mutate filter plugin 가 있다.해당 플러그인은 공식문서에 설명이 잘 되어있다.( 공식문서에서의 mutate filter plugin 의 gsub 옵션에 대한 설명이다. )공식문서에는 위와 같은 식으로 여러 옵션들이 친절하게 설명되어 있다.하지만 예시가 없어서 개인적으로 한 눈에 와닿지가 않았었는데, 공부도 할 겸 하나씩 사용해보며 예시를 남기고자 한다.이 글이 mutate filter plugin 를 오랫만에 접할 미래의 나와 **`mutate filter plugin 를 처음 학습하는 사용자에게 조금이나마 도움이 되었으면 한다.Mutate filter pluginmutate filter plugin 의 옵션으로는 아래와 같다. convert copy gsub join split lowercase, uppercase capitalize merge coerce update replace strip rename 1. convert해당 필드를 형변환한다. logstash.confinput { stdin{ codec =&amp;gt; json }}filter { mutate { convert =&amp;gt; { &quot;field1&quot; =&amp;gt; &quot;integer&quot; &quot;field2&quot; =&amp;gt; &quot;integer_eu&quot; &quot;field3&quot; =&amp;gt; &quot;float&quot; &quot;field4&quot; =&amp;gt; &quot;float_eu&quot; &quot;field5&quot; =&amp;gt; &quot;string&quot; &quot;field6&quot; =&amp;gt; &quot;boolean&quot; } }}output { stdout{}} 1) “field1” =&amp;gt; “integer” 2) “field2” =&amp;gt; “integer_eu”3) “field3” =&amp;gt; “float”4) “field4” =&amp;gt; “float_eu”5) “field5” =&amp;gt; “string”6) “field6” =&amp;gt; “boolean” false: 0, 0.0, &quot;0&quot;, &quot;0.0&quot;, &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot; true: 1, 1.0, &quot;1&quot;, &quot;1.0&quot;, “true”, &quot;t&quot;, &quot;yes&quot;, &quot;y&quot;  ( convert의 경우에는 예시가 공식문서에 아주 잘 나와 있었다. )  2. copy필드의 값을 복제한다. logstash.confinput { ... }filter { mutate { copy =&amp;gt; { &quot;field1&quot; =&amp;gt; &quot;field1_copied&quot; } }}output { ... } input / output  3. gsub정규식으로 일치하는 항목을 다른 문자열로 대체한다. logstash.confinput { ... }filter { mutate { gsub =&amp;gt; [ &quot;field1&quot;, &quot;/&quot;, &quot;_&quot;, &quot;field2&quot;, &quot;[\\\\?#-]&quot;, &quot;.&quot; ] }}output { ... } input / output field1: / =&amp;gt; _ field2: ?, #, - =&amp;gt; .   4. join배열을 하나의 문자로 합친다. logstash.confinput { ... }filter { mutate { join =&amp;gt; { &quot;field1&quot; =&amp;gt; &quot;,&quot; } } }output { ... } input / output  5. split하나의 문자를 배열로 쪼갠다. logstash.confinput { ... }filter { mutate { split =&amp;gt; { &quot;field1&quot; =&amp;gt; &quot;,&quot; } }}output { ... } input / output구분자가 해당 필드에 존재하지 않는 경우에도 필드는 배열로 바뀌는 것을 알 수 있다.join 옵션과 반대 개념이다.  6. lowercase, uppercase소문자(대문자) 로 변경 logstash.confinput { ... }filter { mutate { lowercase =&amp;gt; [ &quot;field1&quot;, &quot;field3&quot; ] uppercase =&amp;gt; [ &quot;field4&quot; ] }}output { ... } input / output  7. capitalize첫 글자를 대문자화, 이외는 소문자화 한다. logstash.confinput { ... }filter { mutate { capitalize =&amp;gt; [ &quot;field1&quot; ] }}output { ... } input / output  8. merge해당 필드 값들을 다른 필드에 포함시킨다. logstash.confinput { ... }filter { mutate { merge =&amp;gt; { &quot;field2&quot; =&amp;gt; &quot;field1&quot; } }}output { ... } input / output &quot;banana&quot; + [&quot;apple&quot;, &quot;melon&quot;] =&amp;gt; [&quot;apple&quot;, &quot;melon&quot;, &quot;banana&quot;] [&quot;banana&quot;, &quot;mango&quot;] + [&quot;apple&quot;, &quot;melon&quot;] =&amp;gt; [&quot;apple&quot;, &quot;melon&quot;, &quot;banana&quot;, &quot;mango&quot;] &quot;banana&quot; + &quot;apple&quot; =&amp;gt; [&quot;banana&quot;, &quot;apple&quot;] [&quot;banana&quot;, &quot;mango&quot;] + “apple” =&amp;gt; [&quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;]  9. coerce필드 값이 null인 경우에 기본값을 넣어준다. logstash.confinput { ... }filter { mutate { coerce =&amp;gt; { &quot;field2&quot; =&amp;gt; &quot;empty&quot; } }}output { ... } input / output단, input에 해당 필드가 key로 존재하지 않는 경우에는 기본값을 넣지 않는다. ( null 값이 있는 경우에는 대체 함.)ex. input이 { &quot;username&quot;: &quot;bactoria&quot; } 인 경우 field1 필드가 생성되지 않음.  10. update해당 필드의 값을 특정값으로 대체한다. logstash.confinput { ... }filter { mutate { update =&amp;gt; { &quot;message&quot; =&amp;gt; &quot;%{source_host}: My new message&quot; } }}output { ... } input / outputinput에서 message 필드가 들어오지 않는 경우 message 필드를 생성하지 않는다. (replace옵션은 필드를 생성함)ex) input이 { } , { &quot;source_host&quot;: &quot;54.17.150.184&quot; } 인 경우 field1 필드가 생성되지 않았다.  11. replace해당 필드의 값을 특정값으로 대체한다. logstash.confinput { ... }filter { mutate { replace =&amp;gt; { &quot;message&quot; =&amp;gt; &quot;%{source_host}: My new message&quot; } }}output { ... } input / outputinput에서 message 필드가 들어오지 않는 경우 message 필드를 생성하여 대체한다. (update옵션은 생성하지 않음)ex) input이 { } , { &quot;source_host&quot;: &quot;54.17.150.184&quot; }인 경우 message 필드가 대체되었다.  12. strip좌우 공백을 제거한다. logstash.confinput { ... }filter { mutate { strip =&amp;gt; [&quot;searchKeyword&quot;, &quot;username&quot;] }}output { ... } input / outputtrim() 함수와 같은 기능이다.참고로 단어 사이의 공백은 제거되지 않는다. ex) 박토리 아  13. rename해당 필드의 이름을 변경한다. logstash.confinput { ... }filter { mutate { rename =&amp;gt; { &quot;HOSTORIP&quot; =&amp;gt; &quot;client_ip&quot; } }}output { ... } input / output  P.S) mutate 옵션 실행 순서mutate의 옵션에는 실행순서가 있다. logstash.confinput { ... }filter { mutate { copy =&amp;gt; { &quot;field&quot; =&amp;gt; &quot;field_copied&quot; } uppercase =&amp;gt; [ &quot;field&quot; ] }}output { ... }input / output 위의 결과는 순차적으로 처리된다면 { &quot;field&quot;: &quot;ABCD&quot;, &quot;field_copied&quot;: &quot;abcd&quot; } 일 것이다.공교롭게도 결과는 { &quot;field&quot;: &quot;ABCD&quot;, &quot;field_copied&quot;: &quot;ABCD&quot; } 이다. 그 이유는 옵션 별로 실행 순서가 정해져 있어 uppercase 옵션 실행 이후에 copy 옵션이 실행되기 때문이다.실행 순서에 대해서는 공식문서에 나와있다. 만약 copy 옵션을 먼저 실행하고자 한다면 어떻게 해야 할까?아래와 같이 mutation을 따로 선언해주면 copy 옵션 실행 이후에 uppercase 옵션이 실행된다. logstash.confinput { ... }filter { mutate { copy =&amp;gt; { &quot;field&quot; =&amp;gt; &quot;field_copied&quot; } } mutate { uppercase =&amp;gt; [ &quot;field&quot; ] }}output { ... } input / output" }, { "title": "엘라스틱서치로 인기검색어 모니터링 해보자 (2) - 엘라스틱서치에 데이터 예쁘게 쌓기", "url": "/2020/03/24/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EB%A1%9C-%EC%9D%B8%EA%B8%B0%EA%B2%80%EC%83%89%EC%96%B4-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%95%B4%EB%B3%B4%EC%9E%90-(2)-%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%98-%EC%8C%93%EA%B8%B0/", "categories": "Elasticsearch", "tags": "", "date": "2020-03-24 02:59:12 +0000", "snippet": "지난번에 6주간 했던 푸드트럭 프로젝트는 Nginx를 이용하면서 액세스 로그를 쌓아왔기에, 이를 Kibana로 시각화하고 싶었다.목표는 이용자들의 인기검색어를 Kibana로 모니터링 해보는 것.이전글 (엘라스틱서치로 인기검색어 모니터링 해보자 (1) - 엘라스틱서치에 액세스로그 쌓기) 에서 액세스로그를 Elasticsearch로 저장하였고, Kibana로 저장된 데이터를 확인하였다.이번 포스팅에서 해결할 것은 2가지다. 수많은 Document 중에서 검색을 수행한 Document만 가져와야 한다. 검색어가 무엇인지를 알아야 한다. 우리는 message 필드로 아래와 같은 정보를 알 수 있다. /api/trucks/search로 시작하는 것은 검색을 수행한 Document 이다. (초록) /api/trucks/search?q= 이후에 오는 것은 검색어 이다. (보라)  검색어를 보기 위해 필요한 정보들이 message 필드에 있다.하지만 message 필드에는 너무나도 많은 정보들이 들어있다.message 안에 짱박혀있는 유의미한 정보들을 각각 의미에 맞게 필드들로 추출하자!!어떻게? =&amp;gt; LogstashLogstash 설정 파일 구성은 아래로 구성된다.input {...} # 데이터를 가져온다.filter {} # 데이터를 가공한다.output {...} # 데이터를 내보낸다.filter 에서 필드를 가공할 수 있다.Version 1. message 필드 쪼개기패턴 만들기message에 들어간 양식에 맞게 패턴을 정의할 수 있다.아래는 Nginx의 Access.log 의 패턴을 지정한다./usr/share/logstash/patterns/nginx.patternNGINX_ACCESS %{IPORHOST:remote_addr} - %{USERNAME:remote_user} \\[%{HTTPDATE:time_local}\\] \\&quot;%{DATA:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\\&quot; %{INT:status} %{NUMBER:bytes_sent} \\&quot;%{DATA:http_referer}\\&quot; \\&quot;%{DATA:http_user_agent}\\&quot; ${IPORHOST:remote_addr} : 타입: IP/Host, 이름: remote_addr /etc/logstash/conf.d/logstash-test.confinput {...}filter { grok { patterns_dir =&amp;gt; &quot;/usr/share/logstash/patterns&quot; # 1) match =&amp;gt; { &quot;message&quot; =&amp;gt; &quot;%{NGINX_ACCESS}&quot; } # 2) add_field =&amp;gt; [ &quot;received_at&quot;, &quot;%{@timestamp}&quot; ] # 3) }}output {...} 1) 패턴을 가져올 디렉토리 2) message 필드를 NGINX_ACCESS 패턴을 사용하여 쪼개겠다. 3) ‘received_at’ 필드 추가 (value: @timestamp) ( Logstash 재실행 )&amp;gt; sudo service logstash restart&amp;gt; curl -XGET &#39;https://&amp;lt;&amp;lt;도메인&amp;gt;&amp;gt;/api/trucks/search?q=%EA%BC%AC%EC%A7%80&#39; # 트래픽 1 발생Logstash를 재실행 한 이후의 로그들은 위와 같이 나온다.(DB가 죽어있어서 status가 499로 뜨는건 비밀)Version 2. request 필드 쪼개기message에서 필드들을 잘 쪼갠 것 같다.아직 쪼개야 하는 필드가 보인다.request 필드에는 URIPATH와 URIPARAM이 함께 들어가 있다. /etc/logstash/conf.d/logstash-test.confinput {...}filter { grok { patterns_dir =&amp;gt; &quot;/usr/share/logstash/patterns&quot; match =&amp;gt; { &quot;message&quot; =&amp;gt; &quot;%{NGINX_ACCESS}&quot; } add_field =&amp;gt; [ &quot;received_at&quot;, &quot;%{@timestamp}&quot; ] } # 새로 추가된 내용 1 grok { match =&amp;gt; { &quot;request&quot; =&amp;gt; [&quot;%{URIPATH:uri_path}&quot;] } } # 새로 추가된 내용 2 grok { match =&amp;gt; { &quot;request&quot; =&amp;gt; [&quot;%{URIPARAM:uri_param}&quot;] } }}output {...}기본적으로 사용 가능한 패턴에 대해서는 여기에서 볼 수 있는데, URIPATH 와 URIPARAM 으로 쪼갤 수 있는 것 같아 보인다. ( Logstash 재실행 )&amp;gt; sudo service logstash restart&amp;gt; curl -XGET &#39;https://&amp;lt;&amp;lt;도메인&amp;gt;&amp;gt;/api/trucks/search?q=%EA%BC%AC%EC%A7%80&#39; # 트래픽 1 발생 uri_path와 uri_param으로 쪼개졌다.Version 3. uri_param 필드 쪼개기원하는 대로 잘 나눠졌지만.. url_param에 아쉬움이 남는다. ?, =는 불필요하며, key와 value를 나눌 수 있을 것 같고, 복수개의 params가 들어올 경우 이것도 나눠줘야 할 것 같다. 파라미터가 URL Encoding 되어있어서 읽기 불편하다. 읽기 편하게 UTF8로 바꾸고 싶다. /etc/logstash/conf.d/logstash-test.confinput {...}filter { grok { patterns_dir =&amp;gt; &quot;/usr/share/logstash/patterns&quot; match =&amp;gt; { &quot;message&quot; =&amp;gt; &quot;%{NGINX_ACCESS}&quot; } add_field =&amp;gt; [ &quot;received_at&quot;, &quot;%{@timestamp}&quot; ] } grok { match =&amp;gt; { &quot;request&quot; =&amp;gt; [&quot;%{URIPATH:uri_path}&quot;] } } grok { match =&amp;gt; { &quot;request&quot; =&amp;gt; [&quot;%{URIPARAM:uri_param}&quot;] } } # 새로 추가된 내용 kv { source =&amp;gt; &quot;request&quot; field_split =&amp;gt; &quot;&amp;amp;?&quot; value_split =&amp;gt; &quot;=&quot; target =&amp;gt; &quot;params&quot; } # 새로 추가된 내용 urldecode { charset =&amp;gt; &quot;UTF-8&quot; field =&amp;gt; &quot;params&quot; }}output {...} request 필드에서 ?q=%EA%BC%AC%EC%A7%80&amp;amp;limit=10 &amp;amp;과 ? 로 쪼개고 [ q=%EA%BC%AC%EC%A7%80 , limit=10 ] 각각을 = 기준으로 쪼개서 왼쪽은 key, 오른쪽은 value {q: %EA%BC%AC%EC%A7%80}, {limit: 10} params 라는 필드에 저장해달라 params = {q: %EA%BC%AC%EC%A7%80, limit: 10} params 필드 인코딩을 UTF-8로 바꿔달라 params = {q: 꼬지, limit: 10}  ( Logstash 재실행 )&amp;gt; sudo service logstash restart&amp;gt; curl -XGET &#39;https://&amp;lt;&amp;lt;도메인&amp;gt;&amp;gt;/api/trucks/search?q=%EA%BC%AC%EC%A7%80&amp;amp;limit=10&#39; # 트래픽 1 발생  검색어 가져오기 끗 ( 타입 설정 )위 그림에서 필드의 타입이 ? 인 것들이 많다.Elasticsearch로 부터 필드 타입 정보들을 받아올 수 있다.Management - Index Patterns - nginx* - Refresh field list 클릭검색한 Document만 가져오기현재는 access.log의 모든 데이터를 보고 있다. 나는 검색한 데이터만 필요로 하다.검색한 로그는 uri_path가 동일하다.=&amp;gt; uri_path 가 /api/trucks/search 인 것만 가져오면 된다. 검색한 Document 가져오기 끗 TODO :: 필드 타입 설정 키바나에 반영, 인기검색어 Visualize, 형태소 분석상" }, { "title": "엘라스틱서치로 인기검색어 모니터링 해보자 (1) - 엘라스틱서치에 액세스로그 쌓기", "url": "/2020/03/24/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EB%A1%9C-%EC%9D%B8%EA%B8%B0%EA%B2%80%EC%83%89%EC%96%B4-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%95%B4%EB%B3%B4%EC%9E%90-(1)-%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98%EC%97%90-%EC%95%A1%EC%84%B8%EC%8A%A4%EB%A1%9C%EA%B7%B8-%EC%8C%93%EA%B8%B0/", "categories": "Elasticsearch", "tags": "", "date": "2020-03-24 00:12:12 +0000", "snippet": "지난번에 6주간 했던 푸드트럭 프로젝트는 Nginx를 이용하면서 액세스 로그를 쌓아왔기에, 이를 Kibana로 시각화하고 싶었다.목표는 이용자들의 인기검색어를 Kibana로 모니터링 해보는 것.개발 환경 OS : Ubuntu 18.04.1 LTS Nginx : 1.14.0 Logstash: 7.4.1 ElasticSearch: Amazon Elasticsearch Service (7.4) Kibana: Amazon Elasticsearch Service (7.4) 대략적인 인프라는 (TODO)Nginx 로그 쌓기인기검색어를 뽑아내기 위해서는 사용자가 검색했던 데이터를 어딘가에 기록해두어야 한다.우리 프로젝트는 Nginx로 들어오는 로그를 남긴다. /etc/nginx/nginx.conf# ...http { # ... log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;&#39;; access_log /var/log/nginx/access.log main; error_log /var/log/nginx/error.log; server { # ... }}/var/log/nginx/access.log 에 main format으로 남긴다는 말이다. /var/log/nginx/access.log 는 아래처럼 찍힌다.14.52.151.97 - - [23/Mar/2020:15:41:13 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 292 &quot;https://food-truck.shop/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;14.52.151.97 - - [23/Mar/2020:15:41:13 +0000] &quot;GET /manifest.json HTTP/1.1&quot; 304 0 &quot;https://food-truck.shop/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;14.52.151.97 - - [23/Mar/2020:15:41:13 +0000] &quot;GET /logo192.png HTTP/1.1&quot; 304 0 &quot;https://food-truck.shop/&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;// ...ELK 구축Amazon Elasticsearch Service 인스턴스 생성하기AWS의 Amazon Elasticsearch Service는 프리티어로 1년간 무료로 사용할 수 있는 인스턴스가 있다.인스턴스를 생성하면 아래처럼 Elasticsearch 엔드포인트와 Kibana 주소가 나온다IAM 사용자 생성하기Logstash에서 Elasticsearh로 데이터를 전송할 때 유효한 사용자인지를 식별하는 과정이 필요하다.이를 IAM을 이용하여 해결하려 한다. 정책 정책 생성 서비스: Elasticsearch Service 작업: 액세스 레벨 - 쓰기 리소스: 특정 - 모두 선택 정책 검토 이름: «정책 이름» 사용자 사용자 추가 사용자 세부 정보 설정 사용자 이름: «사용자 이름» AWS 액세스 유형 선택 액세스 유형: 프로그래밍 방식 액세스 권한 설정 기존 정책 직접 연결 «위에서 생성한 정책 이름» 선택 액세스 키와 비밀 액세스 키는 나중에 Logstash 설정할 때 사용하니 따로 기록해둔다.LogstashLogstash를 우리 프로젝트가 배포되어있는 EC2 인스턴스에 설치한다.아래 명령어들은 Ubuntu 18.04.1 LTS 기준이다. Logstash 설치&amp;gt; sudo wget https://artifacts.elastic.co/downloads/logstash/logstash-7.4.1.deb&amp;gt; sudo dpkg -i logstash-7.4.1.deb 플러그인 설치 - Logstash에서 Elasticsearch(Amazon es)로 데이터 전송을 도와주는 플러그인 (output 에서 사용됨.)&amp;gt; sudo /usr/share/logstash/bin/logstash-plugin install logstash-output-amazon_es Logstash 메모리 설정 변경Logstash가 실행되면 기본적으로 초기,최대 힙 사이즈가 1GB로 설정되어 있다.각자 인스턴스 사정에 맞게 힙사이즈를 조정한다.EC2 프리티어 (t2.micro) 의 경우 램이 1기가라서 줄여놓는 것이 기존 서비스에 영향이 덜 갈 것이다. /etc/logstash/jvm.options-Xms256M # JVM의 초기 힙 사이즈-Xmx256M # JVM의 최대 힙 사이즈# ...Elasticsearch 로 Access.log 전송하기이제 Logstash 설정만 해주면 Elasticsearch로 로그를 전송할 수 있다. /etc/logstash/conf.d/logstash-test.confinput { file { path =&amp;gt; [&quot;/var/log/nginx/access.log&quot;] sincedb_path =&amp;gt; &quot;/dev/null&quot; start_position =&amp;gt; &quot;beginning&quot; }}filter { }output { amazon_es { hosts =&amp;gt; [&quot;search-####-#####.ap-northeast-2.es.amazonaws.com&quot;] # Amazon Elasticsearch service 엔드포인트 region =&amp;gt; &quot;ap-northeast-2&quot; # Amazon Elasticsearch service 인스턴스의 지역 index =&amp;gt; &quot;nginx-access.log-%{+YYYY.MM}&quot; aws_access_key_id =&amp;gt; &#39;#####################&#39; # 위에서 발급한 사용자 액세스 키 aws_secret_access_key =&amp;gt; &#39;##############################&#39; # 위에서 발급한 사용자 비밀 액세스 키 }} Logstash 실행&amp;gt; sudo service logstash startKibana로 로그 확인Dev Tools로 확인하기인덱스명은 nginx* 로, 와일드카드를 사용할 수 있다. (nginx 로 시작하는 인덱스들 모두가 검색 대상이다.)Discover 로 확인하기지금껏 Nginx의 Access.log 파일을 Elasticsearch로 넣어보고,넣은 데이터를 Kibana로 확인하는 작업을 했다." }, { "title": "2020년 5주차 회고", "url": "/2020/02/02/2020%EB%85%84-5%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2020-02-02 23:58:56 +0000", "snippet": "2020년 목표가 얼또 200회다. 앞으로 아래 양식으로 추가하고자 한다. 2020 얼또 🐱‍🏍 달성 횟수 총 횟수 Weekly x 2 7 8 Monthly 15 20 Year 15 20   좋았던 점매일 아침 얼또를 했다 ( 4/4 ) 이번주 설 대체연휴를 제외한 4일 간 매일 아침 일찍 책을 읽음 얼또 시간을 유의미하게 보냈는가 ? 굳이 따지고 싶지는 않다. 온전히 나를 위한 시간이기에 무엇을 하든 유의미하다. 습관으로 자리잡고 있는 것에 만족한다. 지금은 책을 읽고 있지만, 나중에는 운동하는 시간도 확보하고 싶다.  자바 공부 오랫만에 자바로 알고리즘 문제를 풀었다 문제 풀면서 많은 것을 까먹었구나 라고 느낌 인텔리제이의 sout 단축키도 까먹었다 자바를 하니 내 안에 피가 들끓는 느낌을 받았다 너무 좋아   아쉬웠던 점 프로젝트 PM으로서의 역할 싸피 팀 프로젝트에서 PM을 맡음 6주짜리 프로젝트에 3주가 흐름 PM으로서 남들보다 무엇인가를 더 해야하고, 프로젝트를 총괄해야 하는 부담감이 있다   공부한 것린스타트업, 리액트 네이티브  다음주 할 것드림어스컴퍼니(FLO) 블라인드 채용 - 백엔드, 앱 개발 챌린지 프로그래머스에 3년차 백엔드 개발 잡페어 3년차 이상 지원가능하지만, 개인 공부용으로 하려고 함 요구사항이 명확하기에 다시 스프링 공부하기에 제격이라고 판단 " }, { "title": "우아한 모노리스 (1월 우아한 테크 세미나) 후기", "url": "/2020/01/24/%EC%9A%B0%EC%95%84%ED%95%9C-%EB%AA%A8%EB%85%B8%EB%A6%AC%EC%8A%A4-(1%EC%9B%94-%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98)-%ED%9B%84%EA%B8%B0/", "categories": "리뷰", "tags": "우아한테크세미나, 모노리스", "date": "2020-01-24 16:57:21 +0000", "snippet": "우아한 모노리스 (1월 우아한 테크 세미나) 후기어제 우아한 테크 세미나를 다녀왔다.Microservice Architecture(MSA)라고 하면 유행하고 있는 아키텍처라고 알고 있다. 넷플릭스, 쿠팡, 배민에서 대부분 서비스가 MSA로 개발/운영하는 것으로 알고 있고, 심지어 규모가 적은 스타트업에서도 MSA를 도입한 경우도 보았다.그런데 MSA에서 Monolithic Architecture(모노리스)로 전환하신 이유가 궁금하여 세미나를 신청 하였다. 나는 MSA를 다뤄본 경험이 없을 뿐더러 대규모 모노리스를 다뤄본 경험도 없다. 그래서 모노리스가 가지는 문제점에 대해서도 잘 모르고 있었다. 그래서 세미나가 시작하기 전에 MSA와 모노리스에 대한 장단점을 학습해갔다.쿠팡 블로그에서 기존에 모노리스가 가지는 단점들과 MSA 장점들을 이해할 수 있었다.  세미나를 들으며 빈을 전역이 아닌 모듈 별로 등록할 수 있다는 것과 gradle로 멀티 프로젝트 관리하는 것, 직소 프로젝트라는 것을 처음 들어봤다. DDD, 클린 아키텍처의 내용도 많이 나와서 경험과 능력이 부족한 것에 대한 아쉬움이 있었다. 그래도 이번 세미나로 소프트웨어 설계와 개발자의 정체성을 함께 생각해 보는 시간이었다.우리는 기업의 서비스를 개발하는 사람이고, 현시대에는 미래 예측이 불가능하기에 언제든지 요구사항 변화가 일어날 수 있음. 따라서 기업의 경쟁력을 가지기 위해 소프트웨어는 변경을 최대한 빨리 수용할 수 있어야 함. - 린스타트업Microservice와 Monolithic은 아키텍쳐 스타일이다. 소프트웨어 복잡성을 근본적으로 해결해주는 것은 아님.보다 근본적인 해결책은 응집과 결합을 다스리는 것! (높은 응집도, 낮은 결합도)응집과 결합을 다스리지 못하면 MSA로도 스파게티를 만들 수 있다.응집과 결합을 다스리기 어려운 이유는 기간 내에 기능을 출시해야 하기 때문. 마감 시간이 다가올수록 좋은 설계보다는 최대한 빨리 동작 가능한 것을 생각하게 됨 =&amp;gt; 기술부채변경은 언제든지 비용(시간, 돈)이 발생한다. 좋은 구조는 변경을 적은 비용으로 수용하는 것결국 개발자 능력인 것 같다.상품/주문/배송 서비스를 예시로 모듈화하기, MSA로 전환하는 과정을 Step 별로 보여주셨는데, 다음에 시간을 내서 살펴보려 한다.  설 연휴 전날이라 운 좋게 들을 수 있었던 것 같다.세미나를 들으며 노션에 기록해두었는데, 세미나 영상이 공개되면 다시 보면서 정리해야겠다.우테코 교육생, 코치분들, 몇몇 유명 개발자분들을 가까이서 볼 수도 있었는데, 실제로는 처음 봬서 넋 놓고 쳐다보기만 했다.어제 버스를 타고 부산으로 내려오는 동안에도 가슴이 두근거렸었는데 오늘 아침에 그 감흥이 많이 사그라들었다. 그래서 더 늦기 전에 글로 남기고 싶었다.2월에도 세미나 기회가 생기면 좋겠다." }, { "title": "2020년 3주차 회고", "url": "/2020/01/20/2020%EB%85%84-3%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2020-01-20 23:36:21 +0000", "snippet": "2020년 목표가 얼또 200회다. 앞으로 아래 양식으로 추가하고자 한다. 2020 얼또 🐱‍🏍 달성 횟수 총 횟수 Weekly 3 5 Monthly 8 12 Year 8 12   좋았던 점Why 를 묻기 팀 프로젝트 서비스를 기획할 때 기능 세부사항에 있어 고객의 사용성을 따짐 기획을 개발하며 고민했던 것은 왜 기능이 필요한지에 대한 것임 기술 스택을 선정할 때도 팀원들과 합당한 이유를 찾을 때 까지 고민함 친구랑 술먹다가 재밌는 주제가 나옴 :: 사수가 짠 2500 줄의 코드는 잘못된 것인가 ? 잘못됬다. SOLID 원칙을 위배하기 때문 -&amp;gt; 그럼 SOLID는 왜 지켜야 하는가 ? 비즈니스에 따라 2500줄이 합당한 코드일 수도 있음 결국 사수의 의견을 들어봐야 하고, 그 사람의 Why를 들어봐야 함 Why 안에는 비즈니스에 대한 확장성을 고려한 답변이어야 함 본인 스스로에게 Why에 대한 질문을 묻고 답하시는 개발자 분들을 보며, 그렇게 하시는 이유에 대해 공감이 크게 가지 았았던 것 같음서비스를 만들다 보면 Why에 대한 질문은 일상일 수도 있겠다는 생각이 듦  책 구매 페이스북을 보다가 글쓰기 스터디하는 분의 피드를 보고 괜찮아 보이는 책을 구매함 1. 결국 글을 쓰는 것이 아니라 다듬는 것입니다 글 쓰는 능력이 부족하다는 것을 스스로 알고 있음 책을 읽으며 개선할 부분을 자각할 수 있기를 기대하는 마음으로 구매함 2. IT에 몸담은 이들을 위한 지적생산기술 글 읽은 것을 이해하는 속도가 느리다고 스스로 느낌 요새 시간들을 효과적으로 쓰지 못하고 있는데, 결국 나의 생산성을 올리는데 도움을 충분히 줄 수 있는 책인 것 같아 구매함   아쉬웠던 점 2주 연속 회고를 제 때 하지 못한 것 원래 일요일 저녁에 남겨야 했는데, 주말에 우선 순위에서 계속 밀리다 보니 못썼다. 결국 또 월요일에 쓰게됨  웹 아키텍처 공부를 하지 않은 것 하고자 하는 마음이 크게 들지 않았던 것 같음  공부한 것린스타트업, 리액트, 리액트 네이티브  다음주 할 것(엄밀히 따지면 이번주가 되겠다)웹 아키텍처 공부 지난주에 못했는데 이번주는 설날이다~~ 시간이 매우 많다 우아한 모노리스 정리 목요일에 우아한 테크 세미나를 들으러 감 (우아한 모노리스) 작년 하반기 KSUG 세미나에서 티켓 예매를 하지 못해 들을 수 없었던 주제 작년 KSUG PPT자료를 보니 MSA, 모노리스, DDD에 대한 선행 학습을 해야할 것 같음 블로깅은 안하더라도 개인적으로 정리하기 " }, { "title": "Nginx의 limit_req 모듈 사용기", "url": "/2020/01/19/Nginx%EC%9D%98-limit_req-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%EA%B8%B0/", "categories": "Deploy", "tags": "nginx, limit_req", "date": "2020-01-19 20:11:31 +0000", "snippet": "이슈 발생두 달전에 있었던 일이다. 프로젝트의 발표를 위해 서버를 로컬에 배포해 두었고, 발표를 듣는 이들에게 데모를 체험할 수 있도록 링크를 알려주었다.그런데 발표 도중에 서버로 응답이 오지 않는 이슈가 발생했으며 서버로 요청하는 모든 기능이 마비되었다.발표가 끝난 후 노트북을 보니, 아래 로그가 계속 찍혀 들어오고 있었다.누군가 내 서버에 Request Message를 매우 빠르게 보내고 있었고, 이에 내 서버는 다른 사람들의 요청을 처리하지 못한 것이다.(누군가 장난으로 트래픽을 보내고 있었다.) 어떻게 공격했을까 ?트래픽을 일으킨 친구에게 어떻게 했는지 물어보았고, 방법은 간단했다.추천/섭취 버튼을 누르면, 서버로 request를 보내게 되는데 이를 이용하여 서버로 트래픽을 발생시킨 것이다. 개발자 도구를 이용하여 추천 버튼에 attack이라는 클래스를 추가한 후, 아래와 같은 스크립트를 이용하면 된다. attack(1000): 서버에 총 1000번의 request를 보낸다. 해결하는 방법이슈를 해결하는 방법을 찾아보니 자바 애플리케이션에서 해결하는 방법이 있고 Bucket4J, RateLimitJ, RateLimiter 웹서버(NGINX)에서 해결하는 방법 도 있었다. limit_req 이 중 나는 nginx에서 limit_req 모듈을 이용하여 해결하는 방법을 찾아봤다.  limit_req in Nginx나는 NGINX를 HTTP, HTTPS 포트로 들어오는 요청을 서버 포트로 리다이렉트시키는 용도로만 쓰고 있다.기존의 코드는 다음과 같다. /etc/nginx/nginx.conf# ...http { # ... server { listen 80; server_name localhost; location / { proxy_pass http://localhost:4000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; } # ... }}여기서 request message 를 제한할 수 있는, limit_req 를 입히면 다음과 같다. /etc/nginx/nginx.confhttp { # ... limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; ### 1) server { listen 80; server_name localhost; limit_req zone=one burst=5; ### 2) location / { proxy_pass http://localhost:4000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; limit_req_status 429; ### 3) limit_req_log_level error; ### 4) } # ... }}1) limit_req_zone $binary_remote_addr zone=myName:10m rate=5r/s; limit_req_zone 키 공유 메모리 영역 rate - zone을 생성함 키 : 요청에 limit을 걸 클라이언트 기준 $remote_addr: 클라이언트의 IP 주소 $binary_remote_addr: 클라이언트 IP 주소 (이진 표현) 약 16,000 개의 IPv4에 상태 정보를 1MB에 넣을 수 있음 (64bit platform 기준) 공유 메모리 영역 : 키의 상태를 유지하는 영역의 이름과 크기 zone=myName:10m: 공유 메모리 영역 크기는 10mb, 이름은 myName $binary_remote_addr (클라이언트 IP 주소의 상태) 가 보관됨 rate : 요청 비율 제한 ( 초당요청(r/s), 분당요청(r/m) ) rate=1r/m : 1분에 1개씩 request를 Server로 보냄 rate=12r/m : 5초에 1개씩 request를 Server로 보냄 (12request/60초 =&amp;gt; 5초에 1request) 2) limit_req zone=one burst=5; limit_req zone 이름 burst zone 이름: 위에서 만든 zone을 가져다 씀. burst: 일종의 버킷이다. burst 용량을 초과하는 요청이 들어올 경우 429(Too Many Request) 에러 반환 burst=5인 위의 경우에 7개의 요청이 동시에 들어온다면 ? Server(1개), burst(5개), Error(1개) burst=5인 위의 경우에 6개의 요청이 동시에 들어온다면 ? Server(1개), burst(5개) burst=4인 위의 경우에 9개의 요청이 동시에 들어온다면 ? Server(1개), burst(4개), Error(4개) 위의 예시는 절대적인 것은 아니다. 위의 예시들은 burst가 가득 차기 이전에 burst -&amp;gt; Server로 첫 요청을 먼저 수행한다고 가정한 것. 이에 Server(1개) 가 담겨있는 것임.3) limit_req_status 429; 이 설정을 별도로 하지 않으면 503 에러 응답 이 설정을 설정하면 burst가 가득찼을 경우 429 에러 응답4) limit_req_log_level log level을 지정할 수 있다. 예시rate=12r/m, burst=5 인 Nginx에한 클라이언트의 Request Message가 동시에 10개 들어온 경우 Ok(6개), Error(4개) Server(1개) burst(5개) burst에 쌓인 Request를 5초당 1개 씩 Server로 보냄 Error(4개) burst가 가득 찼으므로 에러 응답 최종 결과 OK (1번째 Request) Error (7번째 Request) Error (8번째 Request) Error (9번째 Request) Error (10번째 Request) OK (2번째 Request) OK (3번째 Request) OK (4번째 Request) OK (5번째 Request) OK (6번째 Request) 한 클라이언트의 Request Message가 동시에 10개 들어오고,7초 후에 Request Message가 동시에 2개 들어온 경우 Ok(7개), Error(5개) (0초) Server(1개) burst(5개) burst에 쌓인 Request를 5초당 1개 씩 Server로 보냄 Error(4개) burst가 가득 찼으므로 에러 응답 (7초) burst(1개) 기존에 burst에는 4개의 Request가 대기중. 남은 공간 1개를 채움. Error(1개) burst가 가득 찼으므로 에러 응답 최종 결과 OK (1번째 Request) Error (7번째 Request) Error (8번째 Request) Error (9번째 Request) Error (10번째 Request) OK (2번째 Request) Error (12번째 Request) OK (3번째 Request) OK (4번째 Request) OK (5번째 Request) OK (6번째 Request) OK (11번째 Request) (서버의 요청 처리 속도에 따라 다를 수 있다. ex. 1번째 Request는 10번째 Request 뒤에 찍히는 경우 )  limit과 burst 차이나는 초반에 limit과 burst가 헷갈려서 이해하는데 많은 시간을 소비했다.limit은 Nginx -&amp;gt; Server 로 클라이언트 요청을 몇 초마다 보낼지를 나타내고,burst는 Nginx -&amp;gt; Server 로 보낼 클라이언트 요청들을 잠시 담아두는 곳이다.결국 burst에 담겨 있는 request들은 지정한 주기(limit) 마다 서버에 요청된다. burst가 가득 찼을 때 request가 들어오면 Nginx는 바로 에러를 응답한다. 내가 정리한 것은 이까지고, 이 외에도 공식 문서에는 많은 정보들이 있다.필요하면 다음에 다시 찾아봐야겠다.  Test누구든지 로컬에서 돌려볼 수 있도록 https://github.com/bactoria/nginx-limit-req-test 에 공유 해두었다." }, { "title": "2020년 2주차 회고", "url": "/2020/01/13/2020%EB%85%84-2%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2020-01-13 21:30:14 +0000", "snippet": "2020년 목표가 얼또 200회다. 앞으로 아래 양식으로 추가하고자 한다. 2020 얼또 🐱‍🏍 달성 횟수 총 횟수 Weekly 3 5 Monthly 5 7 Year 5 7   좋았던 점얼또 개발서적 읽기이번주에는 얼또시간에 개발서적을 읽음칸반과 스크럼이라는 책을 읽으며 애자일의 이론적인 부분을 꽤 익힘. Zira가 좀 더 익숙해지면 다시 읽어야겠다고 느낌  아쉬웠던 점개발자로서의 회의감 개발을 정말 사랑하는 사람인가 인생에 개발만으로 꾸려도 괜찮지 않을까 했었지만, 선택의 기로에 서보니 꼭 그런 사람도 아니었음 그로 인해 자존감이 낮아짐 최근 새로운 프로젝트를 시작하면서 회의감이 또 들었음 개발자들끼리 기획부터 하는 팀프로젝트가 아직 너무 낯설다 모든 것(기획부터 배포까지)을 해내야 한다는 부담감에 스스로가 지치는 것 같음 5명의 생각을 동기화하는 것이 어려움. 누군가 말을 할 때 Sync 부채가 생기는 느낌이다. 1명이 말할 때 마다 각자 머릿속에서 그리는 것이 다른 경우가 생각보다 많았음. 내가 말을 해도 다른 구성원들이 100% 같은 생각을 가질 수가 없기에, 이 Sync 부채를 중간 중간 마다 해소해야 할 필요성을 느낌. 그래야 더 큰 의사소통 비용을 방지할 수 있을 것 같음 취준생으로서 개개인의 사정이 다르고 프로젝트를 대하는 기대치가 다름. 이건 회사에서도 개개인의 사정이 있을 수 있기에 언제 어디서든 일어날 것 같기도 함 내가 존경하는 개발자 한 분은 본인 스스로의 정체성을 프로덕트를 만드는 사람이라고 하셨는데, 나는 정말 발끝에도 못미치는 것 같음 회고를 제 때 하지 못한 것 원래 일요일 저녁에 남겨야 했는데, 주말에 몸살이 나서 의지도 없어서 패스해버림 결국 월요일에 쓰게됨  술먹고 몸살난 것 금요일에 술먹고 주말을 날림 술병이라기 보다, 집갈 때 찬바람을 많이 맞은 것 같음. 창문도 제대로 안닫고 자고.. 데일리 다이어리를 쓰지 못한 것 노션에 데일리로 하루단위로 기록을 남기고자 했음 제대로 수행하지 못함 (하루 했다..) 습관을 들여야하는데, 계속 까먹었게 됨 노션을 달고 살자!  공부한 것애자일(스크럼, 칸반), Typescript, Zira 사용법, Typescript+Vue  다음주 할 것얼또 때 린 스타트업 서적 읽기 추천사를 보고 지금 꼭 읽어야겠다고 느낌 &quot;비즈니스는 수익성 높은 사업으로 돈을 벌거나, 고객 가치를 만들어 내는 과정이 아니라 불확실한 미래와 싸워 생존, 번성하는 과정이다&quot; 정말 개발은 아무것도 아닌 것 같다. 고객 가치를 만들어서 살아남기위해?? 이런 생각 자체를 해보지 않았으니.. 스스로의 정체성을 확립하기에도 도움이 됬으면 좋겠음  웹 아키텍처 공부 웹 아키텍처를 공부해볼까 함. 웹 아키텍처라는 말을 아는 형에게 들었는데 로드밸런서에서 막힘 유튜튜로 인스턴스 여러개 만들고 로드밸런서 실습해보는 시간을 가져보는 것도 좋을 듯 해보고 블로깅하기! " }, { "title": "2020년 1주차 회고", "url": "/2020/01/05/2020%EB%85%84-1%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2020-01-05 00:00:00 +0000", "snippet": "2020년 목표가 얼또 200회다. 앞으로 아래 양식으로 추가하고자 한다. 2020 얼또 🐱‍🏍 달성 횟수 총 횟수 Weekly 2 2 Monthly 2 2 Year 2 2   좋았던 점2019년 회고 작성 2019년 회고를 남겼다. 2019년의 주간 회고를 다시 봤었는데, 일기장인 것 같은 느낌을 받음. 사건은 있지만 그에 대한 피드백이 약함 어쨌든 일년을 다시 되돌아 볼 수 있어서 좋았다. 개발 서적 구매또.. 질러버렸다. 모던 자바스크립트 자바스크립트에 대한 깊이가 낮음. 서점 갔다가 괜찮아보여서 구매함. 팀 개발을 위한 git, github시작하기 진유림님 타임라인에서 보고 바로 구매하기로 함. 평소 마스터에서 커밋 푸시만 해왔음. 당장 브랜치따서 작업해야 해서 샀다. 부분적으로 봤는데 쉽고 깔끔하니 만족.   아쉬웠던 점얼또 / 개발 서적 2020년의 얼또에서 얻고자 했던 것은 개발 서적 읽는 시간 확보임. 실수로 타입스크립트 공부하는데 시간을 써버렸다. 이런식으로 가면 개발 서적 읽는 시간을 또 확보하지 못하게 될 것 같다.. (정말 급한 일이 있으면 어쩔 수 없지만, 저 때는 아니었음.) 시간 관리 내 시간들을 세밀하게 통제하지 못하고 있다. 계획에 따라 지켜지지 않는걸 알기에, 계획조차 없다. 무의미하게 흘려버리는 시간들이 종종 있는데, 의식하며 개선하려는 의지가 없다. 아직은 그대로 놔둬도 될 것 같기도 한데.. 어쨌든 아쉬운 부분이긴 하다.  공부한 것TypeScript, ES6, React, Node.js 기초 (노션 정리)CSS Flex  다음주 할 것하루 일정 노션에 정리하기 평일에 내가 뭘 했는지 기억이 가물가물함. 일별 기록이 필요하지 않을까? 더 나은 회고를 위함 얼또?? 개발 서적 읽기 얼또 시간에 개발 서적 읽기 제발 책을 읽어" }, { "title": "2019년 회고, 2020년 다짐", "url": "/2019/12/30/2019%EB%85%84-%ED%9A%8C%EA%B3%A0,-2020%EB%85%84-%EB%8B%A4%EC%A7%90/", "categories": "회고", "tags": "", "date": "2019-12-30 00:00:00 +0000", "snippet": "2019년 회고2019년이 이제 하루가 남았다. 1년을 되돌아보는 시간을 다시 가져볼까 한다.1월 ~ 12월 까지.. 나는 어땠을까 ?뭐 그냥 막연히 떠오리려고 하면 아무것도 떠오르지가 않는다.그래서 그동안 블로그 글들, 사진첩의 사진들을 보았다.음.. 뭐 특별한 건 없는 것 같다.신기하게도 2019년의 절반은 부산, 절반은 서울에 있었다.  교육2018년에는 혼자 공부하면서 개발에 대한 흥미를 붙일 수 있었다면,2019년에는 누군가와 함께 하고 있었던 것 같다.그 시작은 3월 경에 있었던 3주간의 우아한테크코스 프리코스를 진행하면서였다.매주 과제가 나오는데, 이 3주 동안은 개발에 행복하게 빠져있었던 것 같다.3주동안 개인적으로 많은 성장이 있었다. 이 때 코드 컨벤션이나, 객체를 설계하는 방법들에 대한 눈을 뜨기 시작했다.마지막 시험인 오프라인 시험에서는 아무것도 하지 못한 나머지 너무 속상해서 혼자 뒤에 가서 울어버리기도 했다.결과는 탈락이었다. 탈락 통보를 받고 멘토나 동료를 찾아 나서기로 생각했다. 혼자서 공부하는 것 보다 함께 하는 것이 더 많은 성장을 이룰 것이라 믿었다. 당시 Vue.js 스터디도 같이 하고 있었는데, 스터디가 끝나서는 스터디 조장님의 제안으로 매일 6시간 동안 함께 공부하는 시간을 가졌다.당시 밥도 얻어먹고, 장소까지 제공 받으며 공부하고, 프로젝트도 진행하는 너무나 값진 경험을 하고 있었지만, 나는 규모가 큰 곳에서 다양한 사람들과 프로젝트를 해보고 싶어 SSAFY(삼성 청년 소프트웨어 아카데미) 서울 지역에 지원하였다. SSAFY 면접에서도 말했지만, 지원 동기는 동료, 멘토, 라이벌을 찾기 위해서였다. 팀 프로젝트 경험이 부족하기 때문에 다양한 프로젝트 경험을 하고 싶었고, 마음 맞는 팀원 한명이라도 있으면 좋겠다 싶었다. 그렇게 합격한 후 7월 2일부터 SSAFY 교육을 받기 시작했다. 비슷한 시기에 우아한테크코스 테코톡 이라고 하는 영상들이 하나씩 올라왔다.이 당시 SSAFY와 우아한테크코스 교육 내용을 비교하면서 SSAFY가 정말 개발자 육성하는게 맞는건지에 대한 비관적인 시각을 가지게 된 것 같다.SSAFY 과정만 하기에는 아쉬워서 책 읽기 모임이나 AWSKRUG 세미나, 컨퍼런스 등을 다니려고 했었다. (지금은 이 의욕이 조금 꺾인 상태인 것 같다.) SSAFY에서 만난 형이 자주 해주는 말이 있었다. “준오야, 귀인을 만나.”그 귀인 어떻게 만날 수 있는건가… 귀인을 만나도 내가 몰라봤을 수도 있을테지만, 귀인이 나에게 시간을 투자해주면 고마운 마음이 들기 이전에 죄송한 마음부터 들 것 같아 스스로 기회를 놓쳐버릴 것 같다. 우테코 탈락 통보를 받고 4월 23일 에 다짐한 것이 있다.그리고 8개월이 지난 지금, 교육에 떨어져서 다행이라는 포스팅을 남길 수 없다.나는 독하게 살지 않았고, 아직도 우테코 하고 싶다. 우테코 2기에 지원했지만, 서류 탈락이다. 서류를 너무 못 적긴 했다.2019년을 돌아보며 이 글에 남기고자 했던 것은 내가 그렇게 의지가 강한 사람이 아니라는 것과 그 원인에는 인생에 큰 목표가 없기 때문인 것 같다.사실 내가 커서 뭐가 되고 싶다거나 이루고 싶은 원대한 꿈이 없기에 동기가 약한 것 같기도 하다. 그럼에도 아직까지 원대한 꿈을 세울 생각이 없는 것 같다.  프로젝트이번 년도 프로젝트가 2개다. 2개 밖에 없다는 것이 사실 충격이었다.작년에 개인 프로젝트 2개였는데, 이번엔 팀 프로젝트 2개라서 유의미한 경험이긴 하지만 2개밖에 없다니.. 상반기 프로젝트 기회는 여러 번 있었지만, 상반기 완료한 프로젝트는 없다.2월에는 유튜브 구독자수 관련 스타트업에서 외주 제안이 와서 서울에 가서 만나보곤 했지만, 부담감에 제안을 받아들이지 못했다.4월에는 Vue.js 스터디를 하면서 아주 간단한 프로젝트를 만들었지만, 어디 써먹을 정도는 아니었다.6월에는 Vue.js 스터디에서 만난 분과 커뮤니티 사이트를 만들고 있었지만, SSAFY를 하고 싶은 나의 욕심으로 끝까지 마무리 짓지 못하였다. 하반기 프로젝트는 총 2개인데, SSAFY를 하면서 프로젝트와 SSAFY에서 만난 형과 빅스비 공모전에 제출한 캡슐이다.  책이번 년도 책을 진짜 많이 샀다.저번에 책들을 지인 집에 가져가 스캔떠서 PDF로 넣어뒀는데, 집에는 또 새 책이 가득히 싸여있다.초반에는 객체 설계 관련된 책들로 시작해서 최근에는 팀 문화에 대한 책을 구매하고 있다.구매한 책에 비해 읽는 시간이 턱없이 부족했어서 새 책이 책장에 이쁘게 꽂혀있다.저녁에 유튜브 스타크래프트 방송 보는 시간에 책을 읽었더라면 많이 읽지 않았을까…?그리고 또 사고 싶은 책이 아직 많다.  사회 이슈나는 정치도 모르고 회사가 어떻게 돌아가는지도 너무 몰랐다.최근 타다 금지법, 우아한 형제들 M&amp;amp;A 소식을 들으면서 세상 돌아가는 것도 좀 알아야겠다는 생각을 했다.몇 주 전에는 지인의 소개로 사업하시는 분과 비어집에서 네트워킹하는 시간을 나누었는데, 좋은 말씀을 듣기만 하고 왔다. 내가 세상 돌아가는 거에 관심이 더 많았더라면 그 분에게도 도움이 되었을 텐데.. 하는 아쉬움이 많이 남았다.  2020년 다짐별 감흥 없이 2020년을 맞이 할 것 같다.인생에 큰 목표를 세우기에는 아직 큰 욕심이 없기에 내 의지를 불어넣기 위해 자극점들을 스스로 찾아야 할 것 같다. 얼또얼또는 기상 시간과 간단하게 공부할 내용을 쓰고, 종료 후에 실제로 공부한 것을 간단하게 공유하는 페이스북 페이지이다.2019년 얼또를 총 20회도 하지 않았던 것 같다.2020년 평일이 251일 인 것 같은데, 목표는 200일을 채우기로 했다. 술 약속 등 생각하면 굉장히 빡빡해보이는데 일단 밀어넣어 본다.얼또 시간에 책 읽는 시간을 확보하고, zdnet.co.kr 에서 최신 뉴스를 보려고 한다.  건강최근 살도 좀 찌고, 자세가 안좋아서 허리 상태가 나빠진 것이 체감된다.PT를 받거나, 건강을 위한 운동을 좀 해야할 것 같다.이때까지 건강에 큰 문제 없었지만, 2020년에도 건강 때문에 속상한 일 없으면 좋겠다." }, { "title": "SOLID Principles", "url": "/2019/12/10/SOLID-Principles/", "categories": "", "tags": "SOLID", "date": "2019-12-10 00:00:00 +0000", "snippet": "SOLID Principles Single Responsibility Principle (단일책임원칙)클래스를 변경하는 이유는 단 한 가지여야 한다.일단 클래스가 변경되는 이유를 보면 시스템에 대한 변경 요구가 들어올 때 발생한다.시스템에 대한 변경 요구를 만족시키기 위해 해당 책임을 가진 클래스의 수정이 일어나는 것이다.그럼 변경 이유가 2가지일 경우에는 무슨 문제가 생기길래 SRP가 생긴걸까예시로 A클래스에 변경 이유가 2가지(a,b) 있다고 가정하자.이 때 제품의 기능에 어떤 변경이 필요할 때, a의 이유로 인해 A클래스가 변경되어야 해서 a를 변경했다고 하자. 이 때 b의 이유로 구현했던 것들이 정상적으로 동작하지 않을 수도 있다.창문이 내려가지 않아서 정비사에게 창문 수리를 맡겼다. 다음날 차를 다 고쳤다고 문자가 왔다. 정비소에 가서 창문을 내려보니 잘 내려가서 기뻤다. 그래서 시동을 걸었더니 시동이 안걸린다. 변경해달라고 요청하지 않은 부분이 변경된 것이다.“같은 이유로 변하는 것은 하나로 모으자!, 다른 이유로 변하는 것은 분리하자!”같은 이유로 변해야 하는 것들에 대해 응집성을 높이고, 다른 이유로 변경하는 것들에 대한 결합성을 낮추세요또한 변경 이유가 2가지라면 의존해야 하는 객체도 많아질 것이다.a의 이유로 인해 A클래스를 변경했는데, 기존에 잘 사용하던 다른 기능에 영향을 줄 수 있다.(테스트 할 때 private 테스트가 많다. 이 private 메서드를 테스트하고싶다. 어떻게 해야할까?)=&amp;gt; private 메서드를 테스트해야 하는 메서드라고 생각하면 SRP를 위반하고 있지 않은지를 의심해보아야 한다.   Open-Close Principle (개방 폐쇄 원칙) 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 한다.기능을 변경 또는 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않아야 한다.기능을 사용하는 코드를 수정하지 않으면서 어떻게 기능을 변경/확장이 가능한지 .. 무슨 말을 하는건지 헷갈렸는데, 다형성을 생각하면 된다.하나의 인터페이스의 구현체가 여러개 있다고 하자. 이 때 새로운 기능 (타입 추가) 이 필요하다면 기존에 만들어주었던 코드를 수정하지 않고 인터페이스의 구현체를 새로 만들면 된다.기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성이다. Employee클래스에 임직원/아르비이트 를 구분하기 위해 boolean 변수인 hourly를 넣어둘 수 있다. hourly 변수를 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것이다. 타입 변수를 이용한 조건문의 분기를 객체지향에서는 다형성으로 개체한다. (Replace Type Code with Class) 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다. - 오브젝트 설계를 할 때 무조건 다형성으로 만드는 것이 옳은 것은 아님. 변경에 있어서 만약 타입이 추가될 여지가 많다면 다형성이 유리하다. 기존의 코드를 건드리지 않고 타입만 추가하면 되기 때문이다. 하지만 이 경우 새로운 오퍼레이션을 추가하기 위해서는 모든 타입들에게 추가시켜주어야 하기 때문에 만약 오퍼레이션을 추가할 확률이 높다면 추상 데이터 타입이 유리하다. - 오브젝트폐쇄는 완벽할 수 없다. 일반적으로, 얼마나 닫혀있든지 간에 닫혀있지 않은 것에 대한 변경은 항상 존재하기 때문이다.따라서 비즈니스에 대한 변경 가능성을 추측하고 그 변경에 대비하기 쉽도록 추상화 하는 것이 바람직하다.프로그램에서 자주 변경되는 부분을 생각하고 추상화를 잘 하자.   Liskov Substitution Principle (리스코프 치환 원칙) 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.중요한 것은 클라이언트 관점에서 행동이 호환되는지 여부다. 행동이 호환될 경우에만 자식 클래스가 부모 클래스 대신 사용될 수 있다 - 오브젝트 여기서 요구되는 것은 다음의 치환 속성과 같은 것이다. S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면 S는 T의 서브타입이다 [Liskov88]. S s = new o1(); T t = new o2();프로그램 P의 일부public int calculate(T t) { // ... }위를 아래와 같이 치환했을 때 프로그램 P가 정상적으로 동작한다면!?public int calculate(S s) { // ...}S는 T의 서브타입이다.  리스코프 치환 원칙을 위배하는 예시 직사각형(Rectangle)과 정사각형(Square)의 상속 관계는 리스코프 치환 원칙을 위배하는 고전적인 사례 중 하나다정사각형은 직사각형이다 라는 것을 만족하지만, 리스코프 치환 원칙을 위배할 수 있음. 프로그램 P의 일부public void resize(Rectangle rectangle, int width, int height) { rectangle.setWidth(width); rectangle.setHeight(height); assert rectangle.getWidth() == width &amp;amp;&amp;amp; rectangle.getHeight() == height;}Rectangle을 상속받은 Square가 있다.프로그램 P에서 Square를 Rectangle 대신 사용한다면 프로그램 P가 정상적으로 동작했다고 할 수 있을까 ?정상적으로 동작한다면 리스코프 치환 원칙을 만족하고, 그렇지 않다면 만족하지 않는다. Square square = new Square(10, 10, 10);resize(square, 50, 100);프로그램 P의 resize 메서드에는 사각형의 너비와 높이가 다르다고 가정하였다. 그래서 square 객체를 넣었을 경우에 assert를 만족시키지 못한다.resize 메서드는 직사각형은 너비와 높이가 다를 수 있다고 가정하기에, 너비와 높이가 항상 동일하다고 가정하는 정사각형을 넣었을 경우에 문제가 된다.   Interface Segregation Principle (인터페이스 분리 원칙) 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙 이 원칙은 ‘비대한’ 인터페이스의 단점을 해결한다. 비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스다. 즉, 이런 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원한다.인터페이스를 분리하면 변경에 대한 영향을 덜 받을 수 있다.   Dependency Inversion Principle (의존성 역전 원칙)@RequiredConsructorpublic class Movie { private final AmountDiscountPolicy amountDiscountPolicy; // ... public Money calculateMovieFee(Screening screening) { return fee.minus(amountDiscountPolicy.calculateDiscountAmount(screening)); }}상위 수준 클래스인 Movie가 하위 수준 클래스인 AmountDiscountPolicy에 의존한다. 만약 비즈니스가 변경되지 않는다면 문제되지 않겠지만, 변경될 가능성이 있다면 설계는 달라져야 한다.위의 구조는 결합도가 높아지고 재사용성과 유연성이 낮아진다. Movie를 재사용하기 위해서는 AmountDiscountPolicy 를 함께 재사용 해야 하기 때문이다.이 설계가 변경에 취약한 이유는 요금을 계산하는 상위 정책이 요금을 계산하는 데 필요한 구체적인 방법에 의존하기 때문이다.이를 해결하기 위해서는 AmountDiscountPolicy의 추상화인 인터페이스에 의존해야 한다@RequiredConsructorpublic class Movie { private final DiscountPolicy discountPolicy; // ... public Money calculateMovieFee(Screening screening) { return fee.minus(discountPolicy.calculateDiscountAmount(screening)); }}이제 Movie를 재사용 할 때 AmountDiscountPolicy, PercentDiscountPolicy 둘 중 아무거나 사용할 수 있다. 어떤걸 사용할지는 런타임 시점에 결정된다!유연해졌다.  ‘역전’ 이라는 단어를 사용한 이유는 DIP를 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대방향으로 나타나기 때문이다. - 로버트 마틴 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.   출처 SRP https://code.tutsplus.com/ko/tutorials/solid-part-1-the-single-responsibility-principle–net-36074 http://www.gisdeveloper.co.kr/?p=691 https://medium.com/@narusas/단일-책임-원칙-the-single-responsibility-principle-번역-c21e0b7307b0 OCP http://wonwoo.ml/index.php/post/1726 https://blog.naver.com/PostView.nhn?blogId=jwyoon25&amp;amp;logNo=221615569649&amp;amp;categoryNo=0&amp;amp;parentCategoryNo=0&amp;amp;viewDate=&amp;amp;currentPage=1&amp;amp;postListTopCurrentPage=1&amp;amp;from=postView LSP, ISP, DIP 오브젝트 - 조영호 " }, { "title": "싸피 관통 프로젝트 후기", "url": "/2019/12/03/%EC%8B%B8%ED%94%BC-%EA%B4%80%ED%86%B5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0/", "categories": "회고", "tags": "싸피, 프로젝트", "date": "2019-12-03 00:00:00 +0000", "snippet": "싸피 1학기를 수료했다.수료 일주일 전부터 진행한 프로젝트가 있는데, 프로젝트를 진행하면서의 느꼈던, 좋았던, 나빴던 점에 대해 되돌아보고자 하는 시간을 가졌다.(싸피 측에서 커리큘럼에 대해 외부적으로 노출되는 것을 싫어하기에, 요구사항에 대한 것과 프로젝트에 자세항 사항은 남기지 않았다.)WHAT ? : 웹서비스 개발WHO ? : 2명 (서버 1명, 프론트 1명)WHEN ? : 일주일 ( 11.21 ~ 11.28 )  프로젝트를 시작하기에 앞서 기대하던 점개인적인 이번 프로젝트 목표는 다음과 같았다. 1. 프로젝트의 성공 이번 프로젝트가 1학기 동안 진행하면서의 최종 결과물이기에 꼭 성공적으로 마무리 짓고 싶었다. 기능이 정상적으로 작동하는 것으로 끝이 아니라, Best Practice를 따르고 싶었다. 단순히 기능을 돌아가게 하는 것 뿐만 아니라, 아름다운 객체 지향적인 코드를 짜고 싶었다. 2. 팀으로서의 성공싸피를 들어오면서 내가 가장 원했던 것은 팀 프로젝트의 경험이었기에, 팀으로서도 성공하고 싶었다. 이에 우리 팀이 일주일을 어떻게 보내야 성공하는 것인지에 대해 팀원과 이야기를 나누었다.서로 목표에 대해 이야기를 나누었고, 프로젝트를 통하여 개개인의 개발 역량 향상을 원했다. 물론, 프로젝트를 성공적으로 마무리 짓는 것 포함이었다.나에게는 이번 프로젝트가 프론트 개발자와의 첫 협업이라고 볼 수 있기에 경험적인 측면에서 유의미했다.팀원이 나를 볼 때, 개발을 잘하는 동료라기 보기 보다는, 함께 개발하고 싶어하는 동료가 되고 싶었다. 내 스스로가 팀에서 개발을 잘하는 것 보다 함께 개발하고 싶은 사람이 되고 싶었기 때문이다. 3. 회고이번 프로젝트나 팀이 성공/실패 여부와 관련없이 그 과정 속에서 좋았던 점, 잘못된 점에 대해 반성하고자 했으며 이는 나를 성장시키는 계기가 되기를 바랬다.팀 프로젝트를 하며 기술적인 부분에서 새롭게 학습한다거나, 혹은 나의 부족했던 점들에 대해 느꼈을 것이기에 더 나은 개발자가 되기 위해 회고하며 기록하고 싶었다.  개발 시작1. MVC 에서 서버/프론트로 전환기존의 MVC 코드에 기능을 추가하여 개발할 수도 있었지만, 서버와 프론트 로 분리하여 밑바닥부터 다시 개발하였다.굳이 전환한 이유는 다음과 같다.1) 우리가 이해할 수 없는 코드기존의 코드들은 수 많은 사람들의 손을 거친 코드이다. 그렇게 거쳐가며 점점 좋은 코드로 개선된 것이 아니라, 커리큘럼에 맞는 기술 스택으로 기능을 점점 늘려간 코드이다. 이에 내 스스로가 내가 가진 코드를 이해하기 어려웠으며, 이 코드를 팀원에게 설명하기 보다는 처음부터 짜보는게 학습 면에서나 코드 품질에서도 이득일 것이라고 생각을 했다.2) 서버 / 프론트 분리이왕 엎어버릴 거 서버/프론트를 분리시키기로 했다. Srping Boot로 HTTP API를 개발하고, 프론트는 Vue.js로 개발했다. 팀원은 Vue.js를 이번이 첫 프로젝트이지만, 내가 Vue.js에 대한 경험이 있어 막히는 부분은 내가 도움을 줄 수 있어서 큰 어려움이 없을 것이라 판단했다. 그렇게 기존의 기능들을 하나씩 추가하였다. 까다로운 부분이 있었다면 사용자 인증 부분이었다. 인증된 사용자를 서버에서 어떻게 처리할 지에 대한 고민이 있었다.이는 스프링 시큐리티를 이용하여 OAuth2의 리소스 소유자 암호 자격 증명 타입으로 access token을 발급하여 해결하였다.  2. 추가 기능1) 소셜 로그인소셜 로그인은 내 욕심이었다. 새로운 사이트에 회원가입하는 것 보다 소셜 로그인을 제공하는 것이 사용자 유입에 이득이 있다는 이유로 팀원을 설득하려 했고, 팀원은 흔쾌히 승낙해주었다. 그런데 내가 설득시켜서 소셜 로그인을 구현했다기 보다는, 엄청 하고싶어 보여서 해준 것 같다ㅋㅋ 2) 추천 시스템유저들이 추천하는 기능을 넣었다.추천을 누를 수가 있는데, 이는 한명의 유저가 여러번 추천할 수 있다.미디움 블로그의 Clab 기능 처럼.. 3) 도표화인증한 사용자의 로그를 이용하여 유의미한 그래프를 제공했다.기존에는 유저에게 다양한 그래프를 제공하려고 하였으나 시간 관계상 한가지만 넣었다.  발표일주일이 자니서, 팀별로 발표를 하였다.나는 제품을 발표하면서, access token에 관련하여서도 발표했다.듣는 사람이 다 개발자니까 결국에는 이런 기술적인 부분에도 관심이 많을 것 같았기 때문이다.발표하기에 앞서, 각 팀에서 개발한 것들을 로컬에서 배포하였었는데, 발표를 하는 도중에 마우스를 광클하는 소리가 엄청났다. 그 이유는 우리 프로젝트의 무한적으로 할 수 있는 추천 기능 때문이었다. 서버를 뻗게 만들고 싶었는지, 자신이 추천한 제품이 1위를 하기 위한 경쟁이었는지는 알 수 없지만.. (그리고 서버는 터졌지..)   아쉬운점은 없었나 ?많았다. ㅎ1. 애자일애자일을 도입하자 라고 했으나, 정작 내가 애자일에 대해 이해도가 없었던 것 같음. 우리의 개발 방식은 우선 핵심 기능에 우선순위를 정하고 하나씩 구현해 나갔으며, 그 이후 새로운 기능들을 생각하려고 했다. 애자일을 거론하기에 앞서 애자일이 무엇인지에 대한 깊은 이해도가 선행되어야 할 것 같다. 2. 함께 자라기팀이 있었기에 기능 구현에 필요한 것들을 함께 학습하는 것에 대한 기대감이 있었다. 하지만 우리는 서버 / 백엔드 역할을 따로 맡아 분담했기에 함께 자라기가 현실적으로 어려웠다. 3. 코드 품질서버에서의 코드 품질에 대해서도 아쉬움이 많다.첫 번째로, RequestDTO에 비즈니스 로직이 들어있는 경우도 있었다. 소셜 로그인하는 과정에서 사용자 아이디를 소셜타입_고유번호 (ex. google_10294193561363) 으로 했었는데 소셜타입과 고유번호를 이용하여 아이디로 하겠다는 로직이 requestDto에 들어있었다. 이는 레이어간 데어터를 전달하는 dto의 책임을 벗어난 행위이다.두 번째로는, 테스트 코드의 부재에서 오는 아쉬움이다. 처음 개발을 시작할 때는 여유가 있으면 테스트 코드를 짜야겠다고 생각했다. 하지만 주어진 시간안에 기능을 개발하는 데 많은 시간을 소모했기에 테스트 코드를 짜지 않았다.한번은 팀원이 인증된 사용자가 사용하는 어떤 기능의 변경을 요구를 했다. 요구한 기능에 대해 개발을 마치고 end-to-end 테스트가 필요한데, 이를 팀원에게 부탁했다. 이는 프론트엔드를 개발하고 있는 팀원의 생산성에 영향을 미치는 행위일 수 밖에 없다. 그럼에도 내가 테스트 하려면 postman으로 로그인-기능 확인 하는 2단계를 거쳐야 했기에 귀찮았기 때문. 매우 무책임한 사람처럼 보이기도 하지만 팀원이 내가 기능 구현하는 것들을 기다리는 상황이었고 나는 결과를 실제 동작하는 화면으로 함께 확인해보고 싶었다는 변명을 해본다.어쨌든 중요한 건 테스트 코드를 짰더라면 이런 기능 테스트도 쉽게 할 수가 있었다는 것이다. 만약 그때로 돌아간다면 또 안짰을 것 같지만, 아쉬움으로 남는 건 사실이다. 4. 서버 터짐발표 도중에 서버가 뻗었다. 발표를 마치고 노트북을 봤는데 누군가의 request 로그가 매우 빠르게 찍히고 있음을 발견했다.저녁 먹으면서 친구가 그 원인을 알려주었는데, while문 안에 서버에게 POST 요청을 하는 스크립트를 넣어 서버에게 무한정한 request Message를 보냈다고 하더라. 생각치도 못한 공격이라 처음에 듣고는 너무 당황스러웠고, 발표 도중에 터져버린 것이 너무 아쉬웠다. 5. 좋은 동료 되기함께 개발하고 싶어하는 동료가 되고 싶었지만, 과연 좋은 동료였을까에 대한 의문이 남는다. 프로젝트를 너무 내가 하고 싶은 방향으로 흘러가지 않았나 싶다. 설령 그랬다면 내가 프로젝트에 대해 잘 알아야하고 전체적인 조율을 맡았어야 했는데 그런 부분들에 대해 신경을 못 쓴 것 같다. 함께 개발하고 싶어하는 동료라기 보다는 개발 좋아하는 동료로 밖에 안보일 것 같다. 이런 부분들은 서적을 읽고, 앞으로 더 많은 팀프로젝트를 해봐야 할 것 같다. 6. 스프링 시큐리티소셜 로그인은 마지막 날까지 헤매었던 부분이다. Vue.js 에서 구글 OAuth 서버에서 얻은 code를 HTTP API 서버에 전송하면, HTTP API 서버가 code를 이용하여 구글 OAuth 사용자를 받아와서 로그인하게 하려고 하였으나, 마지막 날까지 해결하지 못하였다.이에 대안으로 Vue.js에서 구글 OAuth 서버에서 받은 회원 정보들을 HTTP API 서버로 넘겨주었으나 이는 보안상 문제가 있다고 생각된다.또한, 소셜 로그인 요청이 HTTP API 서버로 들어오면 Spring Security 에서 인증을 거친 후 AccessToken을 반납하는 것이 옳다고 생각하였으나, 실제 구현한 로직은 Controller로 로그인 정보를 받아서 RestTemplate를 이용하여 다시 자신의 서버에 요청하였다. 이는 나의 Spring Security 이해도 부족으로 인한 결과인 것 같다.  좋았던점은 ?개발 역량 향상이 있었음을 느낀다.팀원은 Vue.js를 이용하여 첫 프로젝트였는데 Vuex도 잘 사용하고, 컴포넌트화도 잘 나눈 것 같다. 나 또한 OAuth 에 대한 이해도를 좀 더 높일 수 있었고, TypedQuery를 이용하여 Select문을 처리하는데 있어 자신감과 역량이 향상되었다고 느낀다. 그리고 학습한 것들을 곧 까먹을 것이란 걸 알기에 정리가 꼭 필요하다.그리고 팀원을 잘 만나서 좋았다. 프로젝트를 진행하면서 팀원이 너무 착하고 잘 맞춰준 것 같은 느낌을 받았다.또한, 발표를 할 때 자체적으로 각 팀을 심사를 하여 반에서 우수한 팀에게 상을 줬는데 운좋게도 우리가 2등을 하게 되었다. 기대를 하지 않은 탓인지 너무 기뻤고, 일주일 간의 노력에 대한 보람을 다시 한번 느낄 수 있었다.  앞으로 해야할 것나는 서버를 맡았고 다른 팀원은 프론트를 맡았다. 애초에 역할을 분담할 때 서버 로직에 대해 팀원에게 설명을 하면서 개발하려고 하였으나, 이 또한 시간을 핑계로 하지 않았다. 이에 서로 코드를 공유하는 시간을 가지면 좋겠다는 생각을 했다.서비스 거부 공격으로 인하여 발표 도중에 서버가 터진 것을 대처하는 것도 숙제로 남았다. 검색해보니 특정 시간 동안 실행 횟수를 제한하는 라이브러리를 쓰면 될 것 같은데, 곧 개선해 봐야겠다." }, { "title": "빅스비 챌린지 회고 - 3.좋았던 점", "url": "/2019/11/02/%EB%B9%85%EC%8A%A4%EB%B9%84-%EC%B1%8C%EB%A6%B0%EC%A7%80-%ED%9A%8C%EA%B3%A0-3.-%EC%A2%8B%EC%95%98%EB%8D%98-%EC%A0%90/", "categories": "회고", "tags": "빅스비챌린지, 공모전", "date": "2019-11-02 00:00:00 +0000", "snippet": "커뮤니케이션 평소 커뮤니케이션의 능력이 많이 부족하다고 스스로 느끼고 있었다.팀 프로젝트를 많이 한 적도 없고, 공모전 제출도 처음 해봤다.그래서 이번 프로젝트를 통하여 많은 것들을 느낄 수가 있었다. 주먹구구식인 나의 말투내 말에는 논리와 요점이 흐트러져 있으며, 듣는 방식도 문제가 있다. 의사소통하는 능력이 부족하다는 말이다.내가 말은 무엇을 말하고자 하는지를 상대방이 쉽게 전달되지 못하는 경우가 많았다.팀원이 2명뿐이지만, 의사소통의 장벽은 나에게 있었음을 금방 깨달을 수 있었다. 팀원은 말을 할 때마다, 마지막에 자신의 의견을 정리해주기도 하며, 상대방이 이해했는지를 확인했다.내 말을 들을 때에는 이해한 부분에 대해 디브리핑 하는 습관이 있었다.디브리핑을 받으면서 나는 존중받는 느낌을 받았다. 그래서 프로젝트를 진행하며 팀원의 말투를 클론하여 따라하려고 했다.그래서 빨리 다음 팀 프로젝트를 또 하며 연습을 계속 해야 할 필요성을 느꼈다.싸피에서 하는 미니 프로젝트에서 연습해야지 사실 커뮤니케이션 능력들을 싸피 교육을 하면서 향상시키고 싶었으나,강의 시간이 너무 많아 나의 문제점에 대해 느낄 수 조차 없었으나 이번 공모전을 진행하면서매우 다행인 부분이라고 생각한다. 저번에 사두었던 협업의 기술 책을 읽을 시기가 된 것 같다. 베리굿~  투머치 토커빅스비, 서버 개발을 하면서 이슈가 생겼을 경우에그 이슈가 생긴 이유에 대해 설명을 했고, 해결 했을 경우에는 어떻게 해결 했는지에 대해 팀원에게 설명을 했다.그런데 별 관심이 없어하는 것 처럼 보였다. 사실 앱/웹 개발자와 서버 개발자 사이에서도 마찬가지일 것 같다.이슈가 생긴 이유보다는 이슈에 대한 대처방안을 토의해야 한다.해결할 수 있다면 언제 해결되는지,해결할 수 없다면 프로젝트를 어떻게 바꿔가야 할지 정도가 서로의 관심사일 것 같다. 같은 서버 개발자면 어떻게 해결 했는지 말을 해야겠지만, 이런 경계 밖에서는 굳이 말할 이유는 없는 것 같기도 하다는 생각이 들었다.  개발자가 개발하지 뭐해요 공모전 제출 마지막 2주 전부터는 밤을 새우는 경우가 많았다.새벽에 이렇게 집중하여 코딩을 한게 얼마만인지 모르겠다.바쁘니까 오히려 사는 게 재밌고, 하루 하루가 의미 있게 느껴졌다. 잘 동작하는 코드를 빨리 만들어야 기능을 추가할 수 있었기에 잠이 안오더라.(마감일 하루 전에 11시간 취침 때려버리는 불상사가 있긴 했다.) 역시 개발은 안되는거 없다. 그냥 하면 된다.오래 걸리거나 비효율적이거나 일 뿐  기술 지원앞서서 기술 지원에 대해 아쉬운 점을 토로했으나, 이 부분은 사실 우리의 프로젝트의 미숙해서였고 기술 지원은 너무 좋았다. 온라인 지원(메일)빅스비를 개발하면서 문서로 이해가 잘 되지 않거나, 찾기 힘들었던 부분들은 개발 지원팀에 문의 메일을 보내 해소했다. (보통 1~2일 내에 답변들을 받을 수 있었다.)특히 빅스비 개인화 관련해서 문의를 한 적이 있는데, 구현 방법에 대해서 상세하게 설명해주셔서 큰 힘이 되었다. 오프라인 지원 (Bixby Developer Office Hour &amp;amp; Bixby Happy Hour)두 행사 모두 빅스비 개발 지원팀 분들과 소통할 수 있는 자리였다.이전 글에서 아쉬움을 토로했지만, 어쨌든 당시 우리팀에 필요했던 부분에 대해서 친절하게 도움 받을 수 있었다.빅스비 캡슐 실습 강의를 보면서 들었던 목소리를 실제로 들을 수 있어서, 신기하기도 하고 친숙하게 느껴졌다.  Reference 기여빅스비 캡슐을 개발하는 기간동안 문서의 내용이 조금씩 바뀌는 것을 느꼈다. 동시에 오탈자가 있을 수도 있겠다는 생각을 했다. 얼마 지나지 않아 오탈자 코드 두 개를 발견하여 지원팀에 메일을 보냈다. 며칠 후, 오탈자 제보에 감사하다는 답변 메일을 받을 수 있었는데 뿌듯함을 느꼈다.그로부터 이틀 후에는 오탈자가 곧 수정될 것이라는 답변과 함께 감사 인사를 다시 한번 표해주셨는데, 뿌듯함이 배가 되었다.내가 오탈자 제보를 하지 않았더라도 언젠간 수정이 되었겠지만, 뿌듯하고 자존감이 높아졌다. 현재 오탈자가 정상적으로 수정되어 있는데, 볼 때마다 기분이 좋다." }, { "title": "빅스비 챌린지 회고 - 2.아쉬웠던 점", "url": "/2019/11/02/%EB%B9%85%EC%8A%A4%EB%B9%84-%EC%B1%8C%EB%A6%B0%EC%A7%80-%ED%9A%8C%EA%B3%A0-2.-%EC%95%84%EC%89%AC%EC%9B%A0%EB%8D%98-%EC%A0%90/", "categories": "회고", "tags": "빅스비챌린지, 공모전", "date": "2019-11-02 00:00:00 +0000", "snippet": "빅스비 개발을 하면서 아쉬웠던 점이다.느린 노트북노트북으로 인텔리제이를 잘 사용하고 있었기에 빅스비 스튜디오 도 잘 돌아갈 줄 알았으나, 큰 착각이었다.빅스비는 마치 누군가의 컴퓨터를 원격으로 조종하고 있는 것 처럼 반응이 느렸다.램16GB 컴퓨터에서는 잘 동작하는 거 보니 노트북 사양에 문제가 있었다. 뿐만 아니라, 캡슐이 동기화가 이루어질 때 가끔씩 .bxb 파일 내용이 없어진다.Ctrl +Z도 안먹히는 바람에 새벽에는 파일이 삭제될 때 마다 깊은 분노가 올라왔다. 결국 생산성에 큰 영향을 주었다.  안드로이드 폰의 부재나는 아이폰 유저이다.빅스비 스튜디오로 개발하면 개발 툴에 있는 시뮬레이터를 이용하여 테스팅 해볼 수 있다.빅스비 실행가능한 안드로이드 폰이 없이도 개발할 수 있겠군!허나, 우리의 캡슐은 2가지 앱을 구동 시켜야 하기에 앱이 정상적으로 실행하는지 확인할 수 있어야 했다.또한 발화 부분에도 문제가 있었다. 캡슐의 발화를 수정하고 발화가 잘 동작하는지를 테스트하기가 어려웠다.시뮬레이터에서는 되는 것들이 온디바이스 테스트에서는 안되는 것들이 더럿 있었다. 주말에는 친구 집에가서 친구 폰으로 테스트 했지만,평일에는 같이 공모전하는 형의 휴대폰에 의존했다.결국 피드백이 실시간으로 이루어지지 못하고, 이 또한 생산성에 문제가 있었다.  스파게티 코드현재 제출한 bixby 캡슐 코드, HTTP API 코드를 보면 완전 스파게티 코드이다.빅스비 코드는 컴포넌트화 시킬 수 있는 것을 각 view 파일에서 중복해서 사용하고 있으며,HTTP API 코드를 보면 단일 책임 원칙도 지키지 않는다. 좋은 코드란? (오브젝트 中) 잘 동작해야 한다. 유지보수성이 좋아야 한다 가독성이 좋아야 한다.  아직 빅스비의 Reference를 완전히 숙지하지 않은 상태인데 공모전 제출 마감일이 다가오면서유지보수성을 신경쓰지 못했다. 아니, 안했다. 일단 개발해놓고 리팩토링하자! 가 아니라, 개발 초기부터 완벽을 추구했다. 그러다 보니 동작하는 프로젝트가 나올 생각을 안했다.내 더러운 코드를 다른 사람에게 보여주기 싫어서 인 것 같다. 공모전은 마감 시간이 있다. 이에, 우리가 개발하려고 했던 것들은 기간 내에 잘 동작해야 한다.또한, 캡슐 개발은 나 혼자 맡았기 때문에 팀원에게 내 코드를 설명할 일이 없으며, 훗날 내 캡슐을 볼 일도 없다.다시 말해, 유지보수성은 우리팀의 관심대상이 아니었다.일단 빨리 만들어서 추가적인 기능의 구상과 구현이 우선순위였다. 공모전이 아니라, 지속적으로 서비스해야 하는 캡슐을 만들었다면 달라졌겠지만,당장 10/31 까지 제출해야 하는 캡슐에는 유지보수는 고려대상이 아니었다.(빅스비 코드 품질은 공모전 평가 대상이 아니었음) 어쨌든, 스파게티 코드의 가장 궁극적인 이유는 나의 능력 부족이기 때문이긴 하다.  함께 자라기우리 팀: 2명팀원: 안드로이드 앱, 기획, 제안서, 캡슐 테스트나: 빅스비, api 서버 서버의 경우에는 그냥 뚝딱 만들면 됬는데,빅스비를 학습하는데 있어서 오래 걸렸다. 실제 캡슐 개발 기간은 매우 짧았다는 점이 아쉬움으로 남는다.주변에 캡슐 공모전을 하는 친구도 없어서 영어로된 문서와 개발팀에 의존할 수 밖에 없었다.  기술 지원빅스비를 개발하면서 3가지의 기술 지원을 받았다. 메일 문의 Bixby Developer Office Hour Bixby Happy Hour   그 중 Bixby Developer Office Hour, Bixby Happy Hour 에 대해 아쉬움이 남는다.두 행사 모두 빅스비 캡슐의 전문가분들에게 우리의 빅스비 개발 지원을 해주시는 자리이다.행사 당시 우리 팀의 캡슐이 미완성 상태라 빅스비에서 이거 할 수 있나요, 없나요 에 대한 것들을 계속 여쭤보았다.만약, 캡슐이 완성상태였다면 캡슐을 보여드리면서 전문가들의 의견들을 여쭤봤을 테고, 캡슐의 완성도가 더 높았을 것 같다." }, { "title": "빅스비 챌린지 회고 - 1.계기", "url": "/2019/11/02/%EB%B9%85%EC%8A%A4%EB%B9%84-%EC%B1%8C%EB%A6%B0%EC%A7%80-%ED%9A%8C%EA%B3%A0-1.-%EA%B3%84%EA%B8%B0/", "categories": "회고", "tags": "빅스비챌린지, 공모전", "date": "2019-11-02 00:00:00 +0000", "snippet": "그저께 빅스비 챌린지 공모전에 캡슐을 제출하며 공모전을 마무리 지었다.약 4주 간 공모전을 진행하면서 느꼈던 점들을 회고하고자 한다. 1. 빅스비 공모전을 하게 된 계기싸피를 하면서, 2주간 같은 반이었던 형에게 빅스비 공모전 제안을 받았다. 이틀간 곰곰히 생각했다. 할까? 말까? 빅스비 개발은 나중에 안할텐데… 빅스비를 배우는데 러닝커브가 크지 않나? 차라리 그 시간에 개인 공부를 하는게 낫지않을까? 그래도 싸피 들어오고 나서 프로젝트 하나도 안했는데.. 프로젝트하면 뭐라도 느끼지 않을까? SSAFY를 하면서 가장 원했던 점이 팀으로 무언가를 만들며 더 좋은 내가 되는 것 이었다.그런데 지난 4개월을 돌아보니 팀 프로젝트를 하지 않았다는 사실에 너무 충격이었다.최근에 같이 프로젝트를 하고 싶다고 생각했던 사람 중 한명 이었기에 이번 프로젝트를 해야겠다고 생각했다. 이번 프로젝트를 진행하면서 기대한 것은 2가지이다. 우선 의사소통 능력을 향상 이다.개인 프로젝트는 몇번 했지만, 팀 프로젝트를 한 경험이 졸업작품 밖에 없어서 프로젝트를 할 때의 나는 어떤 사람인지, 어떤 사람이 되어야 하는지에 대해 잘 모르고 있었다. 이런 궁금증들을 해소해주지 않을까 하는 기대감이 있었다. 다음은 새로운 언어, 플랫폼에 대한 도전 이다.웹, 서버 개발에 대한 공부만 해왔기에 새로운 플랫폼에 대해 습득하는 능력을 키우는 것이 필요했다.이번 프로젝트가 새로운 것을 학습하며 느낀 점들이 추후의 내가 새로운 것을 쉽게 학습할 수 있을 거라 생각했다." }, { "title": "2019년 42주차 회고", "url": "/2019/10/21/2019%EB%85%84-42%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "아이패드, 빅스비, SQLP", "date": "2019-10-21 00:00:00 +0000", "snippet": "아이패드아이패드 프로를 구매했다.기존에 아이패드 에어2가 있었지만, 애플 펜슬로 필기하고 싶어서… 싸피 끝나고 저녁에 가로수길 애플 스토어에서 애플 케어 플러스를 등록하러 갔다. 마침 애플 스토어 이벤트로 포토샵과 비슷한 드로잉 어플인 프로크리에이트 강의를 해서 참여했다. 각자 자신을 스케치하는 시간을 가졌다.그림을 다 그린 후에 자기 그림을 소개하는 시간이 있었는데, 다들 잘 그리시더라.나만 너무 못 그린 것 같아 부끄러웠지만 프로 크리에이트 사용법을 익히기도 했고 좋은 추억이 될 것 같다. 집에 와서는 취미 생활로 디지털 드로잉을 해볼까 생각해봤다. 그림 그리는데는 잼병이지만 취미는 꼭 잘하는 것을 하는 것은 아니니까.. 클래스101 에서 프로 크리에이트 드로잉 강의를 찾아보았는데 대부분이 20~30 만원 대여서 가격이 너무 비싸다고 생각했다. 그런데 곰곰히 생각을 해보니 새로운 취미생활을 시작하는데 있어 내 시간을 절약해주고, 무엇보다 당장 그럴싸한 그림을 그릴 수 있을지도 모른다. 그런데도 가격을 처음 봤을 때 비싸다고 생각한 것에 대해 부끄러웠다.얼마나 공짜로 얻어먹으려고 했던건지.. 내가 평소에 예술을 너무 가볍게 여기는 것이 아닌가 하는 생각이 들더라. 내가 평소에 관심을 가지지 않은 분야에 대해서 가볍게 여기는 듯 하다.막상 이런 유료 강의들을 무료로 제공되었다면 과연 내가 들으려고 했을까 라는 생각이 들기도 했다. 내 소중한 돈을 투자해야 간절함이 생기는 것 같다.여러 크리에이터 분들의 그림을 보면서 마음에 드는 강의를 천천히 골라봐야지.  빅스비, SQLP이번주에 빅스비 공모전을 준비하면서 빅스비가 어플리케이션을 호출하는 법을 찾아 헤매다가 무의미한 시간을 많이 보냈다.금요일에 빅스비 개발을 하기 위해 안드로이드 폰을 가진 친구집에 갔다.친구 집에 도착하니 대학교 친구들과 소주를 먹었는데 와…. 대학교 다닐 때의 느낌이 나서 신기하기도 하고 기분이 너무 좋드라.친구들 중에 SQLP 자격증을 딴 친구가 있어서 술 먹다가 SQLP 관련 이야기를 나눴는데 나도 너무 따고 싶다는 생각이 들었다.자격증을 취득하는 것이 목적이라고 봐야겠지만, 현재 SQLP를 학습하면 내 시간들을 온전히 학습하는데 쏟아부을 수 있을 것 같다는 확신이 든다. 일단 28일까지 빅스비를 성공적으로 마무리 지어야 한다기존에 구상하고 계획했던 기능을 완벽하게 구현하고, 다양한 발화에 대해서 최대한 커버하는 것이 목표다." }, { "title": "2019년 41주차 회고", "url": "/2019/10/13/2019%EB%85%84-41%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "학습방법, 수면시간", "date": "2019-10-13 00:00:00 +0000", "snippet": "학습 방법지난주 프로그래머스 웹과제를 끝내고 이번주부터 빅스비 챌린지를 시작했다.빅스비 개발은 처음이라 학습이 필요했다. 참고자료로는 영어로 된 가이드가 있고, 삼성에서 만들어 놓은 빅스비 강의도 있다.나는 가이드를 쭉~ 보고 난 후 간단한 프로젝트를 만들어보려 했다.하지만 프로젝트를 어디서부터 어떻게 만들어야 할지 모르겠더라. 분명히 영상도 다보고 가이드도 봤는데??잘못된 방법으로 학습을 했다. 부끄럽지만 생각을 안하고 멀뚱멀뚱 보는 시간이 많았던 것 같다.그래서 간단한 프로젝트를 가이드와 병행하면서 다시 익혔다.또한, 새로 익힌 것들을 내 방식대로 정리했다. 오늘 학습한 것들이 내일 온전히 남아있을 것이라고 생각하지 않기 때문이다. 저번에 했던 것들을 다시 뒤적이곤 하는데, 어디를 뒤져야 하는지 조차도 모를 때도 더럿 있었다. 학습하며 자기 방식대로 잘 정리를 해놓는다면 시간적으로나 집중력으로나 이득인 것 같다.앞으로 새로운 것을 학습할 때 가이드, 프로젝트, 기록 이 3가지를 동시에 병행해야겠다. 꼭…  수면 시간요새 수면 시간이 줄어들었다.평소에 12시에 잤다면, 요새는 피곤할때까지 노트북하다가 잠이 오면 자다보니 수면시간이 줄었다.이게 좋은 방법인줄 알았으나 매우 안좋은 것 같다.12시에 잘 때는 제한된 시간 내에 빨리 끝낼 수 있도록 집중을 했다. 요새는 무한한 시간을 가진 것과 같은 착각을 하게 되여 집중도 안하는 것 같다.그래서 오히려 수면 시간만 줄어들고 삶에 도움되는게 전혀 없다고 느꼈다.이제는 자는 시간을 꼭 정해놓고 필요에 따라 일찍 일어나는 쪽으로 가려 한다." }, { "title": "Ip로 클라이언트 접속 위치 정보 알아내기", "url": "/2019/10/11/Ip%EB%A1%9C-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%A0%91%EC%86%8D-%EC%9C%84%EC%B9%98-%EC%A0%95%EB%B3%B4-%EC%95%8C%EC%95%84%EB%82%B4%EA%B8%B0/", "categories": "Spring", "tags": "MAXMIND, GeoIP2, GeoLite2", "date": "2019-10-11 00:00:00 +0000", "snippet": "Google Analytics 를 이용하면 접속한 클라이언트의 위치를 제공받을 수 있다.우째하누~ 궁금해서 찾아봤다.  클라이언트 접속 시 국가와 도시 정보를 응답해주도록 만들어보쟈~  위치정보 다운받기MAXMIND 에서 제공해주는 DB를 이용하면 IP Address를 이용하여 대략적인 위치 정보를 얻을 수가 있다.https://dev.maxmind.com/geoip/geoip2/geolite2/GeoLite2 City: 국가 정보 제공GeoLite2 Country: 국가, 도시 정보 제공 GeoLite2 말고 GeoIp2도 있는데,이 둘의 차이점은 GeoLite2 는 무료이고 GeoIp2는 유료다. (CSV로 다운로드 받으면 국가, 도시 정보를 확인해 볼 수 있다.)  의존성 추가자바 의존성을 추가해준다. (Maven)&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.maxmind.geoip2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;geoip2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; (Gradle)repositories { mavenCentral()}dependencies { compile &#39;com.maxmind.geoip2:geoip2:2.12.0&#39;}  콛잉 빈등록@Componentpublic class GeoReader { private static final String DATABASE_CITY_PATH = &quot;C:\\\\Users\\\\bactoria\\\\Downloads\\\\GeoLite2-City_20191008\\\\GeoLite2-City.mmdb&quot;; private DatabaseReader reader; public GeoReader() throws IOException { File dbFile = new File(DATABASE_CITY_PATH); reader = new DatabaseReader.Builder(dbFile).build(); } public CityResponse city(InetAddress ipAddress) { CityResponse response = null; try { response = reader.city(ipAddress); } catch (IOException e) { e.printStackTrace(); } catch (GeoIp2Exception e) { e.printStackTrace(); } return response; }} service@Service@RequiredArgsConstructorpublic class GeoService { private final GeoReader geoReader; public GeoLocation findCity(InetAddress ipAddress) { CityResponse response = geoReader.city(ipAddress); Subdivision subdivision = response.getMostSpecificSubdivision(); City city = response.getCity(); return new GeoLocationDto(subdivision.getName(), city.getName()); }} 국가, 도시 정보를 담는 DTO클래스@Getter@AllArgsConstructorpublic class GeoLocationDto { private String subdivisionName; private String cityName;} RestController@RestController@RequiredArgsConstructorpublic class GeoRestController { private final GeoService geoService; @GetMapping(&quot;/geo&quot;) public ResponseEntity&amp;lt;GeoLocationDto&amp;gt; city() { InetAddress ipAddress = getIpAddress(); GeoLocationDto geoLocationDto = geoService.findCity(ipAddress); return ResponseEntity.ok(geoLocationDto); } private InetAddress getIpAddress() { HttpServletRequest req = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest(); String ip = req.getHeader(&quot;X-FORWARDED-FOR&quot;); if (ip == null || ip.isEmpty()) { ip = req.getRemoteAddr(); } if (ip == null || ip.isEmpty()) { ip = req.getHeader(&quot;Proxy-Client-IP&quot;); } if (ip == null || ip.isEmpty()) { ip = req.getHeader(&quot;WL-Proxy-Client-IP&quot;); } if (ip == null || ip.isEmpty()) { ip = req.getHeader(&quot;HTTP_CLIENT_IP&quot;); } if (ip == null || ip.isEmpty()) { ip = req.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;); } if (ip == null || ip.isEmpty()) { ip = req.getRemoteAddr(); } if (ip == null || ip.isEmpty()) { throw new RuntimeException(); } InetAddress ipAddress = null; try { ipAddress = InetAddress.getByName(ip); } catch (UnknownHostException e) { e.printStackTrace(); } return ipAddress; }} 결과위의 주소를 보면 알 수 있듯이 ngrok으로 배포해서 접속했다.로컬에서 테스트하면 127.0.0.1로 떠서 위치정보를 알 수 없기 때문에 ngrok으로 해결했다.(ngrok은 외부에서 로컬 서버에 접속할 수 있도록 도와주는 터널 프로그램이다. ) 여기서 subdivision이 서울로 나왔지만 특별시, 광역시 등은 subdivision으로 분류되는 듯 하다.(경상남도, 경상북도 등도 subdivision이고, 마산, 용인 등은 city이다.)  위치 정보는 정확한가?위의 cityName를 보면 강동구로 떴는데, 사실 난 강남구(역삼)에 있었다. 저녁에 역삼의 어느 카페에서 테스트를 다시 해보았다.(GeoLocationDto에 위도, 경도를 추가함) 오오!! 강남구 떴다~~위도, 경도를 구글맵에 쳐보면!!종로구로 나온다…ㅜ ipfingerprints 에 접속하면 해당 ip address의 ISP, 경도, 위도, 국가, 도시 정보를 알 수 있다.그리고 하단에는 아래와 같이 나와있다.  IP 주소 위치 정보는 MaxMind를 이용하여 제공하고 있습니다. MaxMind에서 제공하는 국가 정보는 99.8 % 정확합니다. 미국의 주 정보는 90 % 정확헙니다. 미국 도시 정보가 반경 50km 이내일 확률은 81 % 입니다. 정확하게 일치하는 것이 아닌 대략적인 위치다.사실 공짜로 쓰는데 이정도 알려주는 것만으로도 좋은 것 같다. url 단축기에 적용해 볼 만한 것 같다" }, { "title": "2019년 38,39주차 회고", "url": "/2019/09/29/2019%EB%85%84-38,-39%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "운동과개발, URL단축, 실패한경험?", "date": "2019-09-29 00:00:00 +0000", "snippet": "운동과 개발저번주에 헬스를 시작했는데, 첫 날 팔운동을 하다가 바로 근육통이 생겼다.근육통이 올 것이라 어느정도 예상은 했지만, 개발을 하면서 피로를 쉽게 느꼈고 수면욕도 늘었다. 운동과 개발의 관계를 놓고 보면 운동은 개발하는데 방해된다고 생각한다.운동하는 시간 대신 잠을 잔다면, 개발할 때 집중을 더 잘 할 수 있고,운동하는 시간 대신 개발을 한다면, 개발하는 시간을 늘릴 수가 있기 때문이다.하지만, 이러한 생각은 먼 미래를 내다보지 못하고 눈 앞에서 보고 느끼는 상황만 판단하고 있기 때문이다. 얼마전에 페이스북 타임라인으로 유명한 개발자분이 몸이 안좋다는 소식을 들었다. 댓글을 보면 다른 분들도 편찮은 곳이 있으신 것 같았다.그 정도로 개발에 대한 애정을 가지고 개발에 빠져 계셨을 것 같다는 생각이 들면서, 나는 왜 운동을 건강이 아닌 개발만 놓고 비교를 한건지 모르겠다. TODO 웨이트 보다는 유산소 운동 많이 하기 쉬는 시간 중 하루에 한번 정도는 밖에서 산책하기  URL 단축지난주에 인프라에 대한 고민을 좀 했다.Vue.js로 개발을 하고, S3에 배포할지, Lambda에 배포할지..URL 단축서비스 라면 Redirect가 가능하도록 해야 하는데, 같은 도메인(URL)에서 SPA을 함께 뿌려줘야 한다.ELB나 API GATEWAY로 Redirect하는 방법을 알아보다가 둘 다 방법을 찾지 못했다.결국 Spring Boot로 개발하고, Vue.js의 빌드 파일을 톰캣에 올리기로 했다. 왜 진작 이 방법을 떠올리지 못했을까?곰곰히 생각해보면 최근 AWS Lambda를 접하면서 AWS Lambda를 무조건 사용하고 싶었던 것 같다.대충 서비스 배포는 가능하긴한데 디자인이 너무 구리다.  프로그래머스 잡페어어제 프로그래머스 코테를 치고, 과제를 받았다.다행히 작년에 했었던 투두리스트가 아니다!! 이번 과제는 캘린더 구현이다. 작년 과제는 Spring Boot와 Vue.js로 만들었었는데, 이번에는 Spring MVC로 구현한다.오늘 Thymeleaf를 처음 써봤는데 학습이 좀 필요할 것 같다. 일주일 안에 테스트코드 까지 완성할 수 있을까? 해야지.. TODO 캘린더 매우 잘 만들기  실패한 경험?이번주 금요일에 싸피 밋업을 했다.서울지역 싸피1기, 2기가 함께 하는 행사다. 하루종일 배터지게 웃기만 하다 왔긴 한데, 강연을 들을 때 반성을 좀 했다.(강연 내용은 적을수가 없다) 실패를 해본 경험이 있나?별로 없다. 실패를 앞서서 도전도 하지 않은 것 같다.도전을 해야 경험을 할 수 있고 성장이 가능하다더라 나는 취미도 딱히 없다고 생각한다.게임은 진작에 때려 치웠고, 악기 연주에 대한 욕구도 없고.. 사업할 놈도 아닌것 같고.. 뭐 그냥 대충 사는 것 같다. 현재 빅스비 공모전이 있는데 빅스비나 해볼까 생각중이다.내가 가고자 하는 서버 개발은 아니지만, 최소한 개발해야 할 것은 생기고 협업하면서 느끼는 것도 있을 것 같아서 근데 또 모름다음주 되면 딴거 하고 싶은거 생길라나" }, { "title": "유튜튜 - 유튜브 크롤링 이슈", "url": "/2019/09/16/%EC%9C%A0%ED%8A%9C%ED%8A%9C-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%ED%81%AC%EB%A1%A4%EB%A7%81-%EC%9D%B4%EC%8A%88/", "categories": "Etc", "tags": "유튜튜", "date": "2019-09-16 00:00:00 +0000", "snippet": "몇일 전, 유튜튜를 들어가봤는데 문제가 생겼다.모든 채널의 구독자 수가 증가하지 않고 있었다.명절날 이 무슨 버그란 말인가! (시간별) (일별)아이유의 구독자수는 1,559,990 이라고 하지만, 확인해보니 157만 이상이었다. 언제부터 안됬던건지 로그 확인해보자select date_time +&#39;9hours&#39; korea_date_time, subscriberfrom channel_logwhere id = &#39;UC3SyT4_WLHzN7JmHQwKQZww&#39;; (DB)한국 시간으로 13일 오전 4시 넘어서부터 크롤링이 정삭적으로 되지 않았나보다. (CloudWatch)UTC로 2019-09-12 20시 정도부터 크롤링을 실패했다. 한국시간으로는 13일 오전 5시 조금 전이다.166초 후에 메모리가 터졌다. 띠용.. 왜 터졌나현재 크롤러는 2가지가 있다. 5분마다 유튜브 채널에서 구독자 수를 받아와 업데이트하는 크롤러 1시간마다 DB에 있는 현재 구독자 수를 로그로 남기는 크롤러여기서 문제가 되는 부분은 위의 크롤러이다.만약 밑의 크롤러에 문제가 있었다면 구독자가 유지되게 나오는게 아니라, 아애 시간조차도 뜨지 않았어야 했으니까 아래는 AWS Lambda 에서 크롤링하는 부분의 코드이다crwaler.pyimport reimport datetimeimport requestsfrom bs4 import BeautifulSoup as bsKST = datetime.timezone(datetime.timedelta(hours=9))PREFIX = &#39;https://www.youtube.com/channel/&#39;SUFFIX = &#39;/about&#39;headers = {&quot;Accept-Language&quot;: &quot;ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7&quot;}def crawling(channelId): res = requests.get(PREFIX + channelId + SUFFIX, headers=headers) soup = bs(res.text, &#39;html.parser&#39;) # 1 subscriber = soup.find_all(&#39;span&#39;, {&#39;class&#39;: &#39;subscribed&#39;}) subscriber = re.search(&#39;(?&amp;lt;=\\&amp;gt;).*(?=\\&amp;lt;)&#39;, str(subscriber)) if str(type(subscriber)) == &quot;&amp;lt;class &#39;re.Match&#39;&amp;gt;&quot;: subscriber = subscriber.group().replace(&#39;,&#39;,&#39;&#39;) if(re.search(&#39;[가-힣]&#39;, subscriber)): # 2. return crawling(channelId) else: subscriber = -1 aboutStat = soup.find_all(&#39;span&#39;, {&#39;class&#39;: &#39;about-stat&#39;}) views = re.search(&#39;(?&amp;lt;=&amp;lt;b&amp;gt;)[0-9,]+(?=&amp;lt;/b&amp;gt;회)&#39;, str(aboutStat)) if str(type(views)) == &quot;&amp;lt;class &#39;re.Match&#39;&amp;gt;&quot;: views = views.group().replace(&#39;,&#39;, &#39;&#39;) else: views = None joinDate = re.search(&#39;(?&amp;lt;=가입일:)[0-9. ]*&#39;, str(aboutStat)) if str(type(joinDate)) == &quot;&amp;lt;class &#39;re.Match&#39;&amp;gt;&quot;: joinDate = joinDate.group().split(&#39;.&#39;) year = int(joinDate[0]) month = int(joinDate[1]) day = int(joinDate[2]) joinDate = datetime.date(year, month, day) else: joinDate = None title = soup.find(&#39;meta&#39;, {&#39;property&#39;: &#39;og:title&#39;})[&#39;content&#39;] content = soup.find(&#39;meta&#39;, {&#39;property&#39;: &#39;og:description&#39;})[&#39;content&#39;] image = soup.find(&#39;meta&#39;, {&#39;property&#39;: &#39;og:image&#39;})[&#39;content&#39;] updatedTime = datetime.datetime.now(tz=KST) channel = { &#39;subscriber&#39;: subscriber, &#39;views&#39;: views, &#39;joinDate&#39;: joinDate, &#39;updatedTime&#39;: updatedTime, &#39;title&#39;: title, &#39;content&#39;: content, &#39;image&#39;: image } return channel 1.soup = bs(res.text, &#39;html.parser&#39;)이전에는 https://www.youtube.com/channel/채널아이디/about 에 크롤링을 하면구독자 수가 123,456 이런 식으로 나왔다. 2.if(re.search(&#39;[가-힣]&#39;, subscriber)):그런데 가끔씩 한 번씩 데이터가 123,456가 아닌, 12.3만 이라고 넘어오는 경우도 있었다.이 경우 다시 크롤링 해오는 방법으로 해결했었다. 엥…. 그럼 계속 12.3만 포맷으로 바뀐건가!!!! 구독자 정보를 더이상 자세하게 제공해주지 않는건가..이 무슨 추석날의 선물인가..  유튜브의 구독자 수 변동을 알려주는 사이트에서는 이 이슈를 현재 해결했는지 궁금해서 찾아봤다.해결 못했다. 여기도 버그투성이다. 명절이라 놀고 계신걸까 현재 유튜브가 제공해주는 구독자수로 그래프를 그리는 것은 과연 유의미한 것일까 싶다." }, { "title": "2019년 37주차 회고", "url": "/2019/09/16/2019%EB%85%84-37%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "계획과책임, 하반기공채, 이번주에구매한책", "date": "2019-09-16 00:00:00 +0000", "snippet": "지지난주 목표노션 공부안했다. 안했다. 안했다. 안했다. 안했다. 안했다. 안했다. 안했다.파이썬 코드 정리한다고 조금 쓰긴 했는데 거의 모른다고 봐야한다로컬 저장소로 쓰기에는 깔끔한 것 같긴 하다 유튜튜 리팩토링스프링 부트로 구현했던 코드를 DDD로 짜려고 계획했으나, 서버리스로 만들었다.파이썬으로 짰는데, 로직들이 도메인이라 할 것도 없을 정도로 간단해서 금방 끝났다.  계획과 책임얼마 전부터 일주일치 계획을 세웠다.하지만, 계획에 없던 흥미로운 것이 생기면 그것만 계속 눈에 들어온다.이런 상황을 어떻게 받아들여야 할까? 나는 계획을 미루고 눈 앞에 하고 싶은 것부터 하는 편인 것 같다.스스로의 계획에 대한 책임감이 부족한 것 같다.흥미로운 것이 갑자기 생기면 다음주 계획으로 세워놓고 현재의 계획을 먼저 해야할까? 그러다 다음주에 흥미를 잃어버리면? 정답은 알고 있다. 그냥 다 하면 된다.흥미로운 것도 하고, 계획도 하면 문제될게 없다. 다만, 나는 아직 그런 사람이 되지 못했다.  하반기 공채하반기 공채를 다 재꼈다.자소서를 쓰기가 왜 이렇게 귀찮은지…싸피를 하는데 삼성에도 원서를 넣지 않았다. 취업이 간절하지가 않은 걸지도 모르겠다  이번주에구매한책자바 최적화JVM에 대해, 바이트코드 등에 대해 전혀 무지해서 공부해볼까 해서 샀다그런데 자바 개발을 요새 계속 안한다. 다까묵겄네 AWS 기반 서버리스 아키텍처AWSKRUG Serverless 9월 소모임에 다녀왔었는데 서버리스에 완전 꽂혀버렸다.앞으로 간단한 프로젝트를 Serverless로 개발,배포 하려고 한다. 책 한권은 구비하고 있는 것이 좋을 것 같아, 칼라책인 위의 책을 구매했다.  이번주 목표TODO :: 매일 아침 헬스최근에 소화 능력도 많이 떨어졌는데, 하루종일 강의실에 앉아있어서 그런 것 같다.몸도 근질근질한게, 헬스를 다시 해야겠다.저녁시간에는 사람이 너무 많을 것 같아서 싸피 출근 전에 1~2 시간씩 운동하즈아~ TODO :: URL SHORTENER 개발SSAFY를 위한 URL Shortener 이다.디자인을 제외한 핵심 기능들을 이번주에 구현하는 것이 목표다 Vue.js DynamoDB AWS Lambda TODO :: DDD 스터디 준비 (DDD START! 8,9장)3주 만에 스터디다.앞에 내용들 많이 까먹었을 것 같은데, 스터디 했던 내용들을 정주행 해야하지 싶다." }, { "title": "EC2 키페어 분실했을 때 해결법", "url": "/2019/09/08/EC2-%ED%82%A4%ED%8E%98%EC%96%B4-%EB%B6%84%EC%8B%A4%ED%96%88%EC%9D%84-%EB%95%8C-%ED%95%B4%EA%B2%B0%EB%B2%95/", "categories": "AWS", "tags": "", "date": "2019-09-08 00:00:00 +0000", "snippet": "오랫만에 EC2인스턴스에 볼일이 있어 XShell로 SSH접속하려고 했다. todoListKey.pem 파일이 없더라. 포맷할 때 삭제했나보다.어떡하지? 검색했다.EC2 인스턴스의 /home/ec2-user/.ssh/authorized_keys 에 todoListKey.pem 정보가 들어있으니, 이 파일을 새로운 키페어로 바꾸면 된다고 한다.  어케 바꾸누?기존의 EC2 : A임시 EC2 : B1. 새로운 EC2 인스턴스 (B) 생성 2. 기존의 EC2 인스턴스 (A) 중지3. A의 EBS를 Detach 4. A의 EBS를 B에 연결 연결 확인  5. B의 터미널 접속B의 key를 A의 EBS에 복사$ mkdir /mnt/tmp_mount # 마운트할 경로$ mount /dev/xvdb1 /mnt/tmp_mount # 마운트$ cat /home/ec2-user/.ssh/authorized_keys &amp;gt; /mnt/tmp_mount/home/ec2-user/.ssh/authorized_keys # key 복사$ umount /mnt/tmp_mount #마운트 해제 6. A의 EBS를 B에서 Detach7. A의 EBS를 A에 Mount8. A 시작9. A에 SSH 접속 (B의 key 이용)OK 10. B 제거   A의 키페어 정보를 바꾸었음에도 불구하고 이름이 변경되지 않는다.그냥 B의 key 이름을 todoListKey.pem 으로 바꾸어서 보관해야겠다." }, { "title": "AWS RDS Connection 안될 때", "url": "/2019/09/03/AWS-RDS-Connection-%EC%95%88%EB%90%A0-%EB%95%8C/", "categories": "AWS", "tags": "", "date": "2019-09-03 00:00:00 +0000", "snippet": "RDS가 필요하다RDS 데이터베이스를 생성했다 Datagrip으로 접속했다응 안되 아! 포트 개방 해야지~응 그래도 안되 근본적으로 잘못 만들었다.RDS 데이터베이스를 해당 VPC 외부에서 접속하기 위해서는 위처럼 퍼블릭 액세스를 가능하도록 해주어야 한다.(Default : 아니요) OKpsql -h RDS엔드포인트 bactoria postgres  이거 해결하려고 2시간 동안 찾아다녔다. 당연히 보안규칙 문제일 줄 알았는데!!사실 몇 달 전에도 헤매다가 해결했던 건데… 역시 기록을 안하니 까먹는다" }, { "title": "2019년 35주차 회고", "url": "/2019/09/02/2019%EB%85%84-35%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "당근마켓, CoC, 야자, 이번주목표", "date": "2019-09-02 00:00:00 +0000", "snippet": "지난주 목표정규표현식 정리하자정규표현식을 마스터했다고 할 순 없지만, 필요한 정규식이 있으면 성능이 낮은 정규표현식 정도는 짤 수 있게 되었다. 또한 다른 사람이 작성한 정규표현식을 읽고 해석할 수 있게 되었다. 정규표현식을 익히는데 생각보다 시간이 많이 들었다. 앞으로는 유즈케이스를 많이 보면서 눈에 익혀야 할 것 같다. DDD 스터디 준비 (DDD START! 5 ~ 7장)스터디 준비를 착실히 하지 못했다. 책을 모두 읽고 가긴 했다. 스터디 당일날에도 책을 끝까지 읽지 못한 탓에 고속버스에서 책을 읽기까지 했다. 물론, 충분히 고민해보는 시간은 가지지 못했다. 오브젝트 다 읽자오브젝트 1페이지도 보지 않았다…첫 계획이라 목표를 무리하게 잡은건가? 이게 그렇게 무리한 일정은 아닌 것 같은데.. 흘려버리는 시간들이 많았던 것 같다. 실질적인 공부 시간을 많이 확보하지 못한 것 같다.  당근마켓당근마켓 개발자 채용 회사소개 오픈세션 을 다녀왔다.스타트업 개발자들이 어떤 생각을 가지면서 일을 하고 어떻게 학습하는지 궁금해서 참여하였다.다녀오고는 느끼는 것들이 있다.스타트업에서는 신입이든 경력이든 간에 잘하는 사람을 뽑아서 쓰려고 한다. 당근마켓에서도 신입을 뽑는다면 학습곡선이 좋은 사람을 찾고 있다고 했다. 경력이 잘하는 것은 기본이지만 신입이 잘하는 것은 Good!QnA 시간에 데이터 분석 신입이 가져야할 역량에 대한 질문이 있었다. 이에 대한 답변으로는 과연 당근 마켓 데이터 분석만을 하는 사람이 필요한가 였다. 분명 데이터 분석은 필요로 하지만, 이 일은 현재 마케터, 머신러닝 개발자들이 스스로 알아서 하고 있다고 했다. 데이터 분석을 하고 싶은 사람이 알아서 하기에 데이터 분석 포지션이 따로 필요하지가 않다. 다른 질문에서도 그들이 알아서 한다 라는 말을 굉장히 많이 들을 수 있었다.혼자 알아서 하는 것에 대해 당연시 하는 생각이 커진 것 같다. 보통 회사에 들어가면 사수도 있고, 그 사수는 나보다 경험이 많으니 가이드를 잘 해줄 것이라고 하는 기대감을 가지고 있었는데 생각이 좀 바뀌었다.  CoC파이콘을 갔다 온 이후로 CoC를 싸피에 널리 퍼트리겠다고 마음먹었다. CoC라는 좋은 문화를 형성하자는 취지였다. 하지만 상대에게 바라기 이전에, 내가 CoC를 먼저 지켜야 하는데 쉽지가 않다.단체 강연을 듣다보면 하지 말아야 할 말 실수들이 하나씩 보이기 시작한다. 그래서 강연이 끝난 후에 진행하는 설문에서 불만을 토로했다. 하지만, 영향력이 있기 위해서는 불만을 토로하기 전에 내가 먼저 CoC를 지켜야만 한다. 하지만 그러지 못했다.  야자싸피 정규 수업이 끝나고 저녁 6시부터 2시간 동안 야자를 할 수 있다. 공부하기에 매우 적은 시간이다. 집중 잘되고 있는데 집에 가야한다. 집에서 저녁을 먹은 후 추가로 공부하기가 애매하다. 9시에 카페를 갈 생각도 해봤지만, 이럴거면 애초에 야자를 할 필요가 없다. 차라리 수업이 끝나면 곧장 집에 가서 밥을 먹은 후 카페에서 공부하는 것이 공부량을 확보할 수 있다.  이번주 목표TODO :: 노션 공부목표: 노션을 왜 써야하는지에 대해서 느껴보기 TODO :: 유튜튜 리팩토링현재 도메인 로직이 모두 서비스 레이어에 있음. DDD로 짜봐야겠다" }, { "title": "GIF로 움직이는 파비콘 만들기", "url": "/2019/08/29/GIF%EB%A1%9C-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%ED%8C%8C%EB%B9%84%EC%BD%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Etc", "tags": "움직이는파비콘, 앵무새", "date": "2019-08-29 00:00:00 +0000", "snippet": "블로그 파비콘 바꿨다.원래는 지킬 테마에 있던 기본이었는데, 심심해서 바꿔봤다  1. GIF 다운로드GIF 파일을 준비한다. 앵무새는 여기에서 다운로드 받을 수 있다  2. GIF -&amp;gt; PNG 변환파비콘에 GIF 넣으면 아무 소용이 없다. 안움직인다.GIF을 .PNG 들로 변환한 후, 각 파일을 자바스크립트로 순서대로 돌려주면 됨 (.JPG는 흰배경이 남으니까 .PNG로 변환하자) JPG PNG  GIF -&amp;gt; PNG 변환하기 알집 풀면 아래처럼 나올 것이다 다른데서 변환해도 크게 상관없다.다만, 아래처럼 각 사진의 크기가 다르게 변환되는 곳은 피하자. 크기가 다르면 앵무새 움직임이 조금 이상할 수 있다 정상적인 무브먼트. 쉐낏쉐낏\\~  .ICO ?파비콘을 위한 확장자가 따로 있긴 하다..ICO 는 멀티사이즈를 지원하고, 모든 브라우저에 호환된다.다만 용량이 좀 커서 10개의 .ICO를 추가하기에는 약간 부담스러웠다 .PNG도 크롬, IE11은 지원하기에 .PNG로 진행했다.  3. 코드 수정이미지 파일은 모두 준비했으니 이제 코드를 손 볼 차례다 기존 코드&amp;lt;head&amp;gt; &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico?&quot; type=&quot;image/x-icon&quot;&amp;gt; &amp;lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico?&quot; type=&quot;image/x-icon&quot;&amp;gt; &amp;lt;!--...--&amp;gt;&amp;lt;head&amp;gt; 수정 후&amp;lt;head&amp;gt; &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/assets/favicon/p0.png?&quot; type=&quot;image/x-icon&quot;&amp;gt; &amp;lt;link id= &quot;favicon&quot; rel=&quot;icon&quot; href=&quot;#&quot; type=&quot;image/x-icon&quot;&amp;gt; &amp;lt;!--...--&amp;gt; &amp;lt;script&amp;gt; // favicon var faviconRoute = &#39;/assets/favicon/&#39;; var faviconNames = [&#39;p0.png&#39;, &#39;p1.png&#39;, &#39;p2.png&#39;, &#39;p3.png&#39;, &#39;p4.png&#39;, &#39;p5.png&#39;, &#39;p6.png&#39;, &#39;p7.png&#39;, &#39;p8.png&#39;, &#39;p9.png&#39;]; &amp;lt;!--파일이름은 짧게 변경했다--&amp;gt; var idx = 0; setInterval(func, 300); function func() { document.querySelector(&quot;#favicon&quot;).setAttribute(&#39;href&#39;, faviconRoute + faviconNames[idx++]); idx %= faviconNames.length; } &amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;   4. 완성앵무새가 생각보다 머리를 천천히 흔든다(setIterval을 10으로 둬도 위랑 비슷하더라)" }, { "title": "2019년 34주차 회고", "url": "/2019/08/26/2019%EB%85%84-34%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "개발회의감, 단기간목표", "date": "2019-08-26 00:00:00 +0000", "snippet": "개발 회의감수요일이었던가..? 갑자기 개발에 대한 회의감이 들었다.지난 주말, 파이콘의 후원사 부스에서 타다 라는 서비스를 알게되었고, 타다 기술블로그에서 타다 시스템 아키텍처 를 보게 됨쿠버네티스는 아직 쓰는곳이 없을 줄 알았는데, 타다 에서는 사용하고 있었고Kotlin도 백엔드(Spring boot)에서 사용하고 있었다.HTTP 통신은 Json이 아닌, Protocol Buffer를 이용하는 것도 신기했다.신기함을 느끼는 동시에 공허함이 밀려왔다.나는 지금 뭐하고 있나.. 개발하고 싶다는 놈이 2달동안 개발도 안하고.. 다른사람들은 지금도 계속 개발하고 있을텐데?내가 너무 남이랑 비교하고 있는걸까? 그럼 과연 나는 내 위치에서 최선을 다했다고 할 수 있을까? 나는 정말 잘 하고 있나? 이대로 괜찮은가?한가지 확실한 것은 하루하루가 보람차고, 내일이 기대되는 느낌이 없다 는 것이다.나 자신을 얼마나 자책해야 하고, 얼마나 위로해야 할지 모르겠다. 장기적인 프로젝트를 진행하면서 책에 담겨진 팁과 노하우를 프로젝트에 녹여내보고 싶다. 한 가지 프로젝트를 계획 중이긴 하지만, 단기간 프로젝트가 될 것 같다.서울에는 IT 연합 동아리도 많이 있더라. 디자이너랑 같이 협업할 수도 있고.. 마침 새로운 기수를 뽑는 곳도 있던데 지원해봐야겠다.  단기간 목표단기간 목표를 잡아본 지가 오래 전인 것 같다. 나는 계획없는 삶을 살았었다.앞으로 얼마나 지속될진 모르겠지만 일주일 단위의 계획을 세우고, 계획을 수행하는 과정에서 성취감을 조금씩 얻어가고자 한다.일주일 후에 계획에 대해서 회고하는 방식이 좋을 것 같다 TODO 1 :: 오브젝트 다 읽자10장까지 읽어놓고 또 안보는 것 같다. 이번주에 오브젝트 끝내야겠다물론 읽는 것에 의미를 두지 말고 충분히 고민하는 시간도 갖도록 해야 한다하루에 1장씩 읽으면 될 듯 TODO 2 :: 정규표현식 정리하자정규표현식에 대해서 잘 몰라서 공부하려고 책을 샀었는데, 책을 펴보지도 않은 듯..정규표현식은 안쓰면 까먹을 것 같으니까 일단 읽으면서 정리해야겠다다음에 정규표현식을 써야할 때 역량을 쉽게 끌어올릴 수 있도록 정리하는 것이 목표 TODO 3 :: DDD 스터디 준비하자DDD START! 5 ~ 7장" }, { "title": "파이콘2019 후기", "url": "/2019/08/19/%ED%8C%8C%EC%9D%B4%EC%BD%982019-%ED%9B%84%EA%B8%B0/", "categories": "리뷰", "tags": "", "date": "2019-08-19 00:00:00 +0000", "snippet": "작년에 이어, 지난주 금요일 백인서트를 시작으로 파이콘 2019 자원봉사를 했다. 파이썬 문법도 잘 모르지만, 파이콘을 다녀오면 너무 뿌듯하다.컨퍼런스를 참여하면서 느꼈던 것들을 남기고자 한다.  Code of Conduct (행동 강령)파이콘 자원봉사를 하면서 불쾌한 감정을 느낀 경험이 전혀 없었다.봉사를 하러 갔는데, 오히려 힐링을 하고 온 기분이다.그 이유에는 업무 강도가 세지 않아서일 수도 있겠지만, 개인적으로는 CoC의 영향이 큰 것 같다.  파이콘 행동강령 파이콘 한국은: 누구나 편안하게 참여할 수 있는 행사를 지향합니다.서로 다름을 인정하고 존중하는 분위기를 지향합니다.성별, 성적 지향, 성 정체성, 국적, 인종, 지역, 종교, 나이, 사회적 신분, 학력, 지식 수준, 외모, 장애, 질병, 음식 선호 등과 관계 없이 모든 참가자가 동등한 컨퍼런스를 지향합니다.서로 환영하는 분위기를 독려합니다. 오프닝, SNS 등으로 CoC를 상기시켜 주시고, 컨퍼런스장 곳곳에 CoC 관련 푯말이 있었다.이런 제약사항이 있다는 것에 대해 속박 당한다는 느낌이 들 수도 있을 수 있다. 하지만 진행위원분들이 하는 말씀에는 CoC에 대해 철저하게 지키려고 노력하시고, 최대한 배려하려는 마음을 느낄 수가 있어서 전혀 거부감이 들지 않았던 것 같다. 이는 준비위원분들 뿐만 아니라, 자원봉사자 사이에서도 좋은 영향으로 이어지지 않았나 싶다.특히 세션 러너 교육을 받을 때에 자원봉사자에 신경써주셔서 감사했다.  영어 회화지금껏 영어 회화에 대해 필요성을 잘 못느꼈다.하지만, 이번 컨퍼런스에서 영어를 써야할 때가 종종 있었다. 영어를 지금보다 좀 더 잘했다면 많은 것들이 달라졌을 것 같다.젯브레인 스티커를 줍줍하러 젯브레인 부스에 갔을 때다. 젯브레인 부스를 맡고 계신 외국분께서 인텔리제이를 사용하면서 불편한 점이 있다면 언제든지 피드백을 달라고 하시고, 그 외에도 많은 말씀을 하셨는데 잘 이해를 못해서 짧은 대답으로 얼버무려버린 것 같다.외국분과 함께 굿즈를 나눠줄 때에도 더 많은 대화를 나눌 수 있었을 것이다. 이 때 아, 영어를 잘하고싶어!! 라는 생각을 계속 했다.세션에서 질문을 해주신 외국인 분에게 책을 드릴 때에도 한국어로 된 책들이 각각 어떤 책인지를 친절하게 안내해줄 수도 있었을 것이다.영어로 말을 할 때마다 빈번히 나오는 말이 있다. I’m sorry but, I’m not good in English…  Clean Architecture파이콘2019에 인사이트도 후원사로 참여하였다.부스에 놓여있는 책들을 둘러보는데, 로버트 마틴의 신간 서적인 Clean Architecture 책이 떡하니 있었다.출판일은 8월 20일이라서 구매하려고 눈독 들이고 있던 책이었는데, 파이콘에서 출판 전에 구매할 수 있었다  석식양일간 준비위원회분들, 발표자분들과 함께 저녁식사를 하면서 이야기를 나눌 수 있었다. 파이콘에 대해서 많이 들을 수 있었고, 2시간 동안 소통할 수 있었다. 물론, 석식에서도 CoC는 유효했다.  마무리오늘 아침에 일어났을 때 지난 3일간의 일들이 모두 꿈처럼 느껴졌다.3일간 만났던 분들을 내년 파이콘 때가 되야 뵐 수 있어서 그런걸까..이번 컨퍼런스를 통해서 CoC를 SSAFY에도 널리 퍼트리고 싶다는 생각이 들었다.그리고, 기회가 된다면 내년에도 꼭 자원봉사 하고싶다.파이콘 자원봉사 강력 추천드립니다!!" }, { "title": "ObjectMapper는 Property를 어떻게 찾을까 ?", "url": "/2019/08/16/ObjectMapper%EB%8A%94-Property%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B0%BE%EC%9D%84%EA%B9%8C/", "categories": "Java", "tags": "", "date": "2019-08-16 00:00:00 +0000", "snippet": "최근에 Restful API 에 POST Method로 요청 시에 Body의 Json을 requestDto로 매핑하는데 있어서 @Setter가 필요없다는 것을 알게 되었다.@Reuqest Body에서는 Setter가 필요없다? - jojoldu스프링에서 POST Method로 요청을 받을 시에, Jackson2HttpMessageConverter가 Http Message의 Body(Json)를 객체(ReuqestDto)로 매핑시켜주는데, 이 과정에서 ObjectMapper.class 의 readValue(String content, Class&amp;lt;T&amp;gt; valueType) 를 사용한다. ObjectMapper를 사용하니까 dto에 setter가 없어도 매핑 된다는 것이었다. 그래서 requestDto에 Getter/Setter 없이 쓰려고 했는데, 아래와 같이 실패했다.@NoArgsConstructorclass RequestDto { private String name; private long value;}public class ObjectMapperTest { private static final ObjectMapper mapper = new ObjectMapper(); @Test public void ObjectMapper를_이용하여_Json을_객체로_매핑한다() throws IOException { String json = &quot;{\\&quot;name\\&quot;:\\&quot;name\\&quot;, \\&quot;value\\&quot;: 1}&quot;; mapper.readValue(json, RequestDto.class); }}Errorcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;name&quot; (class RequestDto), not marked as ignorable (0 known properties: ]) at [Source: (String)&quot;{&quot;name&quot;:&quot;name&quot;, &quot;value&quot;: 1}&quot;; line: 1, column: 10] (through reference chain: RequestDto[&quot;name&quot;]) UnrecognizedPropertyException 이 발생했다. Property ? 자바스크립트의 객체는 키(Key)와 값(Value)으로 구성된 프로퍼티(Property)들의 집합이다.json에는 name, value 키를 가진 Property가 있는데, 객체에는 name, value를 찾지 못하는 상황이다 그런데 여기서 @Getter를 추가했더니 매핑이 되더라.아니… 이게 왜 되지?  ObjectMapper는 Property를 어떻게 찾는가? ObjectMapper가 객체의 프로퍼티를 찾는 기본 정책을 찾아봤다.(Version: jackson-databind 2.9.9) ObjectMapper.classpublic class ObjectMapper extends ObjectCodec implements Versioned, Serializable { protected final ConfigOverrides _configOverrides; //... public ObjectMapper() { this((JsonFactory)null, (DefaultSerializerProvider)null, (DefaultDeserializationContext)null); } public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { //... this._configOverrides = new ConfigOverrides(); //... }}new ObjectMapper(); 를 할 때 new ConfigOverrides();를 호출한다. ConfigOverrides.classpublic class ConfigOverrides implements Serializable { public ConfigOverrides() { this((Map)null, Value.empty(), com.fasterxml.jackson.annotation.JsonSetter.Value.empty(), Std.defaultInstance(), (Boolean)null); }}Std.defaultInstance() 를 호출한다. VisibilityChecker.classpublic interface VisibilityChecker&amp;lt;T extends VisibilityChecker&amp;lt;T&amp;gt;&amp;gt; { public static class Std implements VisibilityChecker&amp;lt;VisibilityChecker.Std&amp;gt;, Serializable { protected static final VisibilityChecker.Std DEFAULT; //... public static VisibilityChecker.Std defaultInstance() { return DEFAULT; } static { DEFAULT = new VisibilityChecker.Std( Visibility.PUBLIC_ONLY, Visibility.PUBLIC_ONLY, Visibility.ANY, Visibility.ANY, Visibility.PUBLIC_ONLY); } public Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field) { this._getterMinLevel = getter; this._isGetterMinLevel = isGetter; this._setterMinLevel = setter; this._creatorMinLevel = creator; this._fieldMinLevel = field; } }}  타입 private default protected public Creator o o o o Getter x x x o isGetter x x x x Setter o o o o Field x x x o  Json를 객체에 파싱할 때 객체의 프로퍼티 정보를 알기 위해서는객체 생성을 위한 기본 생성자(접근 제한자 무관)가 반드시 존재해야 하고,Getter/Setter/Field 중에 접근 제한자가 위 조건을 만족하는 것이 하나라도 있어야 한다.(Dto에서 Builder 패턴 사용할 때 AllArgsConstructor 쓰는데, ObjectMapper를 위해서 NoArgsConstructor 를 꼭 추가해줘야 함.)  Getter/Setter 없이 Property를 읽도록 하는 방법들1. @JsonProperty@NoArgsConstructorclass RequestDto { @JsonProperty(&quot;name&quot;) private String name; @JsonProperty(&quot;value&quot;) private long value;}필드에 어노테이션만 추가해주어도 프로퍼티를 읽을 수 있다.다만, 모든 필드에 추가하기에는 부담이 있다. 2. @JsonAutoDetect@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)@NoArgsConstructorclass RequestDto { private String name; private long value;}클래스에 어노테이션을 추가하는 방법도 있다.클래스단위로 Visibility를 설정할 수 있다. 3. ObjectMapper 설정 변경ObjectMapper objectMapper = new ObjectMapper();objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);objectMapper로 매핑할 Dto에게 모두 동일한 Visibility를 부여하고자 한다면 이 방법이 깔끔한 것 같다.필드의 접근제한자가 private라도 읽을 수 있기에, 기본생성자와 필드만 있으면 읽을 수 있다. 이 방법이 성능저하를 일으키는지는 잘 모르겠다. RequestDto에서 Entity로 변환할 때 ModelMapper, Setter, Builder(생성자) , toEntity() 로 할 수 있는데, toEntity()를 사용한다면 dto에는 더이상 setter/getter가 필요가 없어진다.(ModelMapper의 경우에도 아래처럼 설정한다면 Getter/Setter 없이 매핑 할 수 있다.)ModelMapper modelMapper = new ModelMapper();modelMapper.getConfiguration() .setFieldMatchingEnabled(true) .setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);다만, 테스트할 때에는 불편할 것 같다.@Controller 테스트 할 때 dto에 대한 검증을 @toString으로 해야 한다거나,@Service 테스트 할 때 dto를 만들기 위해서 objectMapper를 써야할 것 같다.그렇다고 테스트의 편의를 위해 getter/setter를 추가하는 것이 좋은 방법일까는 모르겠다. 어떤 것이 더 나은 방법일까. 이것도 트레이드 오프인가  (Gson)Gson은 기본생성자와 getter/setter 없이, 필드가 private 이어도 매핑이 가능함.오와우~@ToStringclass RequestDto { private String name; private long value; // 생성자 접근시 RuntimeException 발생!! public RequestDto(String name, long value) { throw new RuntimeException(); }}public class GsonTests { private static final Gson gson = new Gson(); @Test public void Gson은_객체에_기본생성자_setter_getter가_없어도_매핑된다() { String json = &quot;{\\&quot;name\\&quot;:\\&quot;name\\&quot;, \\&quot;value\\&quot;: 1}&quot;; String result = &quot;RequestDto(name=name, value=1)&quot;; RequestDto requestDto = gson.fromJson(json, RequestDto.class); assertThat(requestDto.toString()).isEqualTo(result); // Test passed! }}" }, { "title": "2019년 32주차 회고", "url": "/2019/08/13/2019%EB%85%84-32%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "습기, 오브젝트, 도메인주도개발, 이번주에구매한책", "date": "2019-08-13 00:00:00 +0000", "snippet": "습기고시텔에 1개월간 지내면서 아직까지 큰 불편함이 없다.주방이 공용이라 요리를 못하지만, 요리 안해도 먹을건 많아서 불편하진 않다.방도 좁긴 하지만, 역삼 지하철을 타지 않아도 된다는 메리트는 매우 크다.불편한 점을 한가지를 꼽으라면 습기다. 요새 장마철이라 그런지 방이 너무 습하다.습기의 원인은 샤워나 빨래인 것 같다.아침에 샤워를 하고 밤에 돌아오는데, 방 안이 여전히 습하다.써큘레이터를 계속 틀어놓았으나 습기가 제대로 빠지지가 않는다.창문이 옆으로 여는 방식이면 좋았을텐데 아쉽다. 위로 재끼는 창문은 환기가 잘 안되는 것 같다.제습기를 사기에는 놔둘데도 없고, 소음도 많이날 것 같고..방 안에 제습제나 많이 까야겠다.에어컨 있는 곳으로 옮기면 좋긴 하겠지만.. 한 달 지나면 이 고민은 날씨가 알아서 해결해줄 것 같다. 오브젝트오브젝트 책을 절반정도 읽었다.9장까지 읽은 바로는 유연한 설계를 어떻게 할지, 다형성에 대해서 많이 알게된 것 같다.지금 책만 읽고 개발을 따로 하지 않으니까 고민하는 시간이 부족하다고 느낀다.내 코드를 기반으로 고민거리들을 책에서 찾는게 베스트 프랙티스같은데..DDD 5장까지 스터디하면 오브젝트 책이랑 유튜튜 리팩토링을 병행 해야겠다.유튜튜를 배포해놓은 AWS 계정의 프리티어가 10월까진데 이 서비스를 죽일지 살려둘지 모르겠다. 스프링 배치도 4월부턴가 뻗은 것 같고.. 수개월 간 방치만 했다 도메인 주도 개발싸피를 하기 전에 커뮤니티 사이트의 서버를 RESTful API로 만들다가, 싸피를 하러 서울에 올라왔다. 뒷부분은 다른분이 이어서 하신다고 했는데 코드 읽기가 힘들어서 다시 만들겠다고 했다.그 당시에 코드 읽기가 힘들다는 것에 대한 이유를 잘 몰랐다. 우테코를 하면서 나름 가독성에 대한 고민도 많이 했었고, 개발 할 때도 가독성에 대해 신경쓰면서 잘 짰다고 생각했었는데.. 단순히 코드를 보기 좋게 작성하는 것 뿐만 아니라, 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아진다. - DDD START!지금 내 코드를 다시 보면 도메인에 대한 가독성이 매우 낮다.DB 모델링을 하고 개발을 바로 했었는데, 너무 데이터 중심으로 생각한 것 같다.어떤 URL로 접근 할 경우, 리소스에 대한 CRUD로 생각했고, 데이터가 어떻게 변경되어야 하는지에 초점을 맞췄다. 메서드 이름들이 대부분 CRUD에 속한다. 그래서 도메인 로직을 표현하기에 너무나 부족했다.사실 REST에서 DDD가 가능한지는 아직 잘 모르지만, 확실한건 내 코드는 도메인을 제대로 표현하지 않았고 가독성이 구리다는 것이다.유튜튜를 리팩토링할 때 도메인 로직을 고민해봐야겠다.  이번주에 구매한 책 도메인 주도 설계 구현도메인 주도 개발 공부하면서 이해가 잘 안되는 부분은 이 책을 참고하려고 샀다.두께가 토비의 스프링 한권 정도 되는 것 같다. GOF의 디자인 패턴지난번 오브젝트 모임에서 디자인 패턴은 유연하지만 가독성을 떨어트린다는 말을 들으며 나도 공부해야겠다고 생각했다.책을 앞부터 정독한다기 보다는 필요할 때마다 해당 부분만 찾아서 볼 것 같다." }, { "title": "Optional", "url": "/2019/08/08/Optional/", "categories": "Java", "tags": "", "date": "2019-08-08 00:00:00 +0000", "snippet": "public static void main(String[] args) { Optional&amp;lt;String&amp;gt; strNotNull; strNotNull = &quot;ee&quot;; // compile error! strNotNull = Optional.ofNullable(&quot;ee&quot;); // bad strNotNull = Optional.of(&quot;ee&quot;); // best Optional&amp;lt;String&amp;gt; strNull; strNull = Optional.of(null); // bad strNull = Optional.ofNullable(null); // better strNull = Optional.empty(); // best} orNullableOptional을 처음 접한건 JPA를 사용할 때였다.User에서 findById를 했을 때, 리턴값은 Optional&amp;lt;User&amp;gt; 였다.만약 유저가 존재하지 않는다면 null 대신 Optional.empty()를 다뤄야 했기에,if(user == null) 대신 if(user.isPresent()) 를 사용했다.그런데 최근에 Optional을 잘못 사용하고 있었다는 느낌을 받았다. 기존 코드public class UserService implements UserDetailsService { // ... private void validateDuplicationWithNotDeletedUsers(Optional&amp;lt;User&amp;gt; user) { if (user.isPresent()) { throw new UserAlreadyExistsException(user.get().getUserId()); } } private boolean isSameProfile(User user, Attachment attachment) { if (user.getProfile() == null) { return false; } return user.getProfile().getAttachments().contains(attachment); } private boolean hasAttachment(UserModifyRequestDto requestDto) { return requestDto.getAttachment() != null &amp;amp;&amp;amp; requestDto.getAttachment().getIdx() != null; } private boolean hasAttachment(UserSaveRequestDto requestDto) { return requestDto.getAttachment() != null &amp;amp;&amp;amp; requestDto.getAttachment().getIdx() != null; }} 수정 코드public class UserService implements UserDetailsService { // ... private boolean isSameProfile(User user, Attachment attachment) { return Optional.ofNullable(user.getProfile()) .map(profile -&amp;gt; profile.getAttachments().contains(attachment)) .orElse(false); } private boolean hasAttachment(UserModifyRequestDto requestDto) { return Optional.ofNullable(requestDto.getAttachment()) .map(Attachment::getIdx) .isPresent(); } private boolean hasAttachment(UserSaveRequestDto requestDto) { return Optional.ofNullable(requestDto.getAttachment()) .map(Attachment::getIdx) .isPresent(); }}가독성이 좋아진 것 같다.Optional이 제공하는 기능을 제대로 사용하지 않고 있었다. (Collection)collection에서도 사용 가능하다.public class Application { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, null, 2, 3, 4, 5, null); Optional.ofNullable(numbers) // Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; .map(Collection::stream) // Optional&amp;lt;Stream&amp;lt;Integer&amp;gt;&amp;gt; .orElseGet(Stream::empty) // Stream&amp;lt;Integer&amp;gt; (1, null, 2, 3, 4, 5, null) .filter(Objects::nonNull) // Steram&amp;lt;Integer&amp;gt; (1, 2, 3, 4, 5) .forEach(System.out::print); // 12345 }}  orElse() 와 orElseGet()이 둘중에 하나는 아규먼트가 lazy한 장점이 있는 대신 가독성이 떨어졌던 것 같았는데 정확히 기억이 나지 않아서 테스트 코드를 작성해봤다.public class OptionalTest { @Test public void orElse_orElseGet_테스트() { Node node = new Node(); Node emptyNode = null; Optional.ofNullable(emptyNode).orElse(new Node()); // Node 생성됨 assertThat(Node.count).isEqualTo(1); Optional.ofNullable(emptyNode).orElseGet(() -&amp;gt; new Node()); // Node 생성됨 assertThat(Node.count).isEqualTo(2); Optional.ofNullable(node).orElse(new Node()); // Node 생성됨 assertThat(Node.count).isEqualTo(3); Optional.ofNullable(node).orElseGet(() -&amp;gt; new Node()); // Node 생성 안됨 assertThat(Node.count).isEqualTo(3); // 4 아님!! }}class Node { static int count = -1; public Node() { count++; }}orElse는 값이 있든 없든 객체를 생성하지만,orElseGet은 값이 존재하지 않을 경우에만 실행시킨다. Optional.java public T orElseGet(Supplier&amp;lt;? extends T&amp;gt; supplier) { return value != null ? value : supplier.get(); }파라미터로 Supplier 타입을 받게 되는데, Supplier는 Lazy Evaluation 하기 때문에 사용할 때까지 실행하지 않는 것이다." }, { "title": "Comparable vs Comparator", "url": "/2019/08/05/Comparable-vs-Comparator/", "categories": "Java", "tags": "", "date": "2019-08-05 00:00:00 +0000", "snippet": "Comparable vs ComparatorComparable: 현재 객체에 대해 정렬 가능 (기본정렬)Comparator: String.class 와 같이, 직접적으로 수정할 수 없는 클래스의 경우에 사용, 동적으로 정렬 기준을 바꿔야 할 경우에 사용 Comparable객체끼리 비교하고 싶은 경우, 해당 클래스에서 Comparable 인터페이스 구현하면 됨.객체를 만들 때 인터페이스를 구현해서 씀class Node implements Comparable&amp;lt;Node&amp;gt;{ String name; int age; @Override public int compareTo(Node that) { return Integer.compare(this.age, that.age); // 난 이게 좋아 }} return this.age == that.age ? 0 : this.age &amp;gt; that.age ? 1 : -1 코드 더티. 한눈에 이해 안됨. return this.age - that.age age가 음수이면 스택오버플로우 터짐 ( Integer.MAX_VALUE - (-1) ) return Integer.valueOf(this.age).compareTo(that.age) Good return Integer.compare(this.age, that.age) 난 이게 더 보기 좋음  한계 어떤 Node.class에 대해서 한가지의 방법으로 밖에 정렬 할 수 없음. 여러가지 정렬 기준을 만들 수 없음. (Comparator 써야 함.)  ComparatorPriorityQueue, TreeSet 등의 객체끼리 비교를 관리해야 하는 경우, 생성할 때 기준을 지정해줄 수가 있음.class AgeComparator implements Comparator&amp;lt;Node&amp;gt; { @Override public int compare(Node o1, Node o2) { return Integer.compare(o1.age, o2.age); }}public class Main { public static void main() { Queue&amp;lt;Node&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(new AgeComparator()); }} Comparator :: 클래스 -&amp;gt; 람다로 변환class AgeComparator implements Comparator&amp;lt;Node&amp;gt; { @Override public int compare(Node o1, Node o2) { return Integer.compare(o1.age, o2.age); }}class NameComparator implements Comparator&amp;lt;Node&amp;gt; { @Override public int compare(Node o1, Node o2) { return o1.name.compareTo(o2.name); }}class Node { String name; int age;}public class Main { public static void main() { //... // 1. NameComparator (Basic) list.sort(new NameComparator()); // 2. 익명 클래스 list.sort(new Comparator&amp;lt;Node&amp;gt;() { public int compare(Node o1, Node o2) { return o1.name.compareTo(o2.name); } }); // 3. 람다식 list.sort((Node o1, Node o2) -&amp;gt; { return o1.name.compareTo(o2.name); }); // 4. 람다식이 한줄이라면 더 생략 가능 list.sort((o1,o2) -&amp;gt; o1.name.compareTo(o2.name)); }}" }, { "title": "2019년 30주차 회고", "url": "/2019/07/28/2019%EB%85%84-30%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "오브젝트, 싸피친구들, 이번주에구매한책", "date": "2019-07-28 00:00:00 +0000", "snippet": "오브젝트아샬님이 주최하시는 한달에 한권씩 개발서적 읽는 모임이 있다. 7월의 책은 조영호님의 오브젝트 였다. 조영호님의 전작인 객체지향의 사실과 오해 책을 아주 감명깊게 읽었기 때문에 이번 모임에 신청했다.유튜브로만 보던 개발자를 실제로 뵐 수 있어 설레면서도 한편으로는 너무 부끄러웠다. 모임까지 약 3주간의 시간이 있었으나, 총 15장 중에 2장까지 밖에 보지 못했기 때문이었다. 겨우 2장까지 읽고 모임에 참석해도 될까에 대한 죄책감이 들면서도, 안들키고 어떻게 잘 넘어갈수도 있지 않을까 하는 나쁜생각으로 모임에 참석했다.모임의 진행 방식은 각자 책의 좋았던 점과 아쉬웠던 점 그리고 궁금한 점을 말하면 그 주제로 토론하는 식이다. 현업에서 일하시는 분들이 대부분이었고, 연차가 많으신 분들도 계셨다. 책을 읽으며 이해가 안되는 부분들을 약 2시간 동안 토론할 수 있는 자리였는데 나는 듣기만 하다가 왔다. 내가 할 수 있는건 추후에 책을 읽을 때 진입장벽이 낮아지기를 기대하며 듣는 것 밖에 없었다. 2시간 동안 많은 것들을 들을 수 들었지만, 한편으로는 많은 것들을 놓쳤을 것이라고 생각했다. 크게 성장할 수 있는 좋은 기회를 날렸다.아래는 내가 말했던 궁금한 점과 답변들이다. Q. 좋은코드는 잘 동작해야 하고, 유지보수성이 좋아야하고, 읽기 쉬워야 한다는 것에 동의한다. 유지보수성을 높이면 가독성도 높아질 것 같았는데 책에 보니 유지보수성이 높아지면 가독성이 낮아진다고 한다. 흠.. 혹시 내가 생각하는 가독성과 책에서의 가독성이 다른 것인가.. A1. 유연한설계는 유연성이 필요할때만 옳다. (p305)유연한 것은 좋지만, 불필요한 유연성은 불필요한 복잡성을 낳는다. 여기서의 복잡성이 가독성을 해칠 수가 있다. 유연성은 코드 읽는 사람이 복잡함을 수용할 수 있을 때만 가치가 있다. 책에 나오는 Movie 예제에서도, 각자 팀에 따라서는 할인 정책이 한 개만 있을 수도 있다. 이 경우에는 할인정책은 없어도 되는거거든. Movie 해놓고 그 영화만 SpecialMovie 할 수도 있는 거임. 누가 봐도 명확함. 이건 유지보수성은 나쁘지만 가독성은 좋음. 반면에, 여러개 될 것 같은데 하면서 처음부터 만들기 시작하면 내가 알아야 하는게 점점 늘어난다. 뭔가 일어날지 모르니까 해놓았어? 이건 코드의 가독성을 떨어트림.이거 트레이드오프다. 팀에 따라 적절한 설계를 계속 찾아야함. 켄트벡은 XP에서 YAGNI(You aren’t gonna need it) 라고 했다. 너 아직 그거 안필요할걸? 미래를 위해서 열어놓긴 해도 과도하게 설계하지는 마라. 이런걸 많이 하느니 오히려 리팩토링해도 안전하도록 테스트 코드나 많이 만들자~ A2. 디자인패턴을 생각해보면… 디자인패턴은 유연한 설계의 결과물이다. 하지만 디자인패턴을 깨우쳤을 때 흔히 하는 실수가 디자인패턴을 모든곳에 적용하려고 한다는 것이다. 이것이 안좋은 이유는 코드를 이해하기가 매우 힘들어진다. 함축적이고 동적이기 때문이다. 가독성이란 것을 명명법이나 한가지 일만하는 메서드로 만드는 것 정도로 생각했지, 유연함을 추구하는 설계의 복잡성으로 인한 가독성 저하는 미처 생각하지 못했다.내가 너무 기초적인 것들을 질문한 것 같으면서도 친절하게 답변해주신 분들께 너무 감사하다. 그렇다고 부끄러워서 감사하단 말 한마디도 못했다.  싸피 친구들싸피를 하면서 이전 조원들이랑 치맥을 했다. 싸피하기 전에는 이런 친목질을 절대 안하고 싶었는데, 막상 애들을 만나보니까 뭐든 같이 하고싶다는 생각이 들더라. 다들 성격이 너무 좋다. 이전 조원들이 나에겐 너무 과분하고 좋은 사람들로만 구성되어 있어서 너무 감사했고, 이번에 함께 술먹으면서도 다시 한번 느꼈다.나처럼 취업에는 별 관심없고 개인 공부하러 온사람이 생각보다 많은 것 같다. 할말하않  이번주에 구매한 책DDD Start!주말에 아는 형이랑 도메인주도설계 스터디를 하려고 구매했다. 설계에 대한 공부를 해볼까 해서. (주말에 혼자 카페에서 있는것도 너무 고독이다)인터넷으로 교보문고에서 책을 사려고 했는데 품절이었다. 광화문쪽에 1권이 남아있었는데, 광화문 근처에서 일하는 형이 점심시간에 구매해줘서 살 수 있었다. UML 실전에서는 이것만 쓴다이번 오브젝트 책에서도 나오고, 모임에서도 다이어그램에 대해서 이야기가 많이 나왔다.다이어그램은 수업 시간에 엄청 대충 들었던건데, 오브젝트 모임에서 나빼고 다 알고있는 그런 느낌을 받았다. 설계할 때에도 무조건 알고 있어야 할 같아서 구매했다. 읽기 좋은 코드가 좋은 코드다이 책이 맞는지는 정확히 기억은 안나지만, 다음 모임에 선정된 책인 것 같다. 이번 모임에서 내가 너무 부족하다고 느꼈지만, 그래도 책을 읽기 위한 동기 부여는 확실하기에 구매했다. 일단 사놓고 다 읽으면 모임에 신청하고, 다 못읽으면 신청안하는 걸로.." }, { "title": "2019년 29주차 회고", "url": "/2019/07/21/2019%EB%85%84-29%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "결혼, 취업, 파이콘, JustDoIt", "date": "2019-07-21 00:00:00 +0000", "snippet": "결혼금요일에 대학교 선배, 동기들이랑 술먹었다. 연봉에 대한 이야기가 많이 나오는 것 같다.누구는 많이받고 누구는 적게받고… 개발에 돈을 따지면서 하다보면 진짜 개발 못할 것 같은데.. 연봉에 대한 이야기는 안했으면 좋겠다. 돈으로 모든게 해결되나? 결혼 땜에 그러는건가?저번주에 금요일 KTX 타고 부산 내려갈 때 옆자리에 군인공제회에서 일하시는 분이 앉았다. 우리 아버지 동년배였는데, 동대구까지 가셔서 약 2시간동안 대화를 나누게 되었다.결혼을 꼭 하라고 하더라. 그 이유 중에 하나가 50세 정도 되었을 때 남들은 아들,딸과 같이 시간을 보내는데 혼자 살면 외롭고 남들이 부러울 것이라고 하셨다. 나는 그런걸 원해서 결혼하는건 아닌것 같다고 하니까 아직 젊어서 그런걸 모르는 거라고..또 다른 이유는 내가 죽었을 때 장례를 치룰 누군가가 필요하다는 것이다. 아들, 딸이 있으면 내가 죽더라도 아들, 딸, 지인 등 여러명이 있으면 장례식이 풍성해지고(?) 다른사람들이 봤을 때 저 사람 평소에 잘 살았구나.. 라고 생각한다던가?죽을 때 죽고 나면 그런게 무슨 의미가 있느냐가 내 의견이다. 아들, 딸이 있으면 내 장례식이 좀 더 풍성해지겠지만, 그것 또한 결혼해야 할 이유가 될 수는 없다고 생각한다. 죽고 나서 다른 사람들이 장례식을 오던 말던 그거까지 신경을 쓸 이유가 있나?다만, 내가 아프고 힘들 때 혼자서 앓고 있으면 너무 속상할 것 같다는 생각은 들더라. 취업친한 친구도 취업했다. 같은 동아리의 선배, 동기 중 나 빼고 다 취업한 것 같다. 대부분 다 잘 갔다. 근데 난 조바심이 없다. 잡코리아, 사람인 들어가지도 않고 공채가 언젠지도 모른다. 왜 이런건지 잘 모르겠다. 일하기가 싫냐??? 파이콘8월 중순 파이콘이 열린다. 표 구매와 동시에 자원봉사자를 신청했다. 작년 파이콘에서 자원봉사를 한 경험이 있는데 그 때 너무 재밌었고, 좋은 추억이었던 것 같아 올해도 신청했다. 나는 파이썬에 대해서 잘 모른다. 기껏해봐야 셀레니움을 이용하여 매크로 돌리는 정도, cs231n 강의들으면서 mnist 모델 학습 시켜보는 정도였으니.. 그러다보니 자원봉사자 신청할 때 자기소개에 적을 말이 별로 없어서 떨어질 것 같았다. 운좋게도, 지난 금요일에 파이콘 자원봉사자로 선정됬다는 메일을 받았다.누군가는 파이썬으로 개발하지도 않으면서 굳이 7만원을 들여서 자원봉사를 할 필요가 있냐고 의아해할 수 있겠지만, 작년 기억을 떠올려 보면 전혀 돈이 아깝지 않은 경험이었다. 이런 큰 행사에 내가 기여할 수 있다는 것 만으로도 앞으로의 내 개발 의지를 불타오르게 해주는데 더 이상의 이유가 필요할까슬랙 채널에 작년에 함께 자원봉사자 했던 분들이 몇분 보이셨는데, 올해에도 좋은 경험 했으면 좋겠다. Just Do It뭘하든 상관없으니까 제발.. 좋아하는걸 택하고 빠져들자. 어중간하게 살지 말고..그럼 최소한 인생을 뒤돌아 봤을때 후회는 안할 테니" }, { "title": "뻘글, 남은 올해 목표", "url": "/2019/07/18/%EB%BB%98%EA%B8%80,-%EB%82%A8%EC%9D%80-%EC%98%AC%ED%95%B4-%EB%AA%A9%ED%91%9C/", "categories": "회고", "tags": "", "date": "2019-07-18 00:00:00 +0000", "snippet": "싸피 교육한지 2주가 조금 넘었다. 싸피 소개를 보면 자기주도형 학습이라고 하던데 아직 잘 모르겠다. 전혀 아닌거같은데..지금 가장 큰 문제점은 하루 하루를 만족하면서 잠들지 못하는 것이며, 앞으로도 변함없을 것 같은 느낌이 든다는 것이다.지난 우아한 테크 코스를 탈락하고서는 다짐했었다. 나는 합격생들보다 훨씬 더 성장해있을 거라고.하지만 지금처럼 시간을 흘려보낸다면 택도 없다.학습에 집중하는데 있어 방해되거나 신경써야 할 부분들이 한 두개씩 보인다. 그냥 고등학교를 다시 다니는 느낌이다. 싸피의 장점을 생각해보면 혼자 있을 때 보다 덜 외롭고 덜 지칠 수 있는 것 같다.그런데 이것도 마음맞는 사람 한 명만 있어도 커버되는 부분이다. 애초에 그런 사람 찾아서 같이 공부하려고 했는데 생각보다 찾기가 어렵다.내가 이런 말을 하니까 프로불편러가 된 것 같다. 매우 건방져. 근데 애초에 그런 사람들은 단체 교육에 지원서도 안썼을 것 같기도 하다.공부할거 진짜 많은데, 나중에 싸피를 선택한 것에 대해 후회를 안했으면 좋겠다. 22일날 아샬님의 오브젝트 책 세미나가 있는데, 책도 2장까지만 읽은 것 같다. 조졌다. 책 내용이 나에게 좀 어렵기도 하지만, B형 테스트 공부를 핑계로 책을 안읽었다.정말 된사람은 아무리 바빠도 책을 끝까지 읽었을텐데.. 하루를 어떻게 보내는지 분석해 보았다. 패턴이 크게 4가지로 나눠지더라. 아침 자습 (7-9시) 일어나서 개인 공부 정규 교육 (9-18시) 시간은 8시간인데, 집중도 잘 안되고 개인 공부하기엔 눈치 볼 수 밖에 없음 야간 자습 (18-20시) 공부하기 제일 괜찮은 시간 하지만 집중 잘되기 시작하면 20시 되어있음 집 (21-?시) 글쓰기 좋은 시간 책 읽기도 좋은 것 같음 코딩하기엔 좀 불편함 (책상땜에) 가장 공부 잘 되었던건 야간 자습시간인 것 같다. 시간이 너무 짧은 것이 매우 아쉽다.지난 1년간 학습에 있어서 불필요한 관계의 단절을 중요하게 느꼈는데, 현재의 생활은 정반대인 것 같다. 낭비하는 시간들이 너무 많다. 의식적으로 단절을 할 필요가 있다.지난달 부산에서의 생활과 비교해보면 하루 하루 학습량은 매우 부진하다.숙면을 취하는 이유가 지금 공부하는 것보다 자고 일어나면 더 잘될 것 같기 때문에 잠자는 날이 오면 좋겠다. 우테코 2기의 코테, 프리코스를 위한 알고리즘,객체 공부를 해야겠다고 생각하니 갑자기 힘이 솟는다. 몇 달간은 훌륭한 자극제가 될 것 같다. 글 쓰기를 잘한 것 같다.올해 목표: SW 역량테스트 B형을 따고 우테코 2기 합격하기" }, { "title": "Enum 정리", "url": "/2019/07/18/Enum-%EC%A0%95%EB%A6%AC/", "categories": "Java", "tags": "", "date": "2019-07-18 00:00:00 +0000", "snippet": "Basicnon-enumclass State { public static final State READY = new STATE(); public static final State PLAY = new STATE(); public static final State EXIT = new STATE();} enumenum State { READY, PLAY, EXIT}  1. 코드성 엔터티public enum AttachmentGroupRole { PROFILE, BOARD}public enum BoardType { A,B,C}public enum BoardCommentStatus { AVAILABLE, DELETED}public enum UserRole { USER, ADMIN}프로젝트 할 때 코드성 엔터티를 DB로 안빼고 Application 단에서 처리했었음 2. 싱글톤 구현// 열거 타입 방식의 싱글턴 - 바람직한 방법 (이펙티브자바 3E :25p)enum Elvis { INSTANCE; public void leaveTheBuilding() { System.out.println(&quot;기다려 자기야, 지금 나갈께!&quot;); }}public Main { public static void main(String[] args) { Elvis elvis = Elvis.INSTANCE; elvis.leaveTheBuilding(); }} 직렬화, 리플렉션 에도 싱글톤 유지함. static final / static method 로 싱글톤을 구현하는 경우는 직렬화를 위해 추가적인 작업 필요 리플렉션으로 객체 생성 가능해서 의도적으로 싱글톤을 무너트릴 수 있음. 근데 이거 쓰는거 본적이 없는데.. 3. 데이터 그룹 관리public enum BoardGroup { ADMIN(&quot;관리자&quot;, Arrays.asList(&quot;안되&quot;, &quot;오지마&quot;)), USER(&quot;유저&quot;, Arrays.asList(&quot;자유게시판&quot;, &quot;구루구구&quot;)), EMPTY(&quot;없음&quot;, Collections.emptyList()); private String title; private List&amp;lt;String&amp;gt; boards; private BoardGroup(String title, List&amp;lt;String&amp;gt; boards) { this.title = title; this.boards = boards; } public static BoardGroup findByBoardCode(String boardCode) { return Arrays.stream(BoardGroup.values()) .filter(boardGroup -&amp;gt; boardGroup.hasBoard(boardCode)) .findAny() .orElse(EMPTY); } private boolean hasBoard(String boardCode) { return boards.stream() .anyMatch(board -&amp;gt; board.equals(boardCode)); }}이동욱님의 글을 참고 함. http://woowabros.github.io/tools/2017/07/10/java-enum-uses.html  4. 익명 메소드사칙연산을 수행하는 Operation을 만들 수 있따.익명메서드를 선언하고, 구현은 위에서 해버리기.// 이펙티브자바 &amp;lt;Item 34&amp;gt;enum Operation { PLUS(&quot;+&quot;) { public double apply(double x, double y) { return x + y; } }, MINUS(&quot;-&quot;) { public double apply(double x, double y) { return x - y; } }, TIMES(&quot;*&quot;) { public double apply(double x, double y) { return x * y; } }, DIVIDE(&quot;/&quot;) { public double apply(double x, double y) { return x / y; } }; private final String symbol; public abstract double apply(double x, double y); Operation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; }}public class AbstractMethod { public static void main(String[] args) { double x = 1.1; double y = 3.3; for (Operation op : Operation.values()) System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.apply(x, y)); // 1.100000 + 3.300000 = 4.400000 // 1.100000 - 3.300000 = -2.200000 // 1.100000 * 3.300000 = 3.630000 // 1.100000 / 3.300000 = 0.333333 }} 5. Functional Interface위의 익명 메서드 대신 Functional Interface를 사용하여 사칙연산을 구현할 수 있다.// 이펙티브자바 &amp;lt;Item 42&amp;gt;public enum Operation { PLUS(&quot;+&quot;, (x, y) -&amp;gt; x + y), MINUS(&quot;-&quot;, (x, y) -&amp;gt; x - y), TIMES(&quot;*&quot;, (x, y) -&amp;gt; x * y), DIVIDE(&quot;/&quot;, (x, y) -&amp;gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.symbol = symbol; this.op = op; } public double apply(double x, double y) { return op.applyAsDouble(x, y); } @Override public String toString() { return symbol; }}우테코 프리코스 과제 (숫자 야구게임)public enum State { PLAY_CONTINUE(Constant.PLAY_CONTINUE_NUMBER), EXIT(Constant.EXIT_GAME_NUMBER); private final int value; private State(int value) { this.value = value; } public static State findState(int i) { return Arrays.stream(State.values()) .filter(x -&amp;gt; x.getValue() == i) .findAny() .orElseThrow(() -&amp;gt; new IllegalArgumentException(&quot;잘못된 입력 값 입니다. :: &quot; + i)); } public int getValue() { return value; }} 우테코 프리코스 과제 (로또)public enum Rank { FIRST(6, 2_000_000_000), // 1등 SECOND(5, 30_000_000), // 2등 THIRD(5, 1_500_000), // 3등 FOURTH(4, 50_000), // 4등 FIFTH(3, 5_000), // 5등 MISS(0, 0); private static final int WINNING_MIN_COUNT = 3; private final int countOfMatch; private final int winningMoney; private Rank(int countOfMatch, int winningMoney) { this.countOfMatch = countOfMatch; this.winningMoney = winningMoney; } public int getCountOfMatch() { return countOfMatch; } public int getWinningMoney() { return winningMoney; } public static Rank valueOf(int countOfMatch, boolean matchBonus) { if (countOfMatch &amp;lt; WINNING_MIN_COUNT) { return MISS; } if (SECOND.matchCount(countOfMatch) &amp;amp;&amp;amp; matchBonus) { return SECOND; } for (Rank rank : values()) { if (rank.matchCount(countOfMatch) &amp;amp;&amp;amp; rank != SECOND) { return rank; } } throw new IllegalArgumentException(countOfMatch + &quot;는 유효하지 않은 값입니다.&quot;); } private boolean matchCount(int countOfMatch) { return this.countOfMatch == countOfMatch; }} " }, { "title": "&#39;구글 검색과 자바스크립트 사이트&#39; 정리", "url": "/2019/07/10/'%EA%B5%AC%EA%B8%80-%EA%B2%80%EC%83%89%EA%B3%BC-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%82%AC%EC%9D%B4%ED%8A%B8'-%EC%A0%95%EB%A6%AC/", "categories": "리뷰", "tags": "", "date": "2019-07-10 00:00:00 +0000", "snippet": "지난주 금요일에 짐 챙기러 부산에 내려왔는데, 다음날 부산대에 Google I/O Extended 2019 Busan 행사가 있어 참석했다.아래 내용은 조은님이 발표하신 자바스크립트는 구글에서 어떻게 검색이 되는가? 를 정리한 내용이다.조은님께서 블로그에 공유해도 된다고 흔쾌히 허락해주셔서 포스팅 하려고 한다.조은님이 따로 포스팅한 글 Google 검색은 어떻게 동작하는가? - Medium도 있다. 구글 검색과 자바스크립트 사이트 검색어 입력 검색 서비스는 기존의 검색 결과를 찾게 되면 사용자가 원하는 방향으로 검색 결과를 보여줌 검색이란? 데이터를 긁어와서 필요한 데이터만 정제한 후 유용한 것만 다시 검색 결과에 노출시키는 것 GoogleBot은 어떻게 데이터를 모으는가? GoogleBot 컨텐츠를 크롤링하는 크롤링봇임 공식이미지 귀여움ㅋㅋ 정통적인 웹사이트 (정적 페이지) 컨텐츠가 완성된 html이 정통적인 정적페이지 방식임 자바스크립트는 메뉴를 눌렀을때 다른걸로 이동시키는 용도였음 애초에 Body 내부에 &amp;lt;p&amp;gt; 로 컨텐츠가 있기 때문에 구글봇이 방문을 했을 때 인지를 바로 할 수 있음 현대의 웹사이트 (동적 페이지) 웹사이트는 AJAX를 호출해서 페이지를 만듬 (컨텐츠를 자바스크립트로 동적으로 생성함) GoogleBot 최초로 방문을 했을 때 Body 에는 이것밖에 없음 사람들은 이걸로 컨텐츠가 뭐가 나오는지 알 수 없음ㅋㅋ 요즘은 자바스크립트를 실행하지 않고서는 어떤컨텐츠가 있는지를 알 수가 없음 SPA는 검색이 되지않는다? 왜냐하면 사람도 저 위에꺼 모르니까 봇도 모르지 않을까 아니다!! 구글봇은 똑똑함 해당 페이지를 렌더링하기 때문에 페이지 컨텐츠를 가져갈 수 있음 &amp;lt;body&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/body&amp;gt;  구글 검색 상위랭크에 위치시키려면 GoogleBot을 알아야 함 구글봇은 Chrome을 사용해서 렌더링함 크롬은 3년전 41버전. 지난주는 75버전임 (요즘은 4주에 한번씩 릴리즈함) v8엔진 3년사이 성능 3~4배 향상됨 (크롬 버전이 높을수록 페이지를 크롤링해가는시간이 빨라짐) Puppeteer 크롬을 더 잘 구동시키기 위한 Node API 크롬을 headless모드로 구동시킬 수 있음. 캔버스(결과)만 보여주는 모드 구글봇 + Puppeteer Puppeteer를 이용해 페이지를 렌더하고 렌더된 결과물을 수집함 SPA은 검색 결과 노출에 영향을 미치지 않는다! “SPA는 검색이 되지 않아요.” 라는 오해를 풀어주고 싶었음 festa.io 도 SPA인데 구글에서 검색 잘됨 SPA 단점을 말해주자면 아무리 빨라도 SSR보다 느림 (일반적으로) 클라이언트가 자바스크립트 렌더링이 아무리 빨라도 서버에서 만들어서 내려주는것 보다 느릴 수 밖에 없음 그래서 SPA+SSR 적절히 섞는 방법을 권장 but, 겁나 어려움  SEO Search Engine Optimizer Google Engine은 어떻게 동작하는가? 2달전 Webmaster Conference Seoul 행사가 있었음 거기서 구글 직원이 구글검색 어떻게 검색하는지 모른다고 했음 Google io 발표 연사자가 구글검색 어떻게 동작하는지 모른다고 했음 Google Engine 만드는 사람은 몇명? 약 3~400명이 구글검색의 코어(알고리즘)을 건드리고, 지원조직까지 건드리면 1000명이 넘을 것임 수많은 알고리즘이 구글검색에 쌓이고 쌓인것이 현대의 구글 검색임 정확히 “이렇게 동작하니까 이렇게 하세요” 라고 하는건 현실적으로 불가능함  Robots.txt GoogleBot의 웹 컨텐츠 접근 권한을 제어하는 파일구글 검색결과에 노출되기 싫은 사이트를 숨길 수 있음 Mnet의 Music API가 구글 검색에 노출된 경우가 있음. API가 노출되면 외부에서 긁을 수 있음 트래킹 가능 별거 아닌것 같아도 보안상 취약점이 될 수 있음 Robots.txt로 막지 않아서 생긴 문제임 딱히 막을게 없다면 Robots.txt를 만들 필요 없음 Robot.txt를 안넣으면 이전에 네이버 검색에서 크롤링 안하도록 한 적이 있음 User-agent: * Disallow: / 네이버 검색결과에 노출은 되지만 이페이지를 들어갔더니 가지고 올 수 있는게 / 밖에 없다?! robots.txt 취약점 어느 페이지에 들어가시던 robots.txt를 들어가면 외부인이 볼 수 있음 네이버에서 /robots.txt 를 들어가면 보임 https://www.naver.com/robots.txt 페이스북에 들어가도 보임 https://www.facebook.com/robots.txt 뭐가 문제일까? /admin이 있네? 들어가볼까? 이거 크래킹해볼까? 위와 같은 robots.txt가 보안 취약점을 노출시킴 User-agent:*Disallow: /admin/Disallow: /internal/ 그럼 어떻게 할까? 도메인 분리 (sub 도메인) 해당 도메인 통째로 차단 ex) nid.naver.com 네이버 회원가입 페이지. 구글에 검색이 안됨 인증 검색이 되면 안되는 내부 페이지는 인증을 거쳐야만 볼 수 있도록 구글봇이 아무리 똑똑해도 계정을 만들지는 않을거임ㅋㅋ 계정 인증이 반드시 필요한 상황에는 검색결과가 노출이 되지 않음 반대로 검색 노출이 필요하다면 public으로 설정해야 함 robots.txt 표준 2019/07/01에 robots.txt 표준을 만들기로 함. 깃허브의 robotstxt 지금까지의 구글검색은 이렇게 하겠지 였음 이제부터는 명시적으로 ‘이렇게 하는구나’ 를 알 수 있게 됨  (2019.09.29 추가)Search Console 에서 Disallow: 가 정상적으로 동작하는지 쉽게 테스트 해볼 수 있다!! 웹페이지 상위랭크에는 무엇이 필요한가1. 올바른 &amp;lt;title&amp;gt; 값 사용나쁜 사례RecipeRecipeRecipe모든 컨텐츠의 제목을 동일하게 선언한 경우 애매한 사례동일하지는 않지만 이 페이지가 어디인지 모르는 경우치킨 Recipe맥주 Recipe곱창전골 Recipe 좋은 사례적절하게 컨텐츠를 설명하는 내용을 사용하면서도, 사이트를 잘 설명하고 있는 경우치킨 Recipe - 조은의 Recipe맥주 Recipe - 조은의 Recipe곱창전골 Recipe - 조은의 Recipe 2. 올바른 description 사용각 컨텐츠를 짧게 설명하는 description을 잘 사용하여,Google 검색결과에 더 잘 노출되도록 하자나쁜 사례선언을 하지 않은 경우: 페이지에서 불러온 컨텐츠를 적당히 노출시킴 전화번호, 이메일 등으로 나올 수도 있음 사람들 방문 안함  3. 올바른 HTML 사용상황에 맞는 적절한 HTML 태그를 사용좋은 사례&amp;lt;a href=&quot;page&amp;gt;페이지이동&amp;lt;/a&amp;gt; 나쁜 사례&amp;lt;button onClick=&quot;move(&#39;page&#39;)&quot;&amp;gt;페이지 이동&amp;lt;/button&amp;gt;&amp;lt;div onClick=&quot;move(&#39;page&#39;)&quot;&amp;gt;페이지 이동&amp;lt;/div&amp;gt; 이게 왜 나쁘냐!! 구글봇은 렌더링 한 후에 뭘 하나? &amp;lt;a&amp;gt; 태그를 싹 다 찾음 그 페이지의 모든 컨텐츠를 크롤링 하기 위함. 루트 페이지만 크롤링할 순 없으니까 &amp;lt;a&amp;gt; 태그를 트리처럼 쭉~ 찾음 (엄청 빠르게 동작함) &amp;lt;a&amp;gt; 태그만 잘 선언해도 랭킹 좋아질거임 나쁜 사례의 &amp;lt;button&amp;gt;, &amp;lt;div&amp;gt; 는 긁어오지 않음 &amp;lt;div onClick= ~ &amp;gt; 를 다 케어하기에는 GoogleBot의 리소스 비용이 크기 때문에 안가져감  4. 제목좋은 사례&amp;lt;h1&amp;gt;제목 1&amp;lt;/h1&amp;gt;나쁜 사례&amp;lt;div class=”h1”&amp;gt;제목 1&amp;lt;/div&amp;gt;구글봇이 h1~h6까지 보면서 아웃라인을 돌아봄얘가 제목이고 컨텐츠는 여기고 크롤링은 어떻게 가져갈지에 대한 아웃라인을 그리고 시작함아웃라인 잘 해놓은 것이 상위노출에 유리함그래서 헤딩요소를 잘 검색하는것 만으로도 구글검색에 도움이 됨 5. 반응형 웹 디자인 모바일을 지원하는 페이지를 우선적으로 노출시킴 모바일과 데스크탑 검색결과가 다름 순위가 다른건 아닌데 UI가 많이 다름 모바일과 데스크탑을 동시에 지원하면 당연히 더 상위로 노출됨 반응형 웹디자인으로 만드는것이 굉장히 중요함 모바일 / pc 따로 만든다면 모바일을 우선으로 검색됨 m.blog.naver blog.naver.com 은 노출이 안됨 모바일 지원하는 것을 GoogleBot은 어떻게 알까? 레이아웃을 봤을때 특정 viewport를 넘어가면 모바일을 지원하지 않는다고 판단 viewport 내에서 컨텐츠가 다 잘 있는지를 보고 판단함  structured DataGoogleBot이 봤을 때 방문한 페이지가 올바른 마크업인지는 알겠어.그런데 데이터가 무엇을 의미하는지를 알 수 있을까?어떤 정보를 나타내는지는 알 수 없음&amp;lt;div itemscope itemtype=”http://schema.org/Recipe”&amp;gt;=&amp;gt; 레시피구나! 라고 인식함 이게 왜 중요하냐? 레시피가 최상단에 뜨게 됨 본인의 검색결과가 2~3위까지는 쉽지만, 1위로 노출되는 것은 정말 어려움 구글에 치킨레시피 치면 만개의레시피 나옴 집에서 하니까 안나오네… Google Search가 지원하는 범위product 같은 경우: 쇼핑앱을 만들때 product를 설정하면 상위에 product라고 노출되는걸 확인할 수 있을 거임 Lighthouse이걸 언제 다 하냐?크롬에 기본적으로 설치되어있는 웹페이지 종합 검사 도구가 있음(터미널에서도 사용할 수 있음. 깃허브에 pr날릴 때마다 적용도 가능)어떤 항목을 결정할지 선택할 수 있음 퍼포먼스 pwa best practice accessibility(?) SEO트위터는 점수 높음. 네이버는 낮음web.dev 에 들어가보면 각각의 항목들이 어떤 코드를 보고 여러분들의 사이트를 체크할 수 있는지 알 수 있음 영어임 (번역기 돌리세여) 그 외에도..속도가 빨라야 함 (1초 이내로 렌더링) - 지표가 애매하긴 함모바일을 지원해야 함- 모바일 지원하지 않으면 검색 결과에서 순위 계속 내려감. 아애 검색 안되는 경우도 있음 (페이지를 엄청 뒤로하면 뜰수도..)마지막으로..다른건 까먹어도 SPA가 구글 검색이 안된다는 오해를 풀어가셨으면 좋겠음 나무위키 검색 최적화 잘 되어있는 편임 &amp;lt;a&amp;gt; 태그 잘 걸려있음 &amp;lt;h1~6&amp;gt; 태그 잘 쓰고 있음 robots.txt도 잘 되어 있음 컨텐츠 자체도 p태그 h1 잘 사용하고 있음 컨텐츠와는 상관없이 검색도 잘 되고 베스트 프랙티스로 되어있음ㅋㅋ 뉴욕타임즈 베스트 프랙티스 만들 때 도움이 될 것임 " }, { "title": "파이썬 문법 끄적끄적", "url": "/2019/07/09/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AC%B8%EB%B2%95-%EB%81%84%EC%A0%81%EB%81%84%EC%A0%81/", "categories": "Python", "tags": "", "date": "2019-07-09 00:00:00 +0000", "snippet": "파이썬Strings = &quot;Hello World!&quot;s = s.split(&quot; &quot;) # [&quot;Hello&quot;, &quot;World!&quot;]s = s[1].replace(&quot;!&quot;,&quot;&quot;) # &quot;World&quot;s = s.startswith(&quot;W&quot;) # TrueListlist = []list = [1,2,3]list.append(4) Tuplet = (1,2,3) # Immutable Dictionarycustomer = {}customer[&#39;name&#39;] = &#39;junoh&#39;number_dictionary = { 1: [1, 2, 3], 2: [4, 5, 6], 3: [7], 4: [8, 9, 10, 11], 5: [12, 13, 14, 15]}number_count = {}for index, numbers in number_dictionary.items(): number_count[index] = len(numbers)# {1: 3, 2: 3, 3: 1, 4: 4, 5: 4}for index, _ in number_dictionary.items(): print(index)for index in number_dictionary.keys(): print(index)for numbers in number_dictionary.values(): print(numbers) SetmySet = set([1,2,3,1,2,3]) #{1,2,3}copied_set = mySet.copy() #value copycopied_set.add(7) #{1,2,3,7}new_numbers = [1, 2, 3, 4, 5]copied_set.update(new_numbers) #{1,2,3,4,5,7} for# 방법 1durations = []for talk in talks durations.append(talk[&#39;duration&#39;])# 방법 2durations = [talk[&#39;duration&#39;] for talk in talks]printprint(&quot;{}세 : {}&quot;.format(age, result)) sortcorpus.sort(key=itemgetter(1), reverse=True)[:2]sorted(corpus, key = itemgetter(1), reverse=True)[:2]sorted(corpus, key = lambda x:x[1], reverse=True)[:2]  map (lambda)top_tags = map(lambda x: x[0], top_tag_and_views) filter (lambda)long_books = filter(lambda row: int(row[3] &amp;gt; 250), reader) First Class Functiondef getFirst(a): return a[0] def dummyFunc(a): return getFirst(a) result = dummyFunc([1,2,3])print(result) # 1" }, { "title": "Java 퀵소트 구현", "url": "/2019/06/25/Java-%ED%80%B5%EC%86%8C%ED%8A%B8-%EA%B5%AC%ED%98%84/", "categories": "Algorithm", "tags": "", "date": "2019-06-25 00:00:00 +0000", "snippet": " QuckSort Main Tip 1. ArrayIndexOutOfBoundsException 2. 무한루프 3. nextPivotB형 준비하려면 구현을 해야하는데 소팅 알고리즘 하나 구현해봤다.퀵소트 많이들 쓰는 것 같아서 구현해봤다. 엄청 오래걸렸음. 퀵소트 하니까 피봇은 생각났는데 구현 방법을 다 까먹었다.결국 유튜브에 검색해서 동작원리 좀 봤다. 데이터가 오름차순, 내림차순 정렬일 경우 시간복잡도는 N^2인 소팅방법이다.pivot은 아무거나 해도 되는데 제일 왼쪽에 두고 구현하는데 한참 걸렸다. 메모리 엄청 터지고.. 어쨌든 완성시키긴 했다.(190721 수정. 가독성을 위해 수정)QuckSortclass QuickSort { public static void sort(int[] arr) { sort(arr, 0, arr.length - 1); } private static void sort(int[] arr, final int start, final int end) { if (start &amp;gt;= end) { return; } final int pivot = start; final int pivotData = arr[pivot]; int left = start + 1; int right = end; while (left &amp;lt; right) { while (arr[left] &amp;lt;= pivotData &amp;amp;&amp;amp; left &amp;lt; right) left++; while (arr[right] &amp;gt;= pivotData &amp;amp;&amp;amp; left &amp;lt; right) right--; swap(arr, left, right); } int nextPivot = left; if (pivotData &amp;lt; arr[nextPivot]) { nextPivot -= 1; } swap(arr, pivot, nextPivot); sort(arr, start, nextPivot - 1); sort(arr, nextPivot + 1, end); } private static void swap(int[] arr, int idx1, int idx2) { int temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp; }}  Mainpublic class Main { public static void main(String[] args) { final int SIZE = 15; final int MAX_VALUE = 10; int[] arr = new int[SIZE]; for (int i = 0; i &amp;lt; SIZE; i++) { arr[i] = (int) (Math.random() * MAX_VALUE); } System.out.println(Arrays.toString(arr)); // [0, 9, 5, 0, 9, 3, 2, 8, 4, 4, 8, 2, 1, 5, 5] QuickSort.sort(arr); System.out.println(Arrays.toString(arr)); // [0, 0, 1, 2, 2, 3, 4, 4, 5, 5, 5, 8, 8, 9, 9] }}  Tip1. ArrayIndexOutOfBoundsExceptionwhile (left &amp;lt; right) { while (arr[left] &amp;lt;= pivotData) left++; // &amp;amp;&amp;amp; left &amp;lt; right 빠짐 while (arr[right] &amp;gt;= pivotData) right--; // &amp;amp;&amp;amp; left &amp;lt; right 빠짐 swap(arr, left, right);}위의 코드는 ArrayIndexOutOfBoundsException 이 발생한다. arr =&amp;gt; [1,2,3,4,5] 두 번째 while문은 left를 계속 증가시킴 left = 5 일 때에도 두번째 while문을 돌기 때문에 arr[left]로 터짐  2. 무한루프while (left &amp;lt; right) { while (arr[left] &amp;lt; pivotData &amp;amp;&amp;amp; left &amp;lt; right) left++; // 등호가 빠짐 while (arr[right] &amp;gt; pivotData &amp;amp;&amp;amp; left &amp;lt; right) right--; // 등호가 빠짐 swap(arr, left, right);}두, 세번째 while문의 조건에 등호가 생략되어 있을 경우, 무한루프에 빠진다. arr =&amp;gt; [1, 1, 2, 3, 1] pivot의 값(arr[0]) =&amp;gt; 1 left의 값(arr[1]) =&amp;gt; 1 right의 값(arr[4]) =&amp;gt; 1 left는 ++되지 않으며, right는 –되지 않음 무한루프 따라서 두 while 문 중 적어도 하나에는 등호를 붙여야 하며, 둘 다 붙여도 상관없다. 3. nextPivotint nextPivot = left;if (pivotData &amp;lt; arr[nextPivot]) { nextPivot -= 1;}첫번째 while문을 탈출할 때에는 left == right 이다. 그 이후 nextPivot에 left를 넣어주었다. arr[nextPivot] 은 arr[pivot] 보다 작을 수도 있고 클 수도 있음 작다면, nextPivot 을 그대로 쓰면 됨 크다면, nextPivot 을 1 감소시켜야 함 만약 그대로 쓰면 pivot의 왼쪽에 arr[pivot] 보다 큰 값이 들어가버림 (pivot의 왼쪽의 값들은 pivot의 값보다 작아야 함) (pivot의 오른쪽의 값들은 pivot의 값보다 커야 함) arr[nextPivot-1] 은 arr[pivot] 보다 항상 작거나 같음 " }, { "title": "오랫만에 DFS를 풀 때 마다 겪는 흔한 실수들", "url": "/2019/06/23/%EC%98%A4%EB%9E%AB%EB%A7%8C%EC%97%90-DFS%EB%A5%BC-%ED%92%80-%EB%95%8C-%EB%A7%88%EB%8B%A4-%EA%B2%AA%EB%8A%94-%ED%9D%94%ED%95%9C-%EC%8B%A4%EC%88%98%EB%93%A4/", "categories": "Algorithm", "tags": "", "date": "2019-06-23 00:00:00 +0000", "snippet": " 1. X, Y좌표 2. 아스키코드 3. tc 초기화DFS 문제를 오랫만에 풀면 자잘한 실수들을 하게된다. 그 시간이 아까워서 포스팅 해두려고 한다.1. X, Y좌표int[][] map = new int [size][size];for (int y = 0; int y &amp;lt; size; y++) { for (int x = 0; int x &amp;lt; size; x++) { int[][] map = new int[y][x]; }} int[][] map = new int[y][x]; new int[x][y] 로 자주 실수함. (new int[j][i] 도 마찬가지)  2. 아스키코드map 정보를 입력받을 때 한 열을 1 2 3 1 5가 아닌 12315 따위로 받을 경우for (int y = 0; y &amp;lt; size; y++) { String row = br.readLine(); for (int x = 0; x &amp;lt; size; x++) { // map[y][x] = row.charAt(x); map[y][x] = row.charAt(x) - 48; // good }} int형인 map에 1을 저장할 경우 1이 아닌 49로 저장됨.int one = &#39;1&#39;;System.out.println(one); // 49아스키코드의 49가 숫자 1이기 때문. 그래서 48을 빼줘야 한다.12315를 배열로 받는 다른 방법도 있을 것 같은데 찾아보지 않았다. 3. tc 초기화public class Solution { final static int SIZE = 5; static int[][] map = new int[SIZE][SIZE]; static int visited = new boolean[SIZE][SIZE]; static int result = 0; public static void main(String[] args) throws IOException { final int TC = 10; for (int tc = 1; tc &amp;lt;= TC; tc++) { //... } System.out.println(result); }}전역으로 map, visited, result를 선언과 동시에 초기화를 했다.문제는 tc 한번 돌고나면 다음 tc를 수행할 때, 이전에 사용했던 데이터들(map, visited, result)이 초기화 되지 않는다. visited와 result는 이전의 tc에 영향을 받는다는 것.따라서 tc가 시작할 때 마다 아래처럼 초기화를 해주어야 한다.public class Solution { final static int SIZE = 5; static int[][] map; static int visited; static int result; public static void main(String[] args) throws IOException { final int TC = 10; for (int tc = 1; tc &amp;lt;= TC; tc++) { map = new int[SIZE][SIZE]; visited = new boolean[SIZE][SIZE]; result = 0; //... } System.out.println(result); }}" }, { "title": "자바 문자열 equals 구현", "url": "/2019/06/18/%EC%9E%90%EB%B0%94-%EB%AC%B8%EC%9E%90%EC%97%B4-equals-%EA%B5%AC%ED%98%84/", "categories": "Java", "tags": "", "date": "2019-06-18 00:00:00 +0000", "snippet": " equals()equals() @Test public void equals_구현_테스트() { String a = &quot;asdasd&quot;; String b = &quot;asdasd&quot;; assertThat(equals(a, b)).isTrue(); } private boolean equals(String a, String b) { char[] caa = a.toCharArray(); char[] cab = b.toCharArray(); if (caa.length != cab.length) { return false; } else { byte ret = 0; for (int i = 0; i &amp;lt; caa.length; ++i) { ret = (byte) (ret | caa[i] ^ cab[i]); } return ret == 0; } }passwordEncoder 보다가 equals 괜찮아보여서 긁어옴.나중에 SW역량 B형 준비할 때 써먹어야쥐" }, { "title": "JPA LinkedHashSet 정렬", "url": "/2019/06/17/JPA-LinkedHashSet%EC%A0%95%EB%A0%AC/", "categories": "JPA", "tags": "TODO", "date": "2019-06-17 00:00:00 +0000", "snippet": " Collections 종류 해결책 1. List 2. Set (@OrderBy) Collections 종류 List 순서 보장, 중복 가능 Set 순서 안보장, 중복 불가능 @Entitypublic class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;parent&quot;) Set&amp;lt;Comment&amp;gt; child = LinkedHashSet&amp;lt;&amp;gt;(); @ManyToOne(fetch = FetchType.LAZY) private Comment parent; // ... QueryDsl QComment c = QComment.Comment; QComment child = new QComment(&quot;child&quot;); query.selectFrom(c) .leftJoin(c.child, child).fetchJoin() .where(c.post.eq(post)) .where(c.parent.isNull()) .orderBy(c.id.asc(), child.id.asc()) .fetch() .stream().distinct().collect(Collectors.toList());댓글에 대한 대댓글들이 순서대로 출력될 줄 알았으나, 순서 보장 안됨.LinkedHashSet 사용하면 순서 보장될 줄 알았는데 호출할 때마다 순서가 변함. 랜덤으로 긁는 것 같음. 그런데, H2 Console에 찍어보면 순서대로 나오긴 함.왜 객체로 담을 때 순서를 보장 안해주는거지? LinkedHashSet이잖아.. 해결책1. ListComment.java 일부 @OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;parent&quot;) List&amp;lt;Comment&amp;gt; child = ArrayList&amp;lt;&amp;gt;();리스트로 받으면 마음편함. 순서 보장됨.2. Set (@OrderBy)Comment.java 일부 @OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;parent&quot;) @OrderBy(&quot;id asc&quot;) Set&amp;lt;Comment&amp;gt; child = LinkedHashSet&amp;lt;&amp;gt;();위처럼 @OrderBy 를 추가해주니 순서가 보장 됬음. 이에 대한 해답은 2가지로 나왔음. 사실 근본적인 문제를 해결하지 못한 느낌임.LinkedHashSet으로 구현했으면 로우를 넣을 때마다 순서대로 넣어야하는게 아닌가?확실한건 쿼리자체에서는 정렬되서 나옴. 객체에 넣을때 뭔가 잘못된것 같기도..TODO :: 나중에 알면 수정" }, { "title": "2019년 24주차 회고", "url": "/2019/06/16/2019%EB%85%84-24%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2019-06-16 00:00:00 +0000", "snippet": "삽밥최근 커뮤니티 REST API를 개발하면서 대부분의 시간을 보내고 있다. 여러 고민을 하면서 DB 모델링, 인덱스 실행계획에 대해서 너무 무지함을 느꼈다.대학교에서 데이터베이스 동아리 활동을 했지만, 학업보다는 술을 익혔으니.. 어려울 만도 하다. 내가 얼마나 삽밥인가를 깨달으면서 버킷리스트가 하나 생겼다.SQLP 취득하기3년 전, SQLD를 취득했었다. 그 당시 SQLD 공부를 엄청 재밌게 했었던 것 같다. 쿼리 짜는 것들이 하나하나 다 재밌었다.너무 재밌어서 오라클 성능 고도화 원리와 해법 책까지 빌렸던 것 같다. 물론, 거의 읽지 않고 반납했던 것 같다ㅋㅋㅋ3년이 지난 지금, SQL에 대한 실력은 그 때보다 없다. 이유를 생각해보면 첫번째로 쓸 일이 없었고 (3년간 쓸일이 없었다는게 참 부끄럽다) 두번째로 SQL에 대해 관심을 크게 두지 않았다. 얼또얼또를 또 안했다. 최근 2주동안 한번? 했던 것 같다. 이유를 생각해보면 매번 늦게 자다가 피곤해서 못일어나는 것 같다.매번 꾸준히 일어나서 공부하는 시간을 확보하는 분들이 너무 멋있다. 4차산업흔히 4차 산업의 핵심 기술이라고 말하는 것들 중에 하나 정도는 익혀서 취미생활로 사용해 보고 싶어, 어떤게 좋을지 생각해 보았다.스마트 홈실생활에 정말 유용할 것 같다. 최근 유튜브의 긱블 채널을 보면서 재밌을 것 같다고 느꼈다. 3D프린터와 아두이노를 이용하면 쌈박하고 재밌는 것들을 만들어 수 있는 것들이 많을 것 같다. 취미 생활로 괜찮아보였다. 스마트한 홈을 만들 수 있을 것 같다.NLP자연어 처리도 재밌을 것 같다. 작년 여름 CS231n 강의를 들으면서 CNN 을 익혔었는데.. 자연어로 연구하는 친구가 있어서 훌륭한 선생님은 있는데..ㅋㅋㅋㅋ그 이외의 AR, VR, 블록체인 등은 별 흥미가 느껴지지 않았다." }, { "title": "실행계획 - postgresql", "url": "/2019/06/15/%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-postgresql/", "categories": "SQL", "tags": "", "date": "2019-06-15 00:00:00 +0000", "snippet": " SELECT 구문 앞에 EXPLAIN 붙이면 실행계획을 볼 수 있음.  EXPLAIN SELECT * FROM USER;  이용 가능한 게시물의 게시글, 글쓴이, 카테고리를 뽑아오기EXPLAIN SELECT * FROM board_data INNER JOIN users ON board_data.user_id = users.id INNER JOIN board ON board_data.board_id = board.id WHERE board_data.board_data_status = &#39;AVAILABLE&#39; ORDER BY board_data.id DESC; (실행 계획)Sort (cost=27.82..27.82 rows=1 width=4814) // 1) Sort Key: board_data.id DESC -&amp;gt; Nested Loop (cost=0.28..27.81 rows=1 width=4814) // 2) -&amp;gt; Nested Loop (cost=0.14..19.42 rows=1 width=3766) // 3) -&amp;gt; Seq Scan on board_data (cost=0.00..10.75 rows=1 width=1145) // 4) Filter: ((board_data_status)::text = &#39;AVAILABLE&#39;::text) -&amp;gt; Index Scan using users_pkey on users (cost=0.14..8.15 rows=1 width=2621) // 5) Index Cond: (id = board_data.user_id) -&amp;gt; Index Scan using board_pkey on board (cost=0.14..8.16 rows=1 width=1040) // 6) Index Cond: (id = board_data.board_id)실행 순서 : 4 - 5 - 3 - 6 - 2 - 1 (실행 순서 헷갈리면 jojoldu님 블로그) Seq Scan on board_data (cost=0.00..10.75 rows=1 width=1145) // 4) WHERE 절 수행 board_data_status 가 ‘AVAILABLE’ 인 것을 찾는다 ( Seq Scan ) Index Scan using users_pkey on users (cost=0.14..8.15 rows=1 width=2621) // 5) (Index Scan) 조인 할 대상을 인덱스에 태워서 스캔 Nested Loop (cost=0.14..19.42 rows=1 width=3766) // 3) 실질적으로 조인 수행 실행속도 :: 선행 테이블(board_data) 사이즈 * 후행 테이블(users) 접근 횟수 Index Scan using board_pkey on board (cost=0.14..8.16 rows=1 width=1040) // 6) (Index Scan) 조인 할 대상을 인덱스에 태워서 스캔 Nested Loop (cost=0.28..27.81 rows=1 width=4814) // 2) 실질적으로 조인 수행 실행속도 :: 선행 테이블(board_data) 사이즈 * 후행 테이블(board) 접근 횟수 Sort (cost=27.82..27.82 rows=1 width=4814) // 1) board_data.id 역순으로 정렬  " }, { "title": "JPA04. Fetch", "url": "/2019/06/10/JPA04.-Fetch/", "categories": "JPA", "tags": "", "date": "2019-06-10 00:00:00 +0000", "snippet": "@OneToMany의 Default Fetch 전략 : Lazy@ManyToOne의 Default Fetch 전략 : Eager  @OneToMany@Getter @Setter@Entitypublic class Account { @Id @GeneratedValue private Long id; @Column(nullable=false, unique=true) private String username; private String password; @OneToMany(mappedBy = &quot;owner&quot;, fetch = FetchType.EAGER) //DEFAULT: LAZY private Set&amp;lt;Study&amp;gt; studies = new HashSet&amp;lt;&amp;gt;();}Account result = entityManager.find(Account.class, 1L);위 코드가 실행 시 id가 1인 Account를 가져오게 되는데, Fetch 전략에 따라 SQL 쿼리가 달라진다. FetchType.LAZY// Account 테이블에서 Account 가져옴.select account0_.id as id1_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ from account account0_ where account0_.id=?// 위의 계정에 맞는 STUDY 가져오는 쿼리select studies0_.owner_id as owner_id3_1_0_, studies0_.id as id1_1_0_, studies0_.id as id1_1_1_, studies0_.name as name2_1_1_, studies0_.owner_id as owner_id3_1_1_ from study studies0_ where studies0_.owner_id=?  FetchType.EAGER// 조인해서 한번에 가져옴select account0_.id as id1_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, studies1_.owner_id as owner_id3_1_1_, studies1_.id as id1_1_1_, studies1_.id as id1_1_2_, studies1_.name as name2_1_2_, studies1_.owner_id as owner_id3_1_2_ from account account0_ left outer join study studies1_ on account0_.id=studies1_.owner_id where account0_.id=?" }, { "title": "JPA03. 엔터티 생명주기", "url": "/2019/06/09/JPA03.-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/", "categories": "JPA", "tags": "", "date": "2019-06-09 00:00:00 +0000", "snippet": "Transient (비영속 상태)jpa랑 관련없음.Account account = new Account();account.setUsesrname(&quot;keesun2&quot;);account.setPassword(&quot;jpa&quot;); Persistent (영속 상태)영속성 컨텍스트에 저장된 상태Session session = entityManager.unwrap(Session.class);session.save(account);Account keesun = session.load(Account.class, account.getId()); // SELECT 쿼리가 발생하지 않음. 캐시된 것이 있기 때문에 DB로 요청안해도됨.keesun.setUsername(&quot;whiteship&quot;); // dirtyChecking, write봐인딩?일반 SQL로 했으면 위의 작업은 다음고 ㅏ같이 이루어짐. INSERT SELECT UPDATE하지만 실제로는 2가지만 이루어짐. INSERT UPDATEINSERT INTO account (password, username, id) VALUES (?, ?, ?)UPDATE accountSET password=?, username=?WHERE id=? =&amp;gt; SELECT 쿼리가 일어나지 않았음. Persistent 상태에 있는 객체의 장점임. Session session = entityManager.unwrap(Session.class);session.save(account);Account keesun = session.load(Account.class, account.getId()); // SELECT 쿼리가 발생하지 않음. 캐시된 것이 있기 때문에 DB로 요청안해도됨.keesun.setUsername(&quot;whiteship&quot;); // dirtyChecking, write behindkeesun.setUsername(&quot;keesun2&quot;); INSERTINSERT INTO account (password, username, id) VALUES (?, ?, ?)keesun2 이름이 같으므로 update 쿼리를 하지 않음.dirtyChecking : 객체의 변경사항을 계속 감지하는 것write behind : 객체 상태를 DB에 최대한 늦게 반영하는 것Removed (삭제)실제 커밋이 일어날 때 삭제가 일어남.Detatch 준영속 상태   1차캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 (write-behind) 변경 감지 (Dirty Checking) 지연 로딩(Lazy Loading)1차캐시영속성콘텍스트가 new에서 생성되거 없어질 때까지 잠깐 존재하는녀석Member member = new Member();member.setId(&quot;member1&quot;);member.setUsername(&quot;회원1&quot;);// 1차캐시에 저장됨em.persist(object);1차 캐시|@id |Entity||”member1”| member1|// DB에 요청하기 전에 1차 캐시에서 조회Member findMember = em.find(Member.class, &quot;member1&quot;);트래픽 100명이 온다 -&amp;gt; 영속 컨텍스트 100개 생기고, 캐시 100개 생김. 나가면 다 없어짐. ㅇㅋ? 서로 공유하지 않는 캐시. 트랜잭션 시작하고 끝날때까지만 유짛는 굉장이 짧은 캐시.Member findMember2 = em.find(Member.class, &quot;member2&quot;);1차 캐시|@id |Entity||”member1”| member1||”member2”| member2|와 영한씨 개꿀인데 강의…동일성 보장Member a = em.find(Member.class, “member1”);Member b = em.find(Member.class, “member1”);System.out.println(a == b); // true반복가능한 읽기 등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공 (1차 캐시)쓰기 지연commit 하면 sql보냄.em.// 쓰기 지연 SQL 저장소에 있는 쿼리 보내기 (1차 캐시 지우는 것이 아님.)em.flush();// flush + committx.commit(); Member a = em.find(Member.class, &quot;member1&quot;);// Updatea.setUsername(&quot;Hi&quot;);a.setAge(12);jpa는 트랜잭션 commit 되는 시점에 1차캐시 넣을 때 스냅샷…을 떠놓음flush 하는 시점에 다 비교함. 바뀐놈 있으면 업데이트 쿼리 만들어서 db에 보냄. 이렇게 값만 바꿔도사실 1차캐시에 저장할 때 스냅샷을 뜸.1차 캐시|@id |Entity|스냅샷||”member1”| member1|member1 스냅샷||”member2”| member2|member1 스냅샷|Entity랑 스냅샷이 다른게 있으면 Update쿼리를 만듬.변경감지 (더티 체킹)영속성 컨텍스트에 관리되는 애들은 뭐가 변경되있는지 다 알아요.나이 하나만 바꿔도 다 알아요그래서 커밋하거나 플러쉬할 때 업데이트 쿼리를 DB에 날려버립니다.왜 이렇게 동작할까요&amp;gt;? em.update를 만들지!!사상때무에 그럼. 우리가 자바 컬렋List&amp;lt;User&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();users.add(user1);users.add(user2);users.add(user3);user2.setAge(&quot;10&quot;);컬렉션에 있는 내용이 변경되면 알아서 컬렉션에 반영되잖아. 자바의 이런 패러다임을 따른거지..마치 자바 컬렉션에 있는 객체 다루듯이!!!! 갸꿀플러시플러시 일어나면 스냅샷 다 비교하고.. UPDATE쿼리 만들고 DB에 다보내버려~FLUSH발생할때 등록 수정 삭제 쿼리 일괄로 나감. (한번에 네트워크 태운다는 말이 아님. 설정으로 한번에 네트워크 태울 수도 있음.)플러쉬 하는 방법 em.flush() 트랜잭션 커밋 tx.commit() JPQL 쿼리 실행JPQL 쿼리 실행할 때 flush가 이루어져야 하는 이유select * from member 하기 전에 member를 persist한 것들이 플러쉬가 안일어졌다면.. 못갖고오깄쥬마이바티스타 JDBCTemplate 쓸 경우에는 수동으로 flush() 해줘야 해. 안그럼..ㅠㅠㅠ플러시는 영속성 컨텍스트를 비우지 않음!!! 변경내용을 DB와 동기화 하는 작업트랜잭션이라는 작업 단위가 중요. 커밋 직전에만 동기화 하면 됨!!! 그전에는 어떻게든 버퍼에서 유지하다가… 준영속 상태영속에 있던 엔터티가 더이상 영속성 컨텍스트에서 분리(detached)준영속 만드는 법 em.detach(entity); em.clear(); 1차캐시 다 삭제. (플러시 안일어남.) em.close();스프링 쓸 때 준영속 많이 씀.트랜잭션이 유지되는동안 이게 유지되는데.. 컨트롤러로 나가는 순간 영속성컨텍스트 유지가 안됨. 그럼 지연로딩 못쓰게 됨!!!주의 !얘가 LAZY잖아요. (Member에서 Team 관계매핑할때 Lazy)LazyInitiallizationException실전에서 개발하다보면 위에 오류 엄청 만날것임.지연로딩 하려면 영속성컨텍스트에서 관리가 되어야 함.지연로딩 쓸거면 em을 닫으면 안됨. 그래서 음… 그러면 한 트랜잭션 내에서 레이지된거를 다 처리해줘야하는건가.스프링에서는 트랜잭션 끝나고 컨트롤러에서 레이지로딩 하려고 할 때 저 에러 만날 것임. 영속성컨텍스트가 아니구나. 라고 이해를 하시면 됨. 준영속상태인 것을 레이지로딩 했구나 라고 생각하면 됨. 필요하면 준영속 들어가기 전에 미리 터치를 해놓거나(로딩을해놓거나) 하면 됩니다" }, { "title": "JPA02. 관계", "url": "/2019/06/09/JPA02.-%EA%B4%80%EA%B3%84/", "categories": "JPA", "tags": "", "date": "2019-06-09 00:00:00 +0000", "snippet": "1:N 관계@ManyToOne 단방향@Getter @Setter@Entitypublic class Account { @Id @GeneratedValue private Long id; @Column(nullable=false, unique=true) private String username; private String password;}@Getter @Setter@Entitypublic class Study { @Id @GeneratedValue private Long id; private String name; @ManyToOne // &amp;lt;- FK @JoinColumn(name=&quot;owner_id&quot;) private Account owner;}Study에서는 Account를 참조할 수 있지만, Account에서는 Study를 알 수 없음.@ManyToOne : Study에 Account 관계를 맺어줬음. 단방향임.@JoinColumn : 생략 가능함. ‘필드명_참조하는필드명’ 으로 생성됨. 위의 경우 생략하면 컬럼 이름은 owner_id 깨알팁) @ManyToOne와 @OneToMany가 헷갈린다면..끝쪽을 보세요! 끝이 One으로 끝나면 단일, Many로 끝나면 컬렉션인 레퍼런스를 쓴다고 생각!현재 Reference가 Collection이 아니라 Account니까 One으로 끝나는거다!결과CREATE TABLE account ( id int8 not null, password varchar(255), username varchar(255) not null, primary key (id))CREATE TABLE study ( id int8 not null, name varchar(255), owner_id int8, primary key (id))ALTER TABLE IF EXISTS account ADD CNSTRAINT UK_gex1lmaqpg0ir5g1f5eftyaa1 UNIQUE (username)ALTER TABLE IF EXISTS study ADD CONSTRAINT FK210g5r7wftvloq2ics531e6e4 FOREIGN KEY (owner_id) REFERENCES accountStudy는 onwer의 PK인 ower_id를 FK로 가지고 있음.  @OneToMany 단방향@Getter @Setter@Entitypublic class Account { @Id @GeneratedValue private Long id; @Column(nullable=false, unique=true) private String username; private String password; @OneToMany private Set&amp;lt;Study&amp;gt; studies;}@Getter @Setter@Entitypublic class Study { @Id @GeneratedValue private Long id; private String name;}@OneToMany : 이번에는 Account에서 Study 관계를 맺어줬음. 단방향임.조인테이블이 만들어짐.결과create table account ( id int8 not null, password varchar(255), username varchar(255) not null, primary key (id))create table account_studies ( account_id int8 not null, studies_id int8 not null, primary key (account_id, studies_id))create table study ( id int8 not null, name varchar(255), primary key (id))alter table if exists account add constraint UK_gex1lmaqpg0ir5g1f5eftyaa1 unique (username)alter table if exists account_studies add constraint UK_tevcop76y9etp9vx5vce7gns6 unique (studies_id)alter table if exists account_studies add constraint FKem9ae62rreqwn7sv2efcphluk foreign key (studies_id) references studyalter table if exists account_studies add constraint FK4h3r1x3qcsugrps8vc6dgnn25 foreign key (account_id) references account이건 바꿀 수있음. 위는 빙산의 일각에 불과public class Account { // ... // 어떤 한 유저에 스터디를 추가할 때, 해당 스터디에서의 정보도 함께 변동되어야 함 public void addStudy(Study study) { this.getStudies().add(study); study.setOwner(this); } public void removeStudy(Study study) { this.getStudies().remove(study); study.setOwner(null); }}  @OneToMany, @ManyToOne 양방향RDB에는 FK 한개로 양방향 관계를 가짐.그런데 객체에서의 양방향은 각 클래스에서 참조를 하게 됨.이 때 생각해야할 것이 있음. 한쪽에 업데이트를 하면 반대쪽도 업데이트 되야 한다는 것임.=&amp;gt; 그럼 둘중에 한군데를 주인으로 만들고, 주인이 아닌 쪽은 읽기만 가능하도록 하자! 주인이 아닌 쪽은 읽기만 가능. -&amp;gt; DB에 영향을 주지 않음. 양방향은 단순히 조회를 편하게 하기 위한 부가기능!? 나중에 DDL보면 @ManyToOne 단방향이랑 같을거임.누구를 주인으로 할까? FK 가지고 있는 쪽을 관계의 주인으로 하자. 이렇게 안하면 어떤 테이블 수정헀는데 다른테이블에 쿼리가 날라가면서 멘붕에 빠질 수 있음.주인이 아닌 쪽에서는 mappedBy 설정을 해줘야 함. 안하면 양방향이 아닌, 두개의 단방향 관계가 되서 꼬여버림.mappedBy는 양방향 관계일 때 사용. 매핑된 엔터티의 필드명을 적으면됨.주인이 아닌쪽에서 추가해버리면 DB에 반영 안됨.@Entitypublic class Account { // ... @OneToMany(mappedBy = &quot;owner&quot;) private Set&amp;lt;Study&amp;gt; studies = new HashSet&amp;lt;&amp;gt;();}public class Study { // ... @ManyToOne @JoinColumn(name=&quot;owner_id&quot;) private Account owner;}결과CREATE TABLE account ( id int8 not null, password varchar(255), username varchar(255) not null, primary key (id))CREATE TABLE study ( id int8 not null, name varchar(255), owner_id int8, primary key (id))ALTER TABLE IF EXISTS account ADD CNSTRAINT UK_gex1lmaqpg0ir5g1f5eftyaa1 UNIQUE (username)ALTER TABLE IF EXISTS study ADD CONSTRAINT FK210g5r7wftvloq2ics531e6e4 FOREIGN KEY (owner_id) REFERENCES account-&amp;gt; @ManyToOne 단방향이랑 스키마가 똑같다!! 김영한님 팁! 설계할 때는 무조건 단방향으로 설계! (양방향은 좋은것이 아님. 순환참조라는게..) 개발 도중에 양방향이 필요하다고 생각할 경우 추가. (DB에 영향 안주니까 나중에 추가되도 괜찮음) 양방향은 조회하기 편하려고 부가기능이 들어간 것! 아리까리하면 JPA책 볼 것ㅋㅋ" }, { "title": "JPA01. 엔터티", "url": "/2019/06/08/JPA01.-%EC%97%94%ED%84%B0%ED%8B%B0/", "categories": "JPA", "tags": "", "date": "2019-06-08 00:00:00 +0000", "snippet": "Entity Type@Entity@Getter @Setterpublic class Account { @Id @GeneratedValue private Long id; private String username; private String password;}@Entity : DB의 Account 테이블에 매핑되는 클래스@Id : Account 테이블의 PK에 매핑 (Entity는 고유 식별자를 가짐)@GeneratedValue : Auto-Incresement 설정@Culumn : 컬럼이라고 알려줌 (생략 가능) EntityManager@Component@Transactionalpublic class JpaRunner implements ApplicationRunner { @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception { Account account = new Account(); account.setUsername(&quot;keesun&quot;); account.setPassword(&quot;jpa&quot;); // 1번 방법 entityManager.persist(account); // 2번 방법 Session session = entityManager.unwrap(Session.class); session.save(account); }} @Entity@Entity(name = &quot;myAccount&quot;)@Table(name = &quot;myAccount&quot;)public class Account {}@Entity(name = &quot;myAccount&quot;) =&amp;gt; 하이버네이트 JPA안의 객체에서 쓰는 이름. (별도로 설정하지 않으면 클래스의 이름과 동일하게 사용)@Table(name = &quot;myAccount&quot;) : DB의 테이블에 매핑되는 이름을 설정 (이 설정이 없으면 엔티티의 이름과 동일한 이름으로 설정됨.) @Id엔터티의 PK를 설정 @Idprivate Long id;@Idprivate long id;둘 중에 뭘 쓸까.long의 경우, 0이 초기화 됨. -&amp;gt; 테이블에 id가 0인 레코드를 가진 어카운트와 새로 만든 어카운트(id=0)가 구분이 안됨.Long의 경우, null로 초기화 됨. -&amp;gt; 테이블에 id가 0인 레코드를 가진 어카운트와 새로 만든 어카운트(id = null)가 구분이 됨 @GeneratedValue@Id @GeneratedValue(strategy=&quot;AUTO&quot;)private Long id;strategy SEQUENCE TABLE IDENTITY AUTH (DEFAULT. 사용하는 DB에 따라 적절한 방법 선택) @ColumnEntity의 전역필드에는 @Column이 생략되어 있음.@Column(nullable = false, unique = true)private String username; @Temporal@Temporal(TemporalType.TIMESTAMP)private Date createdJPA 2.1까지는 Date 써야함. (컨버터를 사용해서 LocalDate로 바꾸는 방법도 있긴 하지만 패스)JPA 2.2부터 Java8의 LocalDate 사용 가능 (Hibernate 5.3 이상) @Transient@Transientprivate String no;해당 필드를 테이블의 컬럼으로 매핑하지 않음.  Value Type다른 엔터티에 종속적인 타입. Entity Type vs Value Type PK가 있어야 하는가 독립적으로 존재해야 하는가 Value Type은 pk가 없고 독립적일 필요도 없는 것들이다. private Address address;Address는 Entity Type이냐 Value Type이냐??Address가 테이블로 뽑을만한 것이 맞는가? PK는 뭘로 할건데? 테이블로 뽑는건 아닌 것 같음. @Embeddable@Embeddablepublic class Address { private String street; private String city; private String state; private String zipCode;}( @Column이 생략되어 있음 ) @Entitypublic class Account { // ... @Embedded @AttributeOverrides({ @AttributeOverride( name = &quot;city&quot;, column = @Column(name = &quot;home_city&quot;)), @AttributeOverride( name = &quot;streat&quot;, column = @Column(name = &quot;home_streat&quot;)), @AttributeOverride( name = &quot;zipCode&quot;, column = @Column(name = &quot;home_zip_code&quot;)) }) private Address HomeAddress; @Embedded @AttributeOverrides({ @AttributeOverride( name = &quot;city&quot;, column = @Column(name = &quot;office_city&quot;)), @AttributeOverride( name = &quot;streat&quot;, column = @Column(name = &quot;office_streat&quot;)), @AttributeOverride( name = &quot;zipCode&quot;, column = @Column(name = &quot;office_zip_code&quot;)) }) private Address OfficeAddress;} 결과CREATE TABLE account ( id int8 not null, home_city varchar(255), home_streat varchar(255), home_zip_code varchar(255), office_city varchar(255), office_streat varchar(255), office_zip_code varchar(255), password varchar(255), username varchar(255) not null, primary key (id))CREATE TABLE study ( id int8 not null, name varchar(255), owner_id int8, primary key (id))ALTER TABLE IF EXISTS ACCOUNTADD CONSTRAINT UK_gex1lmaqpg0ir5g1f5eftyaa1 UNIQUE (username)ALTER TABLE IF EXISTS studyADD CONSTRAINT FK210g5r7wftvloq2ics531e6e4 FOREIGN KEY (owner_id) REFERENCES account" }, { "title": "currentUser", "url": "/2019/06/06/currentUser/", "categories": "Spring", "tags": "", "date": "2019-06-06 00:00:00 +0000", "snippet": " 현재 사용자 1. Authentication 객체로 받기 2. @AuthenticationPrincipal 현재 사용자스프링 시큐리티로 인증하였을 경우,현재 사용자 보기1. Authentication 객체로 받기@RestControllerpublic class TempRestController { @GetMapping(&quot;/principal&quot;) public ResponseEntity getAuthentication() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); User principal = (User) authentication.getPrincipal(); return ResponseEntity.ok(principal); }}localhost:8080/principal (without accessToken)// Response{ &quot;principal&quot;: &quot;anonymousUser&quot;} localhost:8080/principal (with accessToken)// Response{ &quot;password&quot;: null, &quot;username&quot;: &quot;user&quot;, &quot;authorities&quot;: [ { &quot;authority&quot;: &quot;ROLE_USER&quot; } ], &quot;accountNonExpired&quot;: true, &quot;accountNonLocked&quot;: true, &quot;credentialsNonExpired&quot;: true, &quot;enabled&quot;: true} 2. @AuthenticationPrincipal@RestControllerpublic class TempRestController { @GetMapping(&quot;/principal&quot;) public ResponseEntity getAuthentication(@AuthenticationPrincipal User principal) { return ResponseEntity.ok(principal); }}1번과 동일  그런데 받아오는게… 영 부실하다.로그인을 할 때 UserDetailsService의 loadUserByUsername 은 로그인 할 경우에 실행된다.@Slf4j@Service@Transactional@RequiredArgsConstructorpublic class UserService implements UserDetailsService { private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; @Override public org.springframework.security.core.userdetails.UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user = userRepository.findByUserIdAndIsDeletedFalse(s) .orElseThrow(() -&amp;gt; new UserNotFoundException(s)); return new org.springframework.security.core.userdetails.User(user.getUserId(), user.getPassword(), authority(user.getRole())); } private Collection&amp;lt;? extends GrantedAuthority&amp;gt; authority(UserRole roles) { return Collections.singleton(new SimpleGrantedAuthority(&quot;ROLE_&quot; + roles.name())); } //...로그인할 때 입력한 Id의 유저를 DB에 호출해서 해당유저의 Id, Password, 권한 정보 를 User(시큐리티 객체)에 담아서 리턴한다.User user = userRepository.findByUserIdAndIsDeletedFalse(userId)만약 비즈니스 로직 상에 Id, Password, 권한정보 이외의 추가적인 유저 정보가 필요하다면 매번 유저 정보를 가져와서 쓸 수 있다.하지만 매번 호출하는 것은 뭔가 구리다.처음 로그인 시, DB에서 호출하는 시점에서 필요한 정보들을 세션에 저장할 수는 없을까" }, { "title": "JPA00. ORM과 RDB", "url": "/2019/06/06/JPA00.-ORM%EA%B3%BC-RDB/", "categories": "JPA", "tags": "", "date": "2019-06-06 00:00:00 +0000", "snippet": "현재 팀프로젝트를 하면서 JPA를 사용하기로 했다.공부는 인프런에서 백기선님의 JPA강의를 보면서 공부하기로 했다. 6월달은 15% 할인이라 만원정도 싸게 구매했다. 이로써 백기선님의 강좌만 4개 째 듣게 되었다.블로깅의 상당수는 강좌 내용이 될 것 같다. 최근 유튜브 스트리밍 방송에서 개인 블로그에 포스팅은 얼마든지 괜찮다고 말씀해주셔서 마음 편히 정리하면서 공부하고자 한다. (몇일 뒤 인프런에도 포스팅 관련 공지가 떴다.  ORM (Object-Relation Mapping) ?ORM : 객체를 테이블로 매핑하는 기술이다? 는 ORM의 아주 일부 기능임ORM의 구현체인 jpa, hibernate의 특징들이 있음. 이 특징들을 알아야 코딩을 할 때 비효율적인 쿼리를 방지할 수 있음. Class와 Table 사이의 매핑 정보를 기술한 메타데이터를 사용하여, 객체를 테이블에 자동으로 영속화해주는 기술 전통적인 사용 방식 (JDBC)(java7 이상)try(Connection connection = DriverManager.getConnection(url, username, password)) { String sql = &quot;INSERT INTO ACCOUNT VALUES(1, &quot;keesun&quot;, &quot;pass&quot;);&quot;; try(PreparedStatement statement = connection.prepareStatement(sql)){ statement.execute();}비즈니스와 관계없는(침투적인) 코드가 많음. (자바7 이전에는 리소스 반납 처리를 해야 해서 코드가 더 길었다고.. ) Domain Model 방식Account account = new Account(&quot;keesun&quot;, &quot;pass&quot;);accountReository.save(account);JDBC와 관련된(침투적) 코드가 없어서 비즈니스에 집중할 수 있다. (유지보수성 좋다.) =&amp;gt; 자신의 코드를 숨기려 하는 비침투적인 스프링의 철학과 비슷생산성 굿. DDL도 알아서 만들어줌. CRUD도 뚝딱뚝딱!그럼 성능은? =&amp;gt; JPA에 대해서 충분한 학습 없이 사용하면 구릴 수 있음. 많은 학습이 필요함.  Java와 RDB의 패러다임 불일치를 ORM이 해결해준다!JAVA &amp;lt;–&amp;gt; RDB 는 패러다임이 서로 다른 부분이 존재함. 어떠한 차이점이 있는지 확인해보자. ORM이 어떤 일을 하는건지를 알 수 있을거임.RDB: 데이터를 어떻게 하면 잘 저장하고 정규화하고 할 수 있을까객체: 상속, 1) 밀도(Granularity)Public class User { private String address;}=&amp;gt; 이건 User 테이블에 address 필드 (VARCHAR(45)) 넣어주면 되겠구먼! Public class User { private Address address;}=&amp;gt; Address와 같은 커스텀한 타입(객체)를 RDB에서는 표현 못함. 이걸 어떻게 매핑시킬꺼냐? 2) 서브타입(Subtype)객체는 상속하기 쉽다. (다형성)테이블은 상속이 없다. (다형성 없음) 유저는 여러가지 결제 수단중에서 한가지의 결제수단를 가짐.public class User { private BillingAccount billingAccount;}BillingAccount : 사용자가 사용하는 결제수단 (인터페이스)BillingAccount의 구현체 : BankAccount.class, CreditCard.classRDB에서는 USER 테이블에서 두 결제수단 테이블의 PK를 FK로 가질 수 있을까?? 아니 없다.테이블 간에 FK는 한 테이블이 다른 테이블의 PK를 FK로 사용하는 것임. 다른 두 테이블에 있는 외래키를 설정할 수는 없음. (다른 두 테이블간의 외래키가 겹칠수도 있고..) 3) 식별성 (Identity)Java에서는 인스턴스가 같은지 확인할 때 2가지 방법이 있음. 레퍼런스의 동일성 체크 (==) 인스턴스의 동일성 체크 (.equals())자바에서 권장하는 동일성 체크는 equals이나, RDB로 변환시키기에는 equals()로 충분하지 않음.어떤 한 테이블에서 두 레코드(로우) 간의 동일성은 PK로 확인함. PK가 같냐 다르냐에 따라 레코드가 같은지 아닌지를 판단함. 하지만 Java 패러다임에는 PK 개념이 없음.엥? equals 재정의하면 pk처럼 쓸수있는거 아닌가..? 4) 연관 관계 (Association)Java에서 관계는 레퍼런스로 표현public class Study { private User owner; private Set&amp;lt;User&amp;gt; users; // ...}Study에 User를 레퍼런스로 등록함으로써 두 클래스의 관계가 생김. 이 관계에는 방향이 있다. (Study에서 User를 참조.)User에서 Study를 참조하고 싶다면 User 클래스에 Set를 추가하면 됨.RDB에서의 관계는 오로지 FK로만 표현함. Study의 FK에는 User의 PK가 있음. RDB는 단방향이 없음. 관계 맺으면 단방향임.물리적 모델링에서의 카디널리티는 무조건 1:1 / 1:N 임. N:N가 없음. 허나, 자바 패러다임은 N:N를 허용함 (ORM이 객체에서 릴레이션으로 표현할 때 N:N을 해소해줌.) 데이터 네비게이션 (Navigation)레퍼런스를 타고 원하는대로 타고 타고 가서 원하는 데이터를 갖는거.릴레이션에서는 이런 기능 없음. 원하는 데이터를 매번 조인해서 가져와야 함.ex) 어떤 한 스터디의 스터디장이 참여하는 스터디들의 스터디장 정보를 원해.// Study.class 일부getOwner().getMyStudy().stream().forEach(s -&amp;gt; s.getOwner()); 어떤 한 스터디의 데이터 받아오기 (Study 테이블 쿼리) 그 스터디의 스터디장 정보(FK)를 사용해서 유저 정보 받아오기 (USER 테이블 쿼리) 그 유저의 USER 정보를 사용해서 참여하고 있는 스터디 정보 받아오기 (스터디 이력 테이블 쿼리) 각 스터디들의 오더정보들을 쿼리 (Study 테이블 쿼리)=&amp;gt; 다수의 쿼리가 발생함. 성능 매우 안좋아져!! 한 트랜잭션 내에서 많은 조인을 하는 방법이 있지만, 이것도 문제임. 데이터 왕창 메모리에 올려놓는 것은 비효율적(DB 부하, 앱 메모리부하) 정말 그 많은 데이터를 쓰는지… 고민을 해봐야함.하이버네이트에서 lazyLoading을 사용할 때, 주의해서 사용해야 함. N+1 Problem이 있음. (이 문제는 이동욱님 블로그에도 있음. 근데 아직 이해가 안됨.ㅠ)getMyStudy() 할 때 조인하지 않고 스터디 목록만 읽어와서 스터디 목록을 화면에 표시할 때 마다 셀렉트한다면 이 때 N+1 문제가 발생=&amp;gt; 스터디 목록 처음에 읽어올 때 1번 읽음(1) + 그 다음에 스터디 목록을 순회하면서 n번의 쿼리가 발생함(N) 성능 구데기임.이를 해결하려면 애초에 스터디를 쿼리할때 조인해서 오너정보를 가져오는 방법 LazyLoading 할 때 한번에 큰 뭉텅이로 (ex. 50개씩 가져와라) 가져오는 방법 (N/50 + 1) 이러한 패러다임의 차이를 줄이고 줄여서 상용화할 수 있도록 호환되도록 노력하는게 ORM 임. 어렵고, 러닝커브가 크다는 것이 이런 패러다임의 차이 때문임.  번외ORM의 사실과 오해 - OKKY4년 전, OKKY에서 ORM과 Mapper에 대한 토론글이다. 양이 매우 방대하다. 읽다가 말았음. Alternatives to JPA쿠팡의 배성혁님이 네이버 D2에서 발표하신 강연이다. 강연의 초반 20분 정도는 JPA의 장단점, 어떻게 대해야 하는지에 대한 설명이 있어서 좋았다. 대충 끄적여보면, 자신의 프로젝트에 ORM, MyBatis 선택은 시스템 성격상 달라져야 한다.(솔루션 업체는 고객이 원하는 DB에 맞춰서 개발해야 하니까 ORM 쓰면 좋음. 서비스 업체는 DB를 깊숙한 곳까지 최적화 해야 하는데 굳이 ORM을 써야할까) 어쨌든 JPA쓸꺼면 제대로 알고 써야 하며, 러닝커브가 큼. JPA 정말 잘 알고 써야하고, JPA 쓴다고 해서 SQL를 몰라서도 안됨. (@NatualID, @DynamicInsert, @LazyCollection 등을 제대로 활용 안하면서 JPA 꾸지다는 사람은 공부를 깊이 안한걸로..)이 영상에 좋은 내용이 아주 많음. 앞으로 영상을 반복해서 볼 것 같음." }, { "title": "2019년 22주차 회고", "url": "/2019/06/04/2019%EB%85%84-22%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "사과, 관계", "date": "2019-06-04 00:00:00 +0000", "snippet": "3주 전 쯔음인가? 나는 여사친과 ‘사과’(먹는사과 아님) 에 대한 주제로 이야기를 나눈 적이 있었고, 이야기를 계속 나누다가 내가 공감능력이 떨어진다는 소리를 들었다. 남들이 나에게 비수같은 말을 꽂아도, 크게 신경쓰지 않는 편이다. 문제는 내가 타인에게 주는 상처에 대해서도 둔하다는 것이다. 그래서 내가 누구에게 어떤 상처를 줬는지, 그리고 상처를 줬다고 해도 쉽게 까먹는다.나는 대화를 하면서, “그럴 수도 있겠네” 라는 말을 굉장히 많이 쓴다. 주방에서 일했을 때, 불화가 생길 때마다 나는 누구의 편도 들지 않고 항상 중립적인 위치였다. 이 상황은 그 누구의 잘못도 아니며, 전혀 싸울 이유도 없고 편가를 이유도 없어보였다. 나로서는 이런 성격이 불편한 경우가 더러 있었다. 내 친구가 누군가에게 피해를 입어서 속상한 상황일 때, 가해자의 입장이 이해가 갈 때도 분명 있었다. “그럴수도 있겠네” 이다. 이는 친구에게 전혀 위로가 되지 않는다. 설령 친구의 속상함에 공감이 가지 않더라도 위로하는 방법도 있겠지만, 진심이 아니라면 애써 위로할 필요는 없다고 생각한다. 그러다보니, 주변 사람들에게 항상 힘이 되고 위로해주는 좋은 친구 관계로는 남을 수 없었다. 나의 이런 행실에 쉽게 상처받는 사람들과는 점점 멀어졌다. 잘난척하는 사람은 내가 미리 손절 하는 편이고, 감성적인 사람들에게는 손절 당하는 편인 것 같다. 주변에 남아있는 사람들은 쿨한 성격을 가진 사람들이 대부분이다. 여러 사람들과 관계를 형성할 수록 느끼는 것이 있다. 관계 속에서 사건 사고가 있을 때가 분명 있다. 이 때는 내가 몰두할 수 있는 환경을 방해한다. 한 곳에 집중하기가 어려워진다. 그래서 아애 단절을 자처한 경우도 있었다. 오히려 마음이 편안해진다. 단절에서 오는 힘이 굉장히 큰 것 같다. 대학교를 다닐 때는 과동아리 총무를 맡으면서 항상 들떠있는 사람으로 살아왔다. 지금은 완전 반대의 사람이 되었는데, 개발을 진심으로 임하면서부터 사고가 바뀐 것 같다. 과거에는 개발자는 워라밸이 보장이 안되는 직업이라 자신의 삶이 없는 직종이라고 생각했지만, 지금은 개발쪽을 선택하길 참 잘했다고 생각한다. 하루를 온전히 몰두할 수 있는 직업이 과연 몇이나 될까. 지금까지 인생에서 가장 소중하고 친했던 누군가를 뽑으라면 초등학생 때 부터 같이 살던 강아지였다. 2년 전, 강아지가 세상을 떠났는데, 그 이후로 지금까지 의지할 곳이 없다. 2년이 지난 지금도 이 친구를 떠올릴 때면 눈물이 흐른다. 가장 소중한 인연을 보내고 나니, 삶에 희망과 욕심을 잃어갔다. 너무 힘들어서 몇 달간은 내 삶을 어떻게 살아갈지에 대한 고민을 계속 했다. 그런데 아무리 생각해도 잘 모르겠더라. 환생과 천국은 존재하지 않는다고 굳게 믿는 나에겐, 고민하고 고민할수록 삶은 허무하게만 다가왔다. 내가 사는 이유는 딱히 죽을 이유가 없었을 뿐더러 죽을 용기조차 없었고, 현재도 마찬가지다. 내 수명을 10년 줄이는 대신 강아지와 1년 동안 다시 살아갈 수 있게 해준다면 당장 그렇게 하고 싶다. 사회적 이슈에 별 관심이 없고, 내 취미가 무엇인지도 잘 모르겠다. 그냥 내가 할 수 있는 것들로 사람들이 필요로 하는 서비스를 만들다가 죽으면 만족할 수 있을 것 같다. 죽기 전에 내가 가장 사랑하는 사람이 옆에 남아서 나를 보내주면 좋겠지만, 결혼도 생각이 없다. 이것이 나의 27살 때 가치관인데 언제 어떻게 변할지 궁금하다." }, { "title": "ModelAttribute와 RedirectAttributes", "url": "/2019/06/01/MyBatis-%EC%82%AC%EC%9A%A9-%EC%8B%9C-snake_case%EC%9D%B8-%ED%95%84%EB%93%9C%EB%A5%BC-camelCase%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/", "categories": "Spring", "tags": "", "date": "2019-06-01 00:00:00 +0000", "snippet": "DBHelloVOhttp://localhost:8080/hello/1{ &quot;id&quot;: 1, &quot;name: &quot;이름&quot;, &quot;regDateTime&quot;: null}DB의 reg_date_time 과 스프링의 regDateTime이 바인딩이 안됨.snake -&amp;gt; camel 로 변경하는 뭔가가 필요함.  Case 1. Alias ✔️HelloMapper.xml &amp;lt;select id=&quot;findAll&quot; resultType=&quot;me.bactoria._27_FileUpload.domain.hello.Hello&quot;&amp;gt; SELECT id, name, reg_date_time as regDateTime FROM hello; &amp;lt;/select&amp;gt; http://localhost:8080/hello/1{ &quot;id&quot;: 1, &quot;name: &quot;이름&quot;, &quot;regDateTime&quot;: &quot;2019-06-01T07:00:46.818145&quot;} regDateTime 이 아닌, regdatetime으로 나오지만, 자바에선 필드명을 대소문자 구분하지 않기 때문에 바인딩이 가능한 것 같음.하지만, 하나하나 저렇게 적기엔 뭔가 꺼림칙함.  Case 2. mybatis 설정 변경 (application.yml) ❌application.ymlmybatis: configuration: map-underscore-to-camel-case: truesnake를 camel로 바꾸는 설정은 맞지만, 나는 sqlSession 빈을 직접 등록했기 때문에 application.yml에 추가해도 적용이 안됨. http://localhost:8080/hello/1{ &quot;id&quot;: 1, &quot;name: &quot;이름&quot;, &quot;regDateTime&quot;: null}  Case 3. mybatis 설정 변경 (@Bean) ✔️DateBaseConfig @Bean public SqlSessionFactory sqlSessionFactory(DataSource datasource) throws Exception { SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); sqlSessionFactory.setDataSource(datasource); sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:me/bactoria/_27_FileUpload/mapper/*.xml&quot;)); sqlSessionFactory.setConfiguration(getSqlSessionConfig()); // (추가) return sqlSessionFactory.getObject(); } // (추가) private org.apache.ibatis.session.Configuration getSqlSessionConfig() { org.apache.ibatis.session.Configuration sqlSessionConfig = new org.apache.ibatis.session.Configuration(); sqlSessionConfig.setMapUnderscoreToCamelCase(true); return sqlSessionConfig; } http://localhost:8080/hello/1{ &quot;id&quot;: 1, &quot;name: &quot;이름&quot;, &quot;regDateTime&quot;: &quot;2019-06-01T07:00:46.818145&quot;} 바인딩 성공!" }, { "title": "2019년 21주차 회고", "url": "/2019/06/01/2019%EB%85%84-21%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "스터디vs싸피", "date": "2019-06-01 00:00:00 +0000", "snippet": "Study최근 함께 스프링MVC를 공부하는 동료가 생겼다. 주 4일(월, 화, 목, 금) 간 6시간 씩 함께 공부했다. 이 Study는 스프링MVC 학습만을 위한 것이 아니라, 하고 싶은 주제를 정해서 함께 공부하는 동료, 팀 같은 느낌이다. 이전에 Vue 스터디를 함께 하시던 분께서 이런 좋은 제안을 해주셔서 너무나 감사하고, 행복하다. 이번 주 하루 일과는 아침 6 ~ 7시 사이에 일어나 얼또를 하고, 10시 ~ 17시는 스프링 스터디를 하고, 저녁에는 독서실에서 하고 싶은 공부를 했다. 딱히 코딩 말고는 하고 싶은 것이 없어서 시간을 많이 보낸 것 같다. 이렇게 쓰고 보면 코딩만 한 것 같지만, 사실은 친구랑 술도 마시고 독서실에 있을 때는 넷플릭스나 유튜브를 틀어놓고 코딩할 때도 있었다. SSAFY목요일 저녁에 삼성 청년 SW 아카데미(SSAFY) 2기 인터뷰 대상자로 선정됬다는 메일을 받았다. 인터뷰에서 합격하면 7월부터 싸피를 하게 된다. (SSAFY는 삼성과 고용노동부에서 소프트웨어 인재를 양성하는 취지로 미취업 청년들에게 교육을 해쥬는 프로그램이다.) 1지망은 서울로 썼다. Study vs SSAFYSSAFY에 최종 합격을 하게 된다면 Study와 SSAFY 중에서 하나를 선택해야 한다.솔직히 Study를 하면 하루하루를 SSAFY 보다 훨씬 알차게 보낼 수 있을 것 같은 자신감은 있다. 내가 SSAFY를 신청한 이유는 뭘까 생각해봐도 딱히 명확한 이유나 근거를 댈 수가 없다. 굳이 말하자면, 서울에는 세미나, 스터디가 많으니까 이것저것 많이 해볼 수 있지 않나? 하는 생각인 것 같다. 근데 솔직히 싸피를 해보지 않은 입장에서 말하기엔 불공평하지만, 싸피보다 지금 하고있는 것이 좋을 것 같다. 그런데 싸피에 대한 욕망은 뭘까나의 인생 목표는 잘 맞는 개발자들과 좋은 개발 하는것이다. 너무 추상적이지만, 아직 일을 해본 경험이 없어서인 것 같다. 목표를 이루기 위해서 대외적으로 알려진 개발자들과 빨리 만나서 네트워킹도 하고 싶었고, 그분들과 함께 개발 이야기를 하면 내가 뭔가 대단해진 것 같은 착각에 빠지기 때문이었던 것 같다. 하지만 세상에는 대외적으로 알려지지 않았지만, 열심히 개발하고 재능있는 개발자들도 많다는 생각을 하게 되었다.나는 좋은 팀, 문화를 주어진 곳 안에서 찾기보다, 밖에서 계속 찾는 습성이 있는 것 같다. 그래서 진짜 보물이 어디있는지를 못 알아볼지도 모르겠다." }, { "title": "Rest API 란?", "url": "/2019/05/28/Rest-API-%EB%9E%80/", "categories": "Rest", "tags": "", "date": "2019-05-28 00:00:00 +0000", "snippet": "Vue 스터디를 하면서 최근에 Rest API에 관한 얘기가 나왔는데,REST에 대해 잘 모르고 있는 것 같아 이번 기회에 확실히 알고 넘어가고자 인터넷을 좀 뒤적거렸다. 그런 REST API로 괜찮은가? by 이응준님 (DEVIEW 2017)REST의 representation이란 무엇인가 by 이응준님 (blog)인프런 REST API 강좌 by 백기선님 (인프런)REST API 제대로 알고 사용하기 by 김동범님 (TOAST Meetup)그 외 다수… Representation ?Representation : resource에 대한 상태를 담은 정보 Representation Representation Data Response Body Representation Metadata Content-Type Content-Language  Representations - RFC 7231(HTTP 1.1), REST의 representation이란 무엇인가 by 이응준님 (blog) 를 보면 representation 에 대해 좀 더 자세히 알 수 있다. Get The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.(GET method - RFC 7231(HTTP 1.1))해당 URL의 리소스에 대한 현재 representation을 요청 REST ? Representational State TransferREST는 웹을 위한 네트워크 기반 아키텍처 스타일(아키텍처가 지켜야하는 제약조건들의 집합) 이다. (소프트웨어 아키텍처 X, 프로토콜 X)관련 논문 : Architectural Styles and the Design of Network-based Software Architectures - Roy Thomas Fielding, 2000  제약조건 (6가지) Client-Server Stateless Cache Uniform Interface Identifying a Representation manipulation of resources through representations self-description HATEOAS Layered System Code-On-Demand (optional)  RESTful은 서비스 중심(SOA)이 아닌 리소스 중심의 표현, 전달, 접근 방식의 특성을 가지는 리소스 기반 아키텍쳐(ROA)이다. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현이건 REST 명세인가 HTTP 명세인가 ?HTTP명세이기도 하고, 이걸 따라야 한다는 것이 REST 인 것 같음. API ? Application Programming Interface데이터를 요청하고 응답을 위한 인터페이스 REST API ?Rest 아키텍처 스타일을 따르는 API Restfu Maturity Model (RMM)Restful 성숙도 모델Leonard Richardson이 QCon 토크에서 설명한 모델. 마틴파울러가 자신의 블로그에 RMM에 관한 글을 적으면서 더 유명해짐.Richardson Maturity Model - steps toward the glory of REST :: 마틴파울러 블로그 (원문)Richardson Maturity Model - steps toward the glory of REST :: 마틴파울러 블로그 (한글 번역) 위 레벨들은 REST의 레벨이 아님. Roy Thomas Fielding은 RMM level3이 되야지 REST라고 부를 수 있다고 함." }, { "title": "ModelAttribute와 RedirectAttributes", "url": "/2019/05/28/ModelAttribute%EC%99%80-RedirectAttributes/", "categories": "Spring", "tags": "", "date": "2019-05-28 00:00:00 +0000", "snippet": "스프링MVC 서적을 보다가 다음의 코드를 보고 의문이 생겼다. @PostMapping(&quot;/modify&quot;) public String modify(BoardVO board, @ModelAttribute Criteria criteria, RedirectAttributes rttr) { log.info(&quot;modify: {}&quot;, board); if (boardService.modify(board)) { rttr.addFlashAttribute(&quot;result&quot;, &quot;success&quot;); } rttr.addAttribute(&quot;pageNum&quot;, criteria.getPageNum()); rttr.addAttribute(&quot;amount&quot;, criteria.getAmount()); return &quot;redirect:/board/list&quot;; }post method로 게시판을 수정하고, /board/list로 리다이렉트한다. 리다이렉트 할 때는 pageNum, amount가 queryString으로 추가될 것이다.Request Request URL: http://localhost:8080/board/modify Request Method: POST Content-Type: application/x-www-form-urlencoded FormData pageNum: 1 amount: 10 bno: 4497525 title: 제목 content: 내용 writer: 주노 Response Status Code: 302 Location: /board/list?pageNum=1&amp;amp;amount=10Redirect Request URL: http://localhost:8080/board/list?pageNum=1&amp;amp;amount=10 Request Method: GET 그런데 위에서 @ModelAttribute를 사용한 이유는 무엇일까. 어노테이션을 없애도 정상적으로 동작한 것 같은데=&amp;gt; Criteria는 @ModelAttribute 를 생략해도 Model에 등록된다. 파라미터가 Object일 때 어노테이션 없어도 Model에 등록됨. (그래도 명시해주는 것이 좋음) 또한, @ModelAttribute에 대해서 제대로 이해를 못했던 것 같다. 모델에 오브젝트를 추가하기 이전에, 일단 QueryString을 객체로 바인딩 해준다는 것을 잠시 망각했다.String, Long은 @ModelAttribute로 받지 못함. Java Beans 규칙(기본생성자, getter, setter 존재)에 맞는 객체만 받을 수 있기 때문. (애초에 @RequestParam 으로 받으면 됨.) RedirectAttributesredirectAttributes.addAttributes();//...rttr.addAttributes(&quot;pageNum&quot;, 5); rttr.addAttributes(&quot;amount&quot;, 10); return &quot;redirect /board/list&quot;;=&amp;gt; Location : /board/list?pageNum=5&amp;amp;amount=10리다이렉트 시, RedirectAttribute들이 QueryString으로 변환되기 때문에 첫번째 파라미터는 String형태만 가능하다. redirectAttributes.addFlashAttributes();//...rttr.addFlashAttribute(criteria);return &quot;redirect:/board/list&quot;;=&amp;gt; Location : /board/listFlash?? =&amp;gt; 한번 사용하고 사라진다.addAttributes와의 차이점 QueryString으로 변환되지 않는다. HttpSession으로 전송된다. 한번 사용하고 사라진다. (새로고침하면 데이터 사라짐) 객체로 넘겨줄 수 있다. (addAttribute는 String만 가능) 리다이렉트된 Method의 Model에 자동으로 등록된다.은 Object를 HttpSession으로 등록한다. Flash 말 그대로 한번 꺼내면 사라진다. 새로고침하면 데이터 사라짐. 게시글 수정 완료 시 Modal을 여는 조건으로 책에서는 사용됬음." }, { "title": "2019년 20주차 회고", "url": "/2019/05/25/2019%EB%85%84-20%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "얼또성공, Fork", "date": "2019-05-25 00:00:00 +0000", "snippet": "얼또 성공이번주에는 매일 6시에 일어나 2시간 동안 개인 공부를 했다. 지난 2주간 일어나기가 힘들어서 실패했는데 이번주에는 어떻게 얼또를 성공적으로 할 수 있었을까.. 그 이유를 생각해보면, 어떤 말에서 영향을 크게 받은 것 같다. ‘성장하기 위해서는 항상 불편해야 할 필요가 있다’ 는 것이다. 포프님이나 아샬님의 유튜브에서 들었던 것 같은데 정확히 기억은 안난다. 아침에, 피곤하기 때문에 일어나지 않았던 것이 피곤하니까 지금 일어나야 성장할 수 있겠다는 생각을 가져볼 수가 있었다. 나는 작년 2월에 얼또를 가입했는데, 그 당시 이런 글을 남긴 적이 있었다. ‘가입된 것을 보고, 그분들과 같은 그룹에 소속됬다고 생각하니 황홀했다.’ 일년만에 다시 얼또를 시작했고, 얼또를 할 때마다 황홀감을 매번 느낄 수 있었다. 이 느낌은 얼또를 함께하는 개발자들이 존경과 선망의 대상임과 동시에, 내가 그 분들과 얼또를 할 수 있음에 약간의 소속감을 느끼는 것에 대한 감정일 것이다. 드디어 얼또를 하게 됬다. 이제 겨우 빨간 막대를 초록 막대로 바꿨다. 이제 리팩토링을 할 차례다. (TDD 비유)주말에는 얼또가 없다. 주말에는 빨리 일어나는데 약간의 책임감을 가질수 있게 하려면 어떻게 해야하는가  Fork누군가 내 블로그 코드를 포크했다. 자랑스러워하고 보람을 느껴야 하는 상황이지만, 너무 부끄러웠다. 1년전에 만들었던 프로젝트인데 가끔 코드를 보면 너무 엉망진창이기 때문이다. ajax요청은 컴포넌트에서 자기맘대로 호출하고 vuex도 제대로 사용도 못했다. 리팩토링을 해야 하는데.. 책도 읽어야 하는데.. 블로그에 대한 애정이 없는건가? 애정이 있었다면 이미 리팩토링 하지 않았을까.. ㅠ" }, { "title": "Vue + Firestore 무한스크롤", "url": "/2019/05/17/Vue-+-Firestore-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4/", "categories": "Vue", "tags": "", "date": "2019-05-17 00:00:00 +0000", "snippet": "Vue 스터디에서 게시판을 만들기로 함. 게시판은 pagination이 아닌, 무한 스크롤 방식으로 하기로 했다. 무한스크롤 라이브러리 선택asesome-vue에서 보면 무한 스크롤이 있겠다 싶어 봤더니 역시나 있었다.이 중에 Star 수가 가장 많은 것은 vue-infinite-scroll이지만, 나는 vue-infinite-loading을 선택했다. 그 이유는 Star 수도 적지 않았고, 최근 커밋이 2개월 전이며(vue-infinite-scroll는 무려 2년 전이다), 데모를 볼 수 있어서 선택했다. How to Usehttps://peachscript.github.io/vue-infinite-loading/guide/#installation 에 가이드가 잘 나와있다. 따라하면 된다. with FireStoreAPI에게 해당 page의 게시글을 응답받기 위해서는 일반적으로 page 번호를 포함하여 요청한다.FireStore 약간 다른데, page 번호를 보내지 않고 마지막으로 받은 doc를 포함하여 요청한다. 쿼리 커서로 데이터 페이지화 - firestore에 아래와 같이 나와있다.// 쿼리 커서를 limit() 메소드와 결합하여 쿼리를 페이지화합니다. // 예를 들어 일정 분량의 마지막 문서를 다음 분량의 커서 시작점으로 사용합니다.var first = db.collection(&quot;cities&quot;) .orderBy(&quot;population&quot;) .limit(25);return first.get().then(function (documentSnapshots) { // Get the last visible document var lastVisible = documentSnapshots.docs[documentSnapshots.docs.length-1]; console.log(&quot;last&quot;, lastVisible); // Construct a new query starting at this document, // get the next 25 cities. var next = db.collection(&quot;cities&quot;) .orderBy(&quot;population&quot;) .startAfter(lastVisible) .limit(25);});lastVisible : 마지막으로 받아온 문서이다.next : 다음 page를 받을 때 lastVisible를 이용한다. 위 코드를 어떻게 써야할지 감을 못 잡아서 아래처럼 짰다.api.js//...const boardLimit = 10;export const board = { fetchs(page) { if (page === &#39;first&#39;) { return firebase.firestore().collection(&#39;boards&#39;) .orderBy(&quot;date&quot;, &quot;desc&quot;) .limit(boardLimit) .get() .then(docs =&amp;gt; { docs.page = docs.docs[docs.docs.length - 1] return docs }) } return firebase.firestore().collection(&#39;boards&#39;) .orderBy(&quot;date&quot;, &quot;desc&quot;) .startAfter(page) .limit(boardLimit) .get() .then(docs =&amp;gt; { docs.page = docs.docs[docs.docs.length - 1] return docs }) } //...} 무한스크롤을 내리다가 게시판을 클릭하고 뒤로가기를 했을 경우, 앞에서 스크롤 했던 게시글들을 그대로 유지하기로 정했다. 이를 위해서는 Vuex에 게시글들을 저장해야 한다.이 때, 주의해야 할 것은 page 또한 Vuex에서 관리를 해야한다는 것이다. 그렇지 않으면 이전에 불러왔던 게시글 밑으로 게시글이 처음부터 추가되는 기이한 현상이 발생한다.이런 경험을 하기 전에 논리적으로 생각할 수 있었으면 좋았을텐데.. 논리적 사고가 부족함을 다시 한번 느꼈다. store/state.jsconst state = { //... page: &#39;first&#39;}export default statepage: Object 로 하지 않은데는 이유가 있다.마지막 게시글까지 스크롤을 내려을 때 page에 null이 담기는데, 이 경우에는 처음 스크롤과, 마지막 스크롤의 경우를 분기하기가 까다로울 것 같다. (분기하지 않으면 말그대로 무한으로 스크롤이 가능하다..)더 좋은 방법이 있을 것 같긴 하지만, 이 부분은 스터디 모임 때 생각해보기로" }, { "title": "Same-Origin Policy와 해결 방안", "url": "/2019/05/17/Same-Origin-Policy%EC%99%80-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88/", "categories": "Rest", "tags": "", "date": "2019-05-17 00:00:00 +0000", "snippet": "Vue.js 프로젝트에서 Rest API로 Ajax요청을 했더니 다음과 같은 에러를 직면했다. Chrome Firefox 해결법 CORS 허용 할 메소드에 @CrossOrigin를 추가 시큐리티 설정에 Options Method를 permitAll REST API 프로젝트를 2개를 했었는데, 2번 모두 SOP 문제에 직면했었고 검색하면서 해결했다. 그래서 지금은 검색하지 않아도 해결 할 수 있다. 하지만 SOP가 무엇이고 왜 나온 것인지, @CrossOrigin을 적용하면 구체적으로 무슨 일이 이루어지는지, Options 메서드를 허용 해야 하는 이유에 대해서는 깊이 생각을 하지 않았던 것 같다.해결법은 아는데, 문제가 생긴 근본적인 원인을 모르는 것이다.프로그래머는 프로덕션을 만드는 사람이고, 서비스를 정상적으로 되게 하는 사람이고, 서비스가 잘 돌아가게 하는 사람이라고 많이 들었다.하지만 최소한 왜 그런건지는 이해를 해야할 것 같다. 어떻게 보면 원인을 알아야 생산성이 더 높아진다고 보는게 맞는 것 같기도 하네. 막무가내로 해결하는 것은 대학교에서 시험치기 위해 암기하는거랑 다를게 없어보인다. Ajax 로 부터Ajax부터 시작하면 될것 같다.이전 웹페이지들은 새로운 내용을 갱신하기 위해 페이지를 리프레시 했었는데,페이지를 리프레시 하지 않고도 서버와 데이터를 주고 받을 수 있게 되었다. 이걸 Ajax라고 한다.지메일이 핫메일을 이긴 진짜 이유 - 조성문님에 따르면 2004년 4월 1일에 Gmail이 나왔는데, 메일을 확인하거나 발송할 때 화면 전체가 깜빡이는 것이 없어서 핫메일보다 빠르고 쾌적했다고 한다. Ajax 를 사용했기 때문이다. (Gmail의 성공 요인은 Ajax가 전부는 아니라고 한다. 어쨌든 빠른건 사실이다.)이 Ajax는 XMLHttpRequest 객체를 통해 구현할 수 있으며, 여기에는 보안 이슈가 있었디. CSRF 공격 (Cross Site Request Forgery)만약 내가 웹페이지를 만들었는데, 아래와 같은 스크립트를 넣어서, 접속자들의 페이스북 타임라인 글들을 삭제하는 것이 가능하다면 ?http://fakebook.comvar url = &quot;http://facebook.com/timelines&quot;; //url은 막무가내로 만든거var xhr = new XMLHttpRequest();xhr.open(&quot;DELETE&quot;, url, true);xhr.onload = function () { var users = JSON.parse(xhr.responseText); if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == &quot;200&quot;) { console.log(&quot;삭제 완료&quot;); } else { console.error(&quot;앗 실패했군&quot;); }}xhr.send(null);이전에 facebook에 로그인을 한 상태에서 fakebook에 방문한다면 그 사람의 타임라인 글을 삭제해버릴 수 있다. (물론 페이스북을 저렇게 단순하게 공격할 수도 없겠지만..) SOP (Same-Origin Policy)SOP는 웹 사이트 방문 시에 다른 Origin의 DOM에 접근시 허용하지 않는 정책이었다. 유저가 신뢰할 수 없는 사이트 방문에 대한 걱정을 덜 수 있다.Ajax가 나온 이후 CSRF를 막기 위해 XMLHttpRequest에도 확장 적용되었다. 웹 브라우저는 현재 웹 페이지에 포함된 스크립트가 어떤 웹 페이지의 데이터에 액세스하는 것을 허용하기 위해서는, 이 두 웹 페이지가 Same Origin이어야 한다.즉, fakebook을 방문했을 때, facebook으로 스크립트를 보낼 수 없게끔 웹 브라우저가 막는 것이 가능해진다. Same Origin 이란?Same Origin : 두 URL의 스키마, 호스트, 포트가 같을 경우Cross Origin : 3개 중에도 하나라도 다를 경우  http://test.com:3000 &amp;amp; https://test.com:3000 -&amp;gt; Cross Origin http://test.com:3000 &amp;amp; http://test.com:8080 -&amp;gt; Cross Origin http://test.com:3000 &amp;amp; http://real.com:3000 -&amp;gt; Cross Origin Same Origin이 아닐 경우(Cross Origin 일 경우), 브라우저에 의해 요청이 거절된다.거절된 것이 이 글의 가장 위에 있는 이미지이다. 해결법1. JSONP2005년 제안된 방법.JSONP를 사용하면 XMLHttpRequest 객체를 사용하지 않고 Cross Origin인 서버로부터 JSON 데이터를 받을 수 있다.XMLHttpRequest 객체를 사용하지 않기 때문에 SOP를 위배하지 않는 것이다.JSONP는 서버로부터 콜백함수를 실행하는 코드를 받아온다.요청// ...&amp;lt;script src=&quot;http://food-truck.shop/search?callback=loadTruckList&amp;amp;s=떡볶이&quot;&amp;gt;&amp;lt;/script&amp;gt;http://food-truck.shop/search?callback=loadTruckList&amp;amp;s=떡볶이 를 아래와 같이 바꿔준다.응답// ...loadTruckList([&quot;John Miller&quot;,&quot;John C. Potter&quot;])food-truck.shop에서 위와 같이 변환해준 것이다.jsonp는 클라이언트에서 쓰겠다고 해서 쓸 수 있는 것이 아니라, 서버에서 위의 형식처럼 함수로 응답해주어야 한다.즉, 서버에서 json 데이터를 함수로 wrapping해서 응답해줘야 하는데 이처럼 감싸는 행위를 Padding이라고 불러서 JSONP 라고 부르는 것 같다.GET Method만을 지원한다는 단점과 보안상의 이슈로 인해 CORS를 추천하는 분위기 라고 함. 2. CORS (Cross-Origin Resource Sharing) 2004년 3월 VoiceXML 브라우저의 안전한 Cross-Origin Data 요청을 허용하기 위해 Cross-Origin 지원을 제안함 2006년 5월 최초의 W3C 작업 초안이 제출됨 2009년 3월 초안은 CORS(Cross-Origin Resource Sharing)로 개명됨 2014년 1월 W3C 권고안으로 승인(W3C Recommendation of CORS) (구식) 201?년 https://fetch.spec.whatwg.org/ (현재) JSONP 패턴의 현대적인 대안.서버와 클라이언트가 정해진 헤더를 통해 서로 요청이나 응답에 반응할지 결정하는 방식으로 CORS라는 이름으로 표준화됨. 서버에 클라이언트가 서버로 HTTP Request를 보낼 때 GET :: custom header가 없으면 HEAD :: custom header가 없으면 POST :: ContentType이 standard(application/x-www-form-urlencoded or multipart/form-data or text/plain) 이고, custom header가 없으면 Cross-Origin에 리소스를 요청 할 수 있다.그 밖의 경우 (ex. POST로 요청에 Content-type이 application/json 인 경우 -&amp;gt; custom header를 가짐.)에는 서버에 Preflight Request를 보내야 함.Preflight Request클라이언트가 서버로 HTTP Request를 보낼 때 위의 기준을 충족하지 못하면, 브라우저가 자동으로 원래 요청보다 먼저 OPTIONS Method로 HTTP 요청하여, 원래 요청을 전송해도 안전한지 확인한다.위 그림에서 빨간 부분이 Preflight Request 과정이다.// Request MessageOPTIONS /users/:id Access-Control-Request-Method: DELETE Access-Control-Request-Headers: origin, x-requested-withOrigin: https://example.com// Response MessageHTTP/1.1 200 OKContent-Length: 0Connection: keep-aliveAccess-Control-Allow-Origin: *Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE JSONP vs CORSJSONP는 GET Method만 지원하는 반면, CORS는 다른 Method도 지원한다.JSONP는 사이트 간 스크립팅(XSS) 문제를 야기할 수 있다.CORS를 사용하면 JSONP보다 더 나은 오류 처리를 지원하는 XHR(XMLHttpRequest)를 사용할 수 있다.CORS는 XHR Level2에서 적용되었는데, XHR2는 대부분의 최신 웹 브라우저에서 지원한다.(https://caniuse.com/#feat=xhr2)IE10 이하는 CORS 지원하지 않음.IE9, 8 이하에서는 XDomainRequest를 사용해야 하고, 그 이하는 JSONP를 사용해야 한다. JSONP는 CORS가 지원되기 이전의 기존 브라우저에서도 동작하기에 브라우저 호환을 중요시하는 곳에서는 JSONP도 쓰고 있을 것 같다.(XDomainRequest가 있지만, Get, Post만 지원함. =&amp;gt; TODO :: CRUD 어떻게?)// XDomainRequestvar xdr = new XDomainRequest();xdr.open(&quot;get&quot;, &quot;http://www.contoso.com/xdr.aspx&quot;);xdr.send();Axios의 경우 0.6.0 버전에서는 XDomainRequest로 IE8을 지원했음. (현재 Axios는 IE11만 지원) 참고 https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/cors.html https://tools.ietf.org/html/rfc6749#section-4.3.2 https://brunch.co.kr/@adrenalinee31/1 https://heowc.dev/2018/03/13/spring-boot-cors/ https://www.zerocho.com/category/HTTP/post/5b4c4e3efc5052001b4f519b https://wit.nts-corp.com/2014/04/22/1400 https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95 https://greatkim91.tistory.com/14 https://www.w3.org/Security/wiki/Same_Origin_Policy SOP https://www.internetmap.kr/entry/Sameorigin-policy JSONP https://ko.wikipedia.org/wiki/JSONP https://kingbbode.tistory.com/26 http://charlie0301.blogspot.com/2013/12/jquery-ajax-same-origin-policy-jsonp.html http://dev.epiloum.net/1311 CORS https://dev.to/effingkay/cors-preflighted-requests–options-method-3024 https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS CORS 설정해도 IE에서 크로스 도메인간 요청 불가 원인 " }, { "title": "셀레니움으로 커뮤니티 홍보하기", "url": "/2019/05/16/%EC%85%80%EB%A0%88%EB%8B%88%EC%9B%80%EC%9C%BC%EB%A1%9C-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%ED%99%8D%EB%B3%B4%ED%95%98%EA%B8%B0/", "categories": "Crawling", "tags": "", "date": "2019-05-16 00:00:00 +0000", "snippet": "유튜브하는 연예인을 알리려고 만든 웹 프로젝트가 있다.허나, 이 페이지를 방문하는 사람이 없어서 어딘가에 홍보를 하고 싶었다. 마침 중고나라에서 반복적인 글을 올리는 매크로를 보았고, 나도 홍보하는 매크로를 만들기로 생각했다. 셀레니움 라이브러리를 이용하여 쉽고 빠르게 매크로를 만들 수 있었다.셀레니움은 python, java, C#, ruby, Perl, PHP, Javascript 언어로 사용 가능하다. - 셀레니움 Docs자바가 편했지만, 생각보다 간단하길래 파이썬으로 짰다. 파이썬 문법을 모르지만, 구글에 검색하면 널린게 코드라 별 어려움이 없었다.디시인사이드 유튜브 갤러리에 2시간 마다 홍보글을 자동으로 올리는 매크로를 만들었다.190516 추가. 지금은 사용하지 않고 있다. 예약 작업 걸어뒀더니 서버가 계속 죽길래 예약작업을 없앴다. 허나, 홍보글 올리는 기능 자체는 아직까지 잘 동작하는 것을 확인했다. 로직은 간단하다.1) 드라이버 로드2) DC inside 접속3) 로그인4) 유튜브 갤러리 글쓰기 페이지 이동5) 제목 &amp;amp; 내용 입력6) 저장7) 드라이버 종료python.py#!/usr/bin/python3# -*- coding: utf-8 -*- #youtube.pyfrom selenium import webdriverimport timeid = &#39;계정 아이디&#39;pw = &#39;계정 비밀번호&#39;URL = &#39;http://www.dcinside.com&#39;GALL = &#39;http://gall.dcinside.com/mgallery/board/write/?id=youtube&#39;TITLE = &#39;유튜브하는 연예인 리스트&#39;CONTENT = &quot;&amp;lt;br&amp;gt;&amp;lt;p&amp;gt;&amp;lt;span style=&#39;font-size: 24pt; font-family: Verdana, sans-serif;&#39;&amp;gt;&amp;lt;b&amp;gt;유튜브하는 연예인 알리기 프로젝트&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;a href=&#39;http://yoututu.kr&#39; target=&#39;_blank&#39; class=&#39;tx-link&#39;&amp;gt;&amp;lt;span style=&#39;font-size: 14pt;&#39;&amp;gt;유튜튜 바로가기&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;img src=&#39;https://github.com/bactoria/Celeb-Youtube-Vue/raw/master/assets/yoututu1.PNG&#39;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;br&amp;gt;&amp;lt;img src=&#39;https://raw.githubusercontent.com/bactoria/Celeb-Youtube-Vue/master/assets/yoututu2.PNG&#39;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/p&amp;gt;&quot;chrome_options = webdriver.ChromeOptions()chrome_options.add_argument(&#39;--headless&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;)chrome_options.add_argument(&#39;--disable-dev-shm-usage&#39;)chrome_options.add_argument(&#39;--disable-gpu&#39;)chrome_options.add_argument(&quot;user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;)# 1. 드라이버 로드driver = webdriver.Chrome(&#39;./chromedriver&#39;, chrome_options=chrome_options)driver.implicitly_wait(3)# 2. DC inside 접속driver.get(URL)time.sleep(3)# 3. 로그인driver.find_element_by_name(&#39;user_id&#39;).send_keys(id)driver.find_element_by_name(&#39;pw&#39;).send_keys(pw)driver.find_element_by_id(&#39;login_ok&#39;).click()# 4. 유튜브 갤러리 글쓰기 페이지 이동driver.get(GALL)time.sleep(3)# 5. 제목 &amp;amp; 내용 입력driver.find_element_by_name(&#39;subject&#39;).send_keys(TITLE)driver.find_element_by_id(&quot;tx_switchertoggle&quot;).click();time.sleep(1)driver.switch_to_frame(driver.find_element_by_xpath(&quot;//iframe[@name=&#39;tx_canvas_wysiwyg&#39;]&quot;))driver.find_element_by_tag_name(&quot;body&quot;).send_keys(CONTENT)# 6. 저장driver.switch_to_default_content()driver.find_element_by_xpath(&quot;//button[@type=&#39;image&#39;][@class=&#39;btn_blue btn_svc write&#39;]&quot;).click()time.sleep(1)# 7. 드라이버 종료driver.quit()브라우저 드라이버가 필요한데, Chrome Driver를 이용하였다.(Chrome 이외에도 Firefox, IE, Safari, Opera 를 이용할 수 있어보인다. - 셀레니움 Docs)chromedriver 파일을 다운받고 python 파일과 같은 루트에 위치시켰다. [root@ip~~ macroDC]# ./youtube.py실행시키면 글이 올라간다.   예약 작업이제 주기적으로 youtube.py를 실행시켜주기만 하면 된다.crontab을 이용하여 특정 시간마다 youtube.py를 실행시켰다. (crontab : 리눅스 예약 작업) crontab# 매일 2시간 간격으로 7분에 `youtube.py`를 실행시킨다. (ex. 0시 7분, 2시 7분, ...)7 */2 * * * cd /home/ec2-user/macroDC &amp;amp;&amp;amp; ./youtube.py " }, { "title": "2019년 18,19주차 회고", "url": "/2019/05/13/2019%EB%85%84-18,19%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "얼또실패, 팔굽혀펴기, 개발, 피드백", "date": "2019-05-13 00:00:00 +0000", "snippet": "얼또 실패얼또를 계획한지 2주가 됬다. 무려 14일이나!! 얼또를 시행한 횟수는 0회다. 2주 동안 단 한번도 안했다… 늦게 자는 바람에 아침 일찍 일어나는게 너무 힘들다. 그리고 프리미어 리그 우승팀이 결정되는 오늘도 늦게 잘 계획이다. 매일 그럴싸한 변명만 늘어놓는다. 내가 원래 이런 사람인가? 2주 전에는 8개월 뒤의 나를 엄청 성장시킬 것처럼 말했지만, 지난 2주를 되돌아보면.. 아침 일찍 일어나는 것도 못하는 사람이다. 그래서 일단 환경을 좀 바꾸기로 했다. 지금껏 집 &amp;amp; 카페에서 공부 했었지만, 어제 독서실을 끊었다. 알아보니까 프리미엄 독서실이라는 게 있더라. 완전 밀폐된 공간이라 노트북을 마음대로 쓸 수 있다. 마치 코워킹 스페이스에 있는 기분이다. 마음에 든다. 팔굽혀펴기헬스 안한지가 8개월이 넘었다. 그동안 살도 좀 쪘고 몸이 무거워진 것을 체감되서 운동의 필요성을 느꼈다. 그렇다고 헬스장을 갈 생각은 없다. 그래서 매일 팔굽혀펴기 100개 이상 씩 하고 있다.근육을 키우기 위해서 깔짝 깔짝하는 건 아무 도움이 되지 않는 것을 잘 안다. 한계치에서 더 해야 한다. 개인의 성장도 똑같은 것 같다. 남들보다 더 많이 성장을 하려면 하루 하루가 불편하다고 느끼게 만들어야 할 것 같다. 그런데, 얼또를 안했다는 건 성장할 생각이 없는건가.. 한 주 더 지켜봐야겠다. 개발가끔 아샬님 유튜브 영상 보는데, 최근 보면서 느낀게 있다.나는 Spring Boot, Node.js, Django 를 다 해봤어! 이런 것 보다 HTTP를 얼마나 알고 있고, 웹의 흐름을 얼마나 꿰뚫고 있는지가 중요한 것 같다. 그래서 최근에는 REST API, SOP 공부를 좀 했다. 취업에는 도움이 될진 모르겠지만, 이런 것도 모르고는 동료들과 대화조차 불가능 할 것 같다. 그런데, 이런건 학부생 때 다 공부하는 내용인가? 난 이런걸 공부 안해서 이제 하고 있는 걸지도. 피드백피드백을 받을만한 곳을 찾아봤다. 난 무직이니까 사수도 없고, 멘토도 없다. 무턱대고 개발자분께 페메로 물어보는건 예의가 아닌 것 같다.현재 내가 피드백을 받을 수 있는 곳은 영상과 책이다. 개발자분들이 유튜브 라이브 방송할 때 궁금한게 있으면 물어보라고 하실 때가 있다. 너무 뜬금없는 질문만 아니면 잘 답변해주셔서 좋은 것 같다. 책도 그렇다. 코딩호러의 이펙티브 프로그래밍, 실용주의 프로그래머 등의 책은 앞으로 어떤 개발자가 되어야 겠다는 생각을 하게 해준다. 이러한 책은 한번 보면 끝나는 것이 아니라 볼 때마다 새롭게 다가올 것 같다. 왜냐하면 책의 지식을 나에게 흡수하면서 읽는다는 느낌보다, 책을 읽으며 내 현재 상태에 고찰을 할 수 있도록 하는 것 같아서.이런 자극제를 좀 더 끌어모을 필요가 있어보인다. 더 많이. 아주 많이." }, { "title": "2019년 16,17주차 회고", "url": "/2019/05/01/2019%EB%85%84-16,17%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "책, 우아한테크코스탈락, 얼또", "date": "2019-05-01 00:00:00 +0000", "snippet": "16주차에 회고를 안했다. 그 때 멘탈이 터졌거든. 그래서 이번에 2주치다. 책목요일 밤에 부산에 도착했다. 집에서 푹 자고 일어나면 서울에서 있었던 일들이 꿈을 꾼 것 마냥 느끼며 툴툴 털어버리진 않을까 기대했다. 그리고 도서관에서 책을 좀 빌려서 보기로 했다. 자고 일어났는데 서울에서 보냈던 시간이 생생했다. 띠용.. 어쨌든 도서관에서 책을 5권 빌렸다. HTTP 완벽가이드 그런 REST API로 괜찮은가 - 이응준 (DEVIEW 2017)를 보며, REST를 공부하다가 이 책이 밑바탕이 될 것 같아서 빌렸다. 이 책을 번역하신 이응준 님의 블로그에 웹 프로그래머를 위한 HTTP 완벽 가이드 읽는 법이 있어, 이대로 읽어보기로 함. 피플웨어 3판 옮긴이의 글을 읽고나니 너무 읽고 싶었다. 이 책을 1년마다 읽는다면 매번 느낌이 다를 것이다. 시스템 프로젝트의 진짜 문제는 기술적인 문제라기 보다 사회학적인 문제인지도 모르겠습니다. 함께 일할 팀원들이 서로를 신뢰하지 않는다면 아무리 좋은 소프트웨어 패키지나 장비를 쓰더라도 차이가 없을 것이다. 취업도 하지 않은 내가 이 글을 읽을 때가 맞나 싶기도 했다. 어쨌든 빌림 함수형 사고 프리코스를 할 때 Stream API를 쓰다가 함수형에 대해 관심이 생김. 자바에서 지원하는 함수형과 리얼 함수형 패러다임의 차이를 알고 싶었다. 케빈님 유튜브의 게임으로 배우는 함수형 프로그래밍을 보며 했던 게임을 하다가 관심이 커져서 빌리기로 함. 리팩토링 블로그 API를 리팩토링하고 싶었다. 근거를 가지기 위해서 리팩토링 책을 빌렸다. 변신 - 카프카 친구가 추천해줘서 읽어봄 도서관에서 다 읽고 오려고 했으나, 배고파서 그냥 빌려옴 책은 다읽으면 책 대로 리뷰를 좀 써야겠다. 다음번에 책을 다시 읽을 때 참고할 수 있도록. 우아한테크코스 탈락코딩테스트 일주일 뒤인 월요일에 불합격 통보를 받았다.나에게 삶의 목표는 좋은 사람들과 좋은 개발을 하는 것이었고, 우아한 테크 코스를 진행하면 8개월 간 목표를 이루면서 행복할 것 같았다.좋은 기회를 잡았다고 생각 했었는데, 결국 얻지 못했다. 그리고 다른 목표가 생겼다. 우아한 테크 코스를 수강하는 황준오보다 더 발전된 황준오가 되자. 그동안 무기력하게 있었는데, 탈락통보를 받으니 오히려 독기가 생긴 것 같다. 얼또페이스북에 얼또 라는 그룹이 있다. 얼또의 취지는 출근하기 전에 공부하는 시간을 갖자인데, 나는 불규칙적인 생활을 고치고자 얼또를 하려고 한다. 일어나는 시간에 조금의 책임감을 가질 수 있기 때문이고, 아침 일찍 일어나서 나쁠건 없으니까. 얼또를 하면서의 첫 목표는 블로그 리팩토링이다. 습관이 잡힐 때 까지 일찍 자야할 것 같다." }, { "title": "우아한 테크 코스 프리코스를 진행하면서 느낀점", "url": "/2019/04/23/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/", "categories": "회고", "tags": "피드백의중요성, 책읽는법, 절망극복하는법", "date": "2019-04-23 00:00:00 +0000", "snippet": "우아한 테크 코스를 진행하면서 느낀 감정들을 시간이 지나면서 잊어버릴 것 같아 남겨본다. 피드백이 중요한가프리코스를 진행하면서 총 3번의 과제와 피드백이 있었다.매주 피드백을 받으면서 자바지기님과 소통하는 느낌을 받아서 좋았다. 내 코드의 문제점을 정말 낱낱이 까발려주는(?) 내 코드에 대한 약간의 책임감을 느끼니 예쁘게 짜야겠다는 생각이 들었다.그 누구든 살아가면서 피드백은 중요한 것 같다. 골목식당에서도 뭘 잘못한지도 모르면서 장사하다가 백종원씨한테 까이면서 고치듯이 나에게도 피드백이 필요하다. 그동안 개발하면서 개인의 성장에 있어 피드백에 대한 중요성을 잘 모르고 있었던 것이 후회가 남는다. 그래서 피드백이 필요한 곳으로 찾아 나서야겠다고 생각했다. 개발은 혼자서 하는게 아닐뿐더러 학습자체도 느린 것 같다. 책 읽는 방법프리코스를 진행하면서 객체를 설계하는 부분에 어려움을 느껴 객체지향의 사실과 오해 라는 책을 읽었는데, 객체 설계의 시작은 메세지로부터 출발했다. 메시지로 책임을 위임하고, 그 책임을 맡아서 할 역할을 개체로 만드니 클래스 구조가 이해되는 것 같더라. 그리고 책으로 통찰력을 얻은건 맞지만, 내 코드에 써먹으면서 학습하며 성장할 수 있다고 느꼈다.이펙티브 자바 의 경우를 봐도 그렇다. 3판을 구매했을 당시 앞에서부터 읽다가 포기한 적이 있었는데, 그 때는 책을 읽기만 하고, 코드를 짜보지도 않고, 내 코드를 기반으로 어떻게 적용할지 고민도 하지 않아서 내용도 금방 까먹어버린 것 같다. 하지만 이번 프리코스를 진행하면서 많은 부분을 익혔다. 6장 열거 타입을 읽으며 Enum도 적용해보고, 리팩토링할 것들을 찾기 위해 7장 람다와 스트림, 8장 메서드 등을 훨씬 집중하면서 읽을 수 있었던 것 같다. 리팩토링한 후, 커밋 메시지를 남길 때에도 내 코드 수정에 대한 근거가 책에 자세히 설명되어 있으니 곱씹어 학습하는 느낌이었다.지난주에 박미정님 인터뷰 - 지앤선를 보며 TDD를 어떻게 공부 하셨는지 들을 수 있었는데, 이 때 책을 어떻게 읽을지 감을 잡을 수 있었다. TDD를 처음 공부할 때 책을 보지 않았어요. TDD가 하는게 좋다고 이야기 하시는 분들의 글을 먼저 봤어요. 그분들의 글을 보면서 내 코드중에 적용시킬게 있는지 찾아봐야요. 그렇게 해보고 좋다는 것을 체감을 하면 그 때부터 책을 봐요.책이 필요한 상황을 만들어서, 내가 정말 필요하다고 느끼게끔 만든 후에 읽는 것을 해보기로 하면서 도서관에서 책 5권을 빌렸다. 이 책들 읽으며 얼또를 실천하려고 한다. 절망을 극복하는 법오프라인 코딩 테스트 치고 나서는 개발에 회의감만 들고… 다음날 양일간의 AWS 컨퍼런스도 재껴버리고… 집에 와서는 ‘언젠간 다시 의욕이 생기지 않을까? 시간이 해결해주겠지’ 라고 생각하며 침대에서 주말을 흘려보냈다.그리고 오늘 최종 불합격 통보를 받았다. 생각보다 별 감흥이 없어서 놀랬다. 오히려 오기가 생겼다. 8개월간의 교육을 받는 황준오보다 더 발전되어 보이겠다. 8개월간 교육생들보다 독하게 살꺼고, 8개월 뒤에는 교육을 떨어져서 다행이었다는 포스팅을 꼭 남길거다.이런 생각이 드니 정신이 오히려 맑아졌다. 생각보다 빨리 회복이 된 것 같아 다행이다." }, { "title": "2019년 15주차 회고", "url": "/2019/04/23/2019%EB%85%84-15%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "노트북없는'나', 디자인재능기부, RestAPI", "date": "2019-04-23 00:00:00 +0000", "snippet": "‘노트북이 없는’ 나는 누구인가화요일에 노트북이 또 뻑났다. 모니터가 안나오더라. 결국 새벽에 램을 닦아가며 정상적으로 작동되긴 했지만.. 컴퓨터와 노트북이 사라진다면 나는 무엇을 할 수 있고, 어떻게 살아갈까 생각을 해보았다.이 세상에서 컴퓨터, 노트북, 휴대폰 등이 사라진다면 사람들의 생활이 모두 무너지겠지만, 나만 못쓴다고 가정했다.우선, 직업을 구해야지. 직업은 무엇일까? 요리하는 것을 좋아했으니 주방에 일하러 갈 것 같다. 셰프처럼 레스토랑에서 일은 하기 어려울테고 프렌차이즈 주방으로 가지 않을까?살아가는 목표를 잡기가 조금 까다로운 것 같다. 요리를 잘하기? 매장 운영을 잘하기?내가 주방에서 일할 때는 목표라기 보다는, 주방 직원들끼리 놀면서 그때 그때 일하는게 그냥 즐거웠었는데.. 본업으로 삼으면서 그러기엔 걱정이 동반될 것 같다. 아무 생각이 없이 살아간다는 느낌이 들 것 같다.  디자인과 친구의 재능기부목요일날 우아한 테크코스 과제를 끝내고 금요일에는 여유가 있었다.저녁에 카페에서 중학교 친구들을 만났다. 만남의 목적은 사과 수업이다. ㅋㅋㅋㅋㅋ디자인과 친구가 사과 그리는 법을 알려주었다.똥손인 내가 이렇게 맛있어보이는 사과를 그리다니!! 멀리서 보면 정말 잘 그린 것 처럼 보인다.집에 가서는 다른 친구들에게 내 사과를 자랑한다고 바빴던 것 같다 ㅋㅋㅋ 색다른 경험이 너무 재밌었다.나는 코딩하는 걸 알려줘볼까.. 생활에 도움이 되고 러닝커브가 낮으며 쉽게 흥미를 가질 수 있는것! 흠.. 어떤게 있을까 고민 좀 해봐야겠다.  REST (Representatinal State Transfer)화요일에 Vue 스터디를 하는 도중 Rest API에 대해 이야기가 나왔는데, Rest에 대해 정확하게 모르는 것 같았다.주말에 공부를 좀 하고 REST에 대해 포스팅을 하려고 했으나, 이렇게 회고글로 끄적이는 이유는….이미 좋은 글들은 많이 널려 있다고 생각했기도 하고, 깊게 들어가다 보니 시간을 많이 투자할 필요성을 느꼈는데 다음주 화요일에 중요한 시험이 있어서 결국 미뤘다.결국 TodoList에 3가지가 추가되었다. REST 파헤치기 HTTP 완벽가이드 구매해서 완독하기 백기선님 REST API 강좌 수강하기TodoList가 차곡차곡 쌓여가기만 한다.. 공부를 안하는건지, 욕심이 많은건지.." }, { "title": "책을 어떻게 읽을까", "url": "/2019/04/19/%EC%B1%85%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%BD%EC%9D%84%EA%B9%8C/", "categories": "회고", "tags": "", "date": "2019-04-19 00:00:00 +0000", "snippet": "책을 어떻게 읽을까.저번에 객체지향의 사실과 오해 를 읽고 나서는 나는 매우 성장했음을 느꼈다.책을 어떻게 읽는 것이 좋을까.이 때는 내가 책을 내가 클래스 설계하면서 막막해서 통찰력을 얻기 위해 읽었던 책인데, 클래스 설계가 막힘. 도움을 얻기 위해 구글에 검색을 함. 블로그에서 책의 예제를 읽고 아! 하고 무릎을 탁침. 다음날 책 사러감. 오전부터 새벽까지 그 책만 읽음. 클래스를 설계를 어떤식으로 해야될지 알게됨. 클래스를 어떻게 짤지 고민함. -&amp;gt; 그래도 잘 못짜겠음 5번으로 돌아감.이렇게 하니 내 코드가 좋아졌음을 느낄 수 있었다. 글을 읽어서 습득한게 아니라 경험으로 습득을 했음. 책만 읽었다면 과연 성장 할 수 있었을까? 책으로 통찰력을 얻은건 맞지만, 내 코드에 써먹으면서 학습한 것 같다고 느꼈음. 그리고 어제 박미정님 인터뷰 - 지앤선에서 박미정님이 TDD를 어떻게 공부 하셨는지 들을 수 있었다. TDD를 처음 공부할 때 책을 보지 않았어요. TDD가 하는게 좋다고 이야기 하시는 분들의 글을 먼저 봤어요. 그분들의 코드를 보면서 내 코드중에 적용시킬게 있는지 찾아봐야요. 그렇게 해보고 좋다는 것을 체감을 하면 그 때부터 책을 봐요.이 부분을 끝으로 영상이 갑작스럽게 끝나서 아쉬웠지만, 이 이야기를 듣고 나는 어떻게 공부해야할 지 떠올렸다. 책이 필요한 상황을 만들어보자.영상을 보면서 또 배웠던 것은 근거를 찾는 거다. 내가 하는 행동, 내가 내리는 결정에 대해 근거를 가지고 있어야 할 필요성을 또 한번 느꼈다. 나의 결정에 근거를 가지고 있어야 다른 사람을 설득시킬 수가 있더라.그리고 오늘 도서관에서 책을 여러권 빌렸다. HTTP 완벽가이드 REST API를 학습하기 위해 빌렸다. 월요일에 Vue 스터디가 있는데, REST를 이해하기 위해 밑바탕이 될 것 같아서 빌렸다. 피플웨어 옮긴이의 글, 머리말을 읽고 나니 이 책을 너무 읽고 싶었다. 이 책을 1년마다 읽는다면 매번 느낌이 다를 것이다. 시스템 프로젝트의 진짜 문제는 기술적인 무제라기보다 사회학적인 문제인지도 모르곘습니다. 함께 일할 팀원들이 서로를 신뢰하지 않는다면 아무리 좋은 소프트웨어 패키지나 장비를 쓰더라도 차이가 없을 것이다. 개발이라는 것보다 어떤 자세를 가지고 생활을 해야할지를 배울 수 있지 않을까 하는 기대감이 있다. 함수형 사고 최근 케빈님 함수형 보면서 게임을 하다가 좀더 알고 싶었다. 리팩토링 블로그 API를 리팩토링하고 싶었다. 근거를 가지기 위해서 리팩토링 책을 빌렸다. 클린코드도 빌리려고 했는데, 책이 없었다. (분명히 대출가능 이었는데..) " }, { "title": "우아한테크코스 프리코스 후기", "url": "/2019/04/14/%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-%ED%9B%84%EA%B8%B0/", "categories": "리뷰", "tags": "우아한테크코스, 우아한형제들", "date": "2019-04-14 00:00:00 +0000", "snippet": " 1주차 함수가 한가지 일만 하기 기능 목록을 만들고, 기능 단위로 commit 하기 2주차 1주차 피드백 Stream API clone 일급 컬렉션 commit message 3주차 클래스 설계 우아한 테크 코스는 회사가 필요로 하는 역량을 가진 프로그래머를 양성하기 위한 프로그램이다.온라인 코딩테스트 합격자는 총 3주간 프리 코스를 진행하게 되는데, 1주일마다 1개씩 요구사항을 구현, 총 3개의 구현을 하게 된다.오늘 프리코스 3주차 과제를 마치며 느낀점을 간략하게 써볼까 한다.(간략하게 쓰려고 했으나, 내용이 길어졌다.)  1주차과제에 대한 요구사항이 몇가지 있었는데, 어려웠던 요구사항은..함수가 한가지 일만 하기 함수를 분리하는 기준과 필요성에 대해서도 명확히 알지 못했다.그래서 함수를 한가지 일만 하도록 쪼개는 것이 쉽지가 않았다.알고리즘을 풀 때 재귀 호출이 필요한 문제를 제외하고는 main() 메서드에서 구현 했으니까..인터넷으로 함수를 어떻게 분리할지 찾아보다가 클린코드 라는 책을 알게 되었고, 함수 분리 뿐만 아니라 클래스 분리, 어떤 코드가 좋은 코드인가에 대한 정보를 얻을 수 있었다.어떤 메소드를 숨겨야 하는지, 객체는 얼만큼 쪼개야하는 지에 대한 개념은 많이 부족했다. 기능 목록을 만들고, 기능 단위로 commit 하기기능을 완벽하게 설계하고 개발을 시작해야 겠다는 부담감이 있었다.당시 개발하는 도중에 기능 목록들이 계속 수정되고 있는 것을 보면서 기능을 설계하는 능력이 많이 부족하다고 생각했다. 2주차1주차 피드백2주차 미션과 함께 1주차에 대한 단체 피드백을 받았다.처음부터 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기 보다 기능을 구현하면서 문서를 계속 업데이트하라 라는 피드백이 있었다.메일을 보낼 때 기능 목록이 바뀌는 것에 대한 고민을 적었었는데 소통한 것 같은 느낌을 받으니 기분이 너무 좋았다.또한, 피드백에 클린코드에서 보았던 내용이 많았는데 책을 더 곱씹어 보아야겠다는 생각이 들었다.  Stream API이번 미션을 진행하면서 Stream API 를 써보고 싶었다. 모던 자바(자바8) - 케빈님 유튜브에서 설명이 너무 잘 되있어서 어렵지 않게 공부할 수 있었다.clone객체의 깊은 복사가 필요했는데, 구현하는게 기억이 나지 않아서 이펙티브자바 책을 다시 보게 되었다.당시 책을 눈으로만 봐서 제대로 알지 못하고 넘어간 것 같다. 덕분에(??) 복사 팩터리도 새로 알게 되었다.일급 컬렉션페이스북을 하다가 우연히 일급 컬렉션 (First Class Collection)의 소개와 써야할 이유를 보았다.컬렉션을 래핑하면서 기존 컬렉션이 제공하는 메서드는 감추면서, 내가 필요한 기능을 컬렉션에게 위임 할 수 있다.페이스북의 순기능을(??) 느끼면서 기존의 코드를 리팩토링했다.commit message커밋 메시지는 다른 사람이 한 눈에 커밋의 의도를 알 수 있도록 해야 한다. 그런데 어떻게 적어야 할지 한참을 고민한 경우가 있었다. 내가 해당 부분의 변경에 대한 이점을 명확하게 알지 못해서 인 것 같다. 2주차 과제를 수행하면서 1주차 때보다 발전 했다고 느꼈고, 3주차 과제는 쉽게 할 수 있을 것 같은 자신감이 생겼다.  3주차클래스 설계3주차 미션을 할 때 나만의 목표가 있었다. 오프라인 코딩테스트는 4시간 이니까 4시간만에 다 구현해야지!!처음에는 클래스를 쪼개려고 고민을 많이 했다. 고민만 하다가 이틀동안 아무것도 못했다.클래스 나누는 연습이 필요할 것 같아서 검색을 하다가 커피 예제를 볼 수 있었다. 글을 읽고, 머리를 맞은 기분이었다. 내가 객체지향 프로그래밍을 설계한 방법이 잘못 되었다는 것을 느꼈다.다음날 아침에 객체지향의 사실과 오해를 구매해서 후다다닥 봤던 기억이 난다. 어떤 클래스가 필요하고 어떤 메서드를 포함해야하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다. - “객체지향의 사실과 오해 p.119”클래스를 어떻게 쪼개야 할지를 고민 했었는데, 어떤 행동을 위임할지 부터 생각해야 했다. 기본이 한참 부족했다.  매 주마다 과제를 진행하면서 부족한 것을 느끼면서도, 동시에 성장하고 있음을 체감할 수 있었다.여러 참고 자료들을 몸으로 구현하면서 습득할 수 있어서 학습 속도가 빨랐던 것 같다. 이제 겨우 3주 했다.다음주 오프라인 테스트를 위해 준비를 잘 해서 좋은 사람들과 함께 코딩할 수 있었으면 좋겠다." }, { "title": "2019년 14주차 회고", "url": "/2019/04/10/2019%EB%85%84-14%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "객체지향프로그래밍, 개발의만족감", "date": "2019-04-10 00:00:00 +0000", "snippet": "객체지향 프로그래밍난 자바로 알고리즘 문제를 많이 풀어왔고, 백엔드 서버도 구축해 봤다.하지만, 객체 지향적인 고민은 안해봤다. 지난 2주간 우아한 테크코스 과제를 해결하며 객체지향 프로그래밍에 대한 자신감이 올랐다.과제를 수행하면서 객체 지향적인 사고력이 늘었다고 느꼈기 때문에, 3주차 과제는 별 어려움 없이 구현 할 수 있을 것 같았다.금요일에 3주차 과제를 받았는데, 객체를 어떻게 쪼개야 할지도 모르겠더라.이틀동안 고민만 하다가 객체지향의 사실과 오해 라는 책을 알게 되었다.생각하라, 객체지향처럼을 보면서 책을 꼭 봐야 겠다고 생각했다.다음날 아침에 서점에 가서 책을 구매해서 보았고, 새벽이 되서야 완독할 수 있었다. 책을 읽고 나니 OOP에 대해서 자신감이 붙었고, 많이 알게 된 것 같다고 생각했다.하지만 책의 집필 동기에 다음과 같이 적혀있다. 이 책의 목적은 객체지향을 다루는 다른 책이나 자료들을 읽을 때 미리 알고 있으면 도움될 만한 기본 배경과 지식을 다루는 책입니다.OOP에 공부를 많이 해야 할 것 같다.트렐로에 아직 TODO가 많이 쌓여있는데…우선순위는 OOP가 먼저인 것 같다. 그동안에 기본기를 많이 놓쳤다.  개발의 만족감작년 초부터 존경하는 개발자가 있었다.실제로는 뵌 적이 없지만 유튜브, 페이스북을 통해서 봤었는데그 분의 개발에 몰두하고, 개발을 사랑하는 모습에 나의 개발에 대한 편견이 바꼈다.최근에 배우자와 각자의 길을 걷기로 했다는 소식을 들었다.자세한 사정을 모르기 때문에 내 마음대로 판단하면 안되지만,삶에 중요도가 개발이 더 크지 않았을까 라고 생각 해봤다.나도 열심히 해서 언젠간 같이 일할 수 있으면 좋겠다. 각자 나름대로의 방법으로 하루 하루 만족감을 채우며 살아간다.난 이런 만족감을 친구들을 만나거나, 게임을 하거나, 쇼핑을 하는 등으로 해소했다.개발자의 장점 중 하나가 개발하면서 이런 만족감을 채울 수 있는 것 같다.개발하면서 생기는 만족감을 더 발전시키고 꾸준히 이어가고 싶다." }, { "title": "2019년 1분기 회고", "url": "/2019/04/04/2019%EB%85%84-1%EB%B6%84%EA%B8%B0-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "세미나, 취직, 슬럼프, 공부법", "date": "2019-04-04 00:00:00 +0000", "snippet": "2019년의 1분기가 벌써 지나갔다.사진첩과 주간회고를 보며 90일 동안 어떤일이 있었는지 되짚어 보았다. 세미나 &amp;amp; 컨퍼런스90일간 세미나를 1번밖에 안갔네.. 작년엔 많이 다녔었던것 같은데??2월 말에 삼성전자 소프트웨어 투어를 다녀왔다.투어를 다녀온 직후, 나는 삼성전자에 들어가고 말겠어!! 라는 생각 뿐이었지만,정작 상반기 서류는 쓰지도 않았다. 😂(SW 역량 테스트 B형 시험도 계획 했었는데.. 신청 안했네)  취직아직도 취직을 안했네.. 못한건가?따지고 보면 취직하기 위한 노력도 별로 하지 않았다. 그냥 개발 공부만 했던 것 같다. 이번에 우아한테크코스도 지원했는데 이건 일하는게 아니라 교육이라서..이 8개월 간의 교육이 평생 추억 할 정도로 열정을 쏟아 부울 수 있을 것 같아서 지원을 했다.  슬럼프지난 2월에 약 3주간 슬럼프가 왔었다. 내가 말하는 슬럼프는 개발을 하기 싫어하는 상태이다.깃허브를 봐도 잔디가 텅텅 비어있다.슬럼프가 찾아오면 스터디나 세미나를 가서 리프레쉬 하는게 도움이 되었던 것 같다.지난 2월에도 삼성전자 수원사업장 투어를 다녀와서는 개발에 대한 욕구를 다시 찾을 수 있었다. 나에게 슬럼프는 왜 오는가 ?1. 몸과 마음이 지쳐서개발이 너무 재미있어서 잠까지 줄여가며 할 때도 있다. 허나, 이 때가 가장 위험한 것 같다.몸과 마음이 지치면 나쁜 생각을 할 확률이 높아진다. 기분 전환을 핑계로 게임이나 인터넷 방송에 빠지게 된다.그럼 하루종일 그것만 한다. 다음날 또한 마찬가지다.그렇게 일주일정도 지나면 결국 내 생활 패턴이 되버리고, 빠져나오기가 쉽지 않다. 2. 목표를 잘못 설계해서목표했던 것을 이루지 못했을 때 자존감이 떨어지면서 슬럼프가 찾아왔다. 일주일 전 쯤에 우연히 박진영씨가 나오는 예능을 보았다. 2003년 박진영의 꿈 : 케이팝 최초로 미국 진출2008년 미국 리먼브라더스 사태 =&amp;gt; 미국에 데뷔할 수 없게 됨꿈을 위해 5년을 바쳤는데 출시도 못해보고 허망하게 끝남. 박진영 : 왜 ? 왜 ? 왜 ? 내가 뭘 잘못 했지? =&amp;gt; 내 꿈이 잘못됬구나.. 이건 꿈이 아니라 수단이야 I want to be ~~ : 수단 I wnat to live for ~~ : 꿈이 때 예능을 보다가 침대에 누워서 내 꿈에 대해 한참을 생각해보았다. 나의 꿈은 좋은 회사에 취직하는 것이었다.원하는 회사에 취직을 못했을 때, 그 순간의 좌절감과 자책감으로 인해 슬럼프가 왔다.허나, 이건 꿈이 잘못 설계됬다. 왜 좋은 회사를 들어가고 싶은데?좋은 회사를 들어가고 싶은 이유는 분명했다.좋은 사람들과 열띤 토론으로 안정적인 프로그램을 만들며 만족감을 느끼며 살고 싶기 때문이다.이제 수단과 꿈이 분명해졌다.  TODO공부법 개선분명히 내가 알고 있는 내용인 것 같은데, 남에게 설명하려고 하면 벙 뜬다.몇일 전 Vue 스터디를 했는데, Vuex 에 대해서 설명할 자신이 없었다.Vuex를 계속 써왔는데 왜 설명을 못할까… 그냥 모르는거였다. 커밋 메시지를 작성할 때도 느꼈다.분명 코드를 깔끔하게 리팩토링 한 것 같은데, 이 작업에 대해 누구나 쉽게 알아보도록 한 줄로 작성하는 것은 어려웠다. 어렸을 때 부터 공부 방법이 잘못된 것 같다.개발자들과 코드의 품질에 대해 토론하려면 꼭 고쳐야 한다.2분기에는 무엇인가를 익힐 때 다른사람에게 설명할 수 있도록 공부하는 습관을 갖춰봐야겠다." }, { "title": "2019년 12주차 회고", "url": "/2019/03/25/2019%EB%85%84-12%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "우아한테크코스, Oauth2, 행복", "date": "2019-03-25 00:00:00 +0000", "snippet": "우아한 테크 코스7문제중에 1문제를 제대로 못풀었는데 1차 합격이 되었다.그리고 몇일 전, 1차 합격자들에게 박재성님이 직접 메일을 보내주셨다. 우아한 코스 합격이 목표가 아닌, 좋은 개발자로 성장하는 것올 목표로 성장해 나가면 좋겠다.띠용 ? 이번주 금요일에 메일을 1주차 과제가 시작되었다.문제는 백준 알고리즘에서 흔히 볼 수 있는 간단한 시뮬레이션 문제였다.그래서 코드를 짜는데, 알고리즘 문제 풀 때처럼 절차지향적인 코드를 짰다.클래스를 나누기가 까다로웠다. 이렇게 나누는 습관을 가지지 않아서 그런 것 같다.SOLID 원칙, Enum, Interface 등 헷갈리는 부분을 다시 공부했다.내가 가장 자신있어하는 언어가 자바였는데, 간단한 시뮬레이션조차 제대로 설계를 하지 못한다는게 부끄럽다.Java를 공부하면서 깃허브에 code를 좀 남겨야겠다.아! 그리고 구현할 기능 목록 을 README에 추가해야하는데 어떤식으로 해야할까.. 고민이다  Oauth2저번주부터 쿠키, 세션, JWT, Oauth2 를 공부했다.공부하면서 블로깅하려고 했으나 타이밍을 놓쳐버렸다.배민 과제를 제출하고 남는 시간에 써야겠다.  행복이 뭐길래.. 행복 : 사람이 생활 속에서 기쁘고 즐겁고 만족을 느끼는 상태에 있는 것.그럼 사람들이 행복하다고 표현하는 것은 기쁘고 즐겁고 만족을 느끼고 있다는 것인가.그럼 행복은 오래 못가는 것일텐데.. 행복이 오래가는 사람은 즐거운 일이 자주 일어난다기 보다,그 사람의 사고 자체가 즐거움을 잘 느끼는 사람일 것 같다. 그리고 사람마다 각기 다른 행복의 정의가 있지 않을까?27살 봄에 내가 생각하는 행복은그냥 큰 걱정없이 생활하면 행복한 것이다." }, { "title": "2019년 11주차 회고", "url": "/2019/03/18/2019%EB%85%84-11%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "오픽, 우아한코테, 인생고민", "date": "2019-03-18 00:00:00 +0000", "snippet": "오픽토요일에 오픽 시험을 쳤다.제대로 준비도 안하고, 하루 정도 스크립트를 봤던 것 같다.매번 느끼지만 자격증을 위한 공부는 의욕이 전혀 생기지 않는다.원인은 잘 모르겠다.  코딩 테스트우아한 테크 코스 코딩 테스트. 중요한 시험이었는데.. 문제를 잘못 읽어서 망쳐버렸다.대가가 너무 크다.  인생 고민오랫만에 인생에 대해 고민하는 시간을 가졌다.  삶은 무슨 의미가 있나 ? 결국 죽는데…의미가 없다.그렇다고 죽을 이유도 딱히 없다. 하지만 죽음에 대해 걱정 할 이유가 없다.죽으면 난 생각을 못하잖아.정말로 고통스러운 것은 죽을 때가 아니라 죽는 것에 대한 두려움인 것 같다.  인생을 하루 단위로 보는게 좋은 것 같다.어제의 일과 피로들이 오늘의 나에게 영향을 주겠지만,삶을 하루 단위로 생각하는 것이 더 보람차게 살 것 같다. 잠에서 깨어날 때 새로 태어나고, 잠들 때 죽자.이런 생각을 할 때면 그동안 흘려보냈던 하루들에 대해 반성하게 된다. 그냥 오늘 하루를 유의미하고 보람차게 살면 된다.죽고 나서는 내가 논할게 아니다. 내가 살면서 후회하는 순간 중 하나가 왜 해야되는지도 모르면서 해왔던 것들이다.어릴 때 실컷 놀지 못한것.왜 공부를 해야 하는지도 모르면서 하라고 해서 한 것. 대학생 시절 술만 퍼먹으러 다니고, 전공 공부에 소홀했던 것들은 크게 후회되지 않는다.당시의 내가 하고싶은 것은 했고, 하기싫은 것은 안한 것 뿐이다.미래를 위해서 소중한 오늘을 투자하지 말자.  지금 사람들의 삶은 굉장히 부자연스럽다.노래를 듣는 것. 통화 하는 것. 자동차 타는 것.사람을 먹으면 안되지만 돼지는 먹어도 되는 것.모기를 해충이라고 하는 것. 모기는 잡지 않지만, 고기는 좋아한다.이런 생각을 하면 내 삶을 바라보는 관점이 좀 달라지더라.  잘도 이런 이상한 글을 싸질러 놓았는데 또 몇 일간 공부 안할 속셈인가보다" }, { "title": "세그먼트 트리 (구간합, 구간곱, 최소값, 최대값)", "url": "/2019/03/14/%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%ED%8A%B8%EB%A6%AC-(%EA%B5%AC%EA%B0%84%ED%95%A9,-%EA%B5%AC%EA%B0%84%EA%B3%B1,-%EC%B5%9C%EC%86%8C%EA%B0%92,-%EC%B5%9C%EB%8C%80%EA%B0%92)/", "categories": "Algorithm", "tags": "", "date": "2019-03-14 00:00:00 +0000", "snippet": "세그먼트트리가 처음에 봤을 때는 어려웠었는데1년이 지나서 다시 보니까 별거 아니다.백준 세그먼트트리 - 42 문제 특정 구간의 최소값을 구하는데, 질문이 1개면 그냥 일일이 세면 된다.질문이 10만개면 달라진다.메모이제이션을 해야 하는데, 세그멘테이션 트리를 이용한다.  N = 8, value = [2,1,5,3,2,4,10,5] 에서 구간 최소값 을 구하는 Segment treeleaf Node가 N개 구성된다. ( tree[8] ~ tree[15] )사실, 2^(HEIGHT-1) 이다. 따라서, N이 7일 때도 leaf는 8개  트리 어떻게 만드나?초기화final int HEIGHT = (int) Math.ceil(Math.log(N) / Math.log(2)) + 1; // 4final int S = Math.pow(2,HEIGHT-1) // 8long[] tree = new long[S * 2];Arrays.fill(tree,Integer.MAX_VALUE); // 최소값을 넣어줄 것이기 때문에 높은 값으로 초기화. leaf 노드에 값을 넣어준다. (tree[8] ~ tree[15])values = {2,1,5,3,2,4,10,5}for(int i = 0; i &amp;lt; N; i++) { index = Math.pow(2,HEIGHT-1) + i; tree[index] = values[i];} parents 구하기 (tree[1] ~ tree[7])for(int i = S-1; i &amp;gt;= 1;i--) { // 7 6 5 4 3 2 1 int leftChild = i * 2; int rightChild = i * 2 + 1; tree[i] = Math.min(leftChild, rightChild);}값 초기화에는 여러 방법들이 있다. Top-down 방식보다 위 방법이 더 효율적임.  구간 최소값 구하기.구간의 최소값 트리를 만들었다.1 ~ 4 최소값 또는 5 ~ 6 최소값을 직접 세지 않아도 메모이제이션 되어 있다. 2 ~ 5 최소값은 어떻게 구하는가.min(2, 3~4, 5) 로 해결하면 된다. 하늘색 부분은 return 잘 시켜주면 됨. private long get(int idx, int l, int r, int from, int to) { if(index &amp;gt;= tree.length-1) return Integer.MAX_VALUE; // tree idx 범위 밖 if(r &amp;lt; FROM || l &amp;gt; TO) return Integer.MAX_VALUE; // l ~ r 이 2 ~ 5와 겹치지 않음. else if(FROM &amp;lt;= l &amp;amp;&amp;amp; TO &amp;gt;= r) return tree[idx]; // l ~ r이 2 ~ 5 에 완전포함 // l ~ r 이 2 ~ 5 와 부분적으로 겹칠 경우 아래 코드 수행 int mid = (l + r) / 2; return Math.min(get(idx*2, l, mid, int from, int to), get(idx*2 + 1, mid+1, r, from, to));}위 코드의 4번째 줄에서 return하는 경우는 3가지다. l = 2, r = 2 l = 3, r = 4 l = 5, r = 5 ( 최대값의 경우 max 이고, 구간합은 덧셈, 구간곱은 곱셈을 해주면 된다. )  update ?기존의 노드를 바꿔야 하는 경우가 있다.초기화와 똑같다.// ex) 2번째 값을 10으로 바꾼다. [2,1,5,3,2,4,10,5] -&amp;gt; [2,10,5,3,2,4,10,5] int idx = 2; int value = 10; update(2,10); //...private void update(int idx, int value) { int idx += S - 1; // 2번째 값은 tree의 index상으로 9임. tree[idx] = value; idx /= 2; while(idx &amp;gt;= 1) { int leftChild = idx * 2; int rightChild = idx * 2 + 1; tree[idx] = Math.min(tree[leftIdx], tree[rightIdx]); idx /= 2; }}  value 범위가 int 범위를 초과하는지 항상 확인 할것.  문제 잘 읽자…세그먼트 문제를 풀면서 런타임 에러도 뜨고, 많이 틀렸다.역시나 문제를 잘못 읽었다…습관이 참 무섭다. 집이라고 대충대충 보면 안되겠다. 오픽 시험이 이틀 남았는데, 영어 공부하기가 너무 귀찮아서 세그먼트를 풀었다..Sorry, Eva…." }, { "title": "2019년 삼성 SW 역량테스트 A형 후기", "url": "/2019/03/14/2019%EB%85%84-%EC%82%BC%EC%84%B1-SW-%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8-A%ED%98%95-%ED%9B%84%EA%B8%B0/", "categories": "Algorithm", "tags": "", "date": "2019-03-14 00:00:00 +0000", "snippet": "2019년 3월부터 A형 운영기준이 변경되었다.변경사항은 삼성 expert academy 공지사항 에서 확인할 수 있다.  시험 전날시험 전날 부랴부랴 SW역량 테스트 기출 문제 (백준) 를 보면서 준비했다.이 문제들이 정말 삼성 기출인진 모르겠지만, 시뮬레이션 몇개 풀면서 감을 찾을 수 있었던 것 같다. 지난 SW Vision Tour에서 문제를 잘읽어라 라고 강조 했었는데,이 날도 역시 문제를 잘못 읽어 혼이 빠지는 느낌을 받았고, 문제를 잘 읽어야겠다고 다시 한번 느꼈다.  내일 시험칠 때는 문제를 읽고, 요구조건들을 종이에 적어 정리해야겠다!  시험 후기문제를 읽으면서 문제를 잘 읽자 를 마음속으로 계속 읊었다.다른 사람들이 타이핑치는 소리가 계속 들렸지만, 문제를 끝까지 파악하고 충분히 고민하는 것에 집중했다. 제도가 바뀌고 첫 시험이라 그런지 문제가 쉽게 나왔던 것 같다.(테스트케이스만 통과했기 때문에, A형을 통과할지는 나와봐야 안다.)문제를 풀고 못 풀고의 차이는 그날 컨디션이 중요한 것 같기도 했고.. 운이 좋았다. 19.03.14 추가Level A+ 못땄다… 당연히 딸 줄 알았는데..시뮬레이션이 틀린 것 같은데..ㅜㅜ1시간의 여유가 있었는데도 불구하고 제출하고 고사장을 나온 내가 밉다.4월에 A형 치러 가야겠닭  개선할 점1. 이클립스 B형 시험칠 때는 이클립스로 준비하기. 이클립스로 응시한다는 것을 새까맣게 잊고 있었다.인텔리제이만 써왔기 때문에 이클립스 단축키를 알리가 없었다.시험치기 전, 이클립스가 갑자기 떠올라서 휴대폰으로 단축키를 빨리 훑었다.  2. 디버깅 디버깅으로 문제를 해결하기. 문제를 풀고 답이 예상처럼 안나와서 디버깅을 할 경우가 있었는데,print로 디버깅 한게 너무 부끄럽다." }, { "title": "2019년 10주차 회고", "url": "/2019/03/11/2019%EB%85%84-10%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "삼성전자A형, 트렐로", "date": "2019-03-11 00:00:00 +0000", "snippet": "삼성전자 A형군대 동기가 삼성전자 SW 역량 Test A형 신청 이 열렸다고 알려줬었다.느긋하게 신청하려고 했는데 구미사업장이 마감되었다. (…)동기한테 말하니까 자기 자리를 취소할테니 신청하라고 했다. 그리고 결국 구미사업장에서 시험을 치렀고, 잘 치고 온 것 같다. 동기가 A형을 취소 안했다면 수원사업장까지 가서 치려고 했을까?그건 잘 모르겠다. 그리고 이번 시험을 계기로 삼성전자 상반기를 지원하려고 한다.이번달에 B형도 시험 칠 예정이다. 개발을 취업으로 해야 하는지를 고민하던 시기가 있었고, 군대 동기가 개발에 대한 흥미를 간접적으로 일깨워 준 적이 있었다.그 때가 내 인생의 한 획을 긋는 시점이었는데 이번에도 도움을 받았다. 이런 주변에 도움받을 수 있는 사람들로 내 주변을 채우고 싶다는 생각이 들었다.물론 나의 욕심과 이기심이긴 하다. 나는 누군가에게 인생의 한 획을 그을 정도의 도움을 준 적이 있을까..  Trello최근 Vue 강의를 보면서 Trello 에 대해 알게 되었다.TodoList 처럼 쓰고 있다. 진작 쓸 걸 그랬다.해야 할 것들이 한 눈에 보이고, 우선순위를 매기기 편하다." }, { "title": "Unable to acquire JDBC Connection", "url": "/2019/03/06/Unable-to-acquire-JDBC-Connection/", "categories": "Deploy", "tags": "", "date": "2019-03-06 00:00:00 +0000", "snippet": "블로그좀 들어가보려고 했더니 죽었다… 당연히 Nuxt 문제인 줄 알았는데 Server 문제였다. 서버에 /api/posts 쿼리를 날려보니 다음과 같은 응답이 왔다.{ &quot;timestamp&quot;:&quot;2019-03-05T09:57:45.768+0000&quot;, &quot;status&quot;:500, &quot;error&quot;:&quot;Internal Server Error&quot;, &quot;message&quot;:&quot;Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection&quot;, &quot;path&quot;:&quot;/api/posts&quot;} DB 연결 실패..우아한 개발자 블로그 에서 비슷한 이슈가 있었는데,해결한 것을 보니.. 고생좀 하겠다 라고 생각하면서서버 EC2에서 DB로 psql 쿼리를 날렸다.-&amp;gt; 접속이 안된다.  뭔가 알 것 같았다.어제 RDS의 인바운드 그룹을 건드렸는데 실수로 EC2의 보안그룹을 지운 것이다. 해야할게 생겼다. 현재 Server 문제인데 Nuxt도 에러를 뱉어버린다. 서버가 문제일 경우 별도의 페이지를 만드는게 좋을 것 같다. 정상적으로 동작하지 않을 때 Noti가 와야 한다. EC2 보안그룹을 추가하는 대신, EC2의 Elastic IP를 추가하면 왜 안되는가? " }, { "title": "2019년 9주차 회고", "url": "/2019/03/04/2019%EB%85%84-9%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "캐시최적화", "date": "2019-03-04 00:00:00 +0000", "snippet": "이번주는 유의미한 시간을 좀 보낸 것 같다. 삼성전자 수원사업장 개발자 술 한 개발자를 만나면서 그 서비스에 일부분을 맡을 수도 있었으나 내가 망쳐버렸다. 서비스에 성능 / 비용 최적화를 위해서는 캐싱을 무조건 고려해야 한다.가격 대비 최적의 퍼포먼스를 뽑아내는 것이 돈을 절약할 수 있으니까.. 허나 지금까지 캐시에 대한 고민을 한 적이 없었다.개인 프로젝트가 하루 접속자 10 ~ 20명 정도라서 캐싱에 대한 고민을 할 계기도 없었다.어쨌든 이건 변명인 것 같고, 이번에 개발자 한명을 만나면서 부끄러운 시간을 가지게 된 것 같다.어쨌든 3일이 지난 지금 생각정리를 해보았다. 캐싱작업을 필요로 할 정도의 프로젝트를 해보자. 그러기 위해서 필요한 건 어떤 것이 있을까?공부할 게 많이 보였다. 1. JPA지금까지의 프로젝트는 테이블이 2개면 끝이었다.그래서 JPA에서 관계에 대해서 어떻게 대충 해결했지만,규모를 가진 프로젝트를 하려면 JPA에 대한 공부를 해야 한다.이는 백기선님의 JPA 강의를 좀 들으면 문제는 없을 것 같다. 2. HTML / CSS퍼블리싱을 공부를 해야 할 것 같았다.퍼블리싱 공부는 오래 걸리지 않을 것 같긴 하다. 3. 팀제일 고민되는 일이다.프론트 / 백엔드 개발은 혼자서 한다고 하더라도프로젝트 구상 / 디자인 / 홍보 를 혼자 잘 할 수 있을지 의문이다. 혼자하면 너무 외로울 것 같다. 개발팀이든 프로젝트팀이든 간에 이런 생각을 할 때마다 난 대학생 때 뭐 했나… 싶다. 4. 성능에 대한 고민이번에 좀 크게 느낀 부분이다.서버는 어떤 걸 쓸지, DB는 어떤 걸 쓸지 등을 고민해봐야 한다.서로의 장단점을 이해해가며 적절한 프로그램을 사용해야 하는데,나는 그냥 막무가내로 한 것 같기도 하다.그래서 개념적인 부분이 좀 미약했던 것 같다." }, { "title": "삼성전자 SW Vision Tour 후기 (CE, IM 부문)", "url": "/2019/03/03/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-SW-Vision-Tour-%ED%9B%84%EA%B8%B0-(CE,IM-%EB%B6%80%EB%AC%B8)/", "categories": "리뷰", "tags": "삼성전자, VisionTour", "date": "2019-03-03 00:00:00 +0000", "snippet": " 중식 / 사업장 투어 C-Lab 삼성전자(CE/IM부문) SW Vision 소개 SW 엔지니어와의 대화 알고리즘 공부방법 소개 삼성전자(CE/IM부문) 채용제도 소개 경품 추첨 및 기념품 지급삼성전자 SW Vision Tour 를 다녀 왔다.몇 달간 세미나를 안다녔는데 프레쉬(?)한 느낌을 받고 싶기도 했고,수원사업장이 궁금해서 가보고 싶기도 했다.  우선, 공지한 시간까지 영통역으로 집결하면 셔틀버스를 타고 사업장까지 데려다 준다. 영통역에서 셔틀버스가 각각 출발하기 때문에 앞자리에 앉고 싶다면 집에서 빨리 출발하면 된다. 도착해서 명찰을 받고 자리에 착석했다.자리에 종이가방이 있는데, 채용책자와 무선충전기가 들어있었다. 음료와 다과도 준비되어 있었다.밤을 새워서 많이 피곤했는지 아메리카노를 5잔 이상 마신 것 같다. 200분 정도 참석하신 것 같다.(사진은 직접 찍은게 아니라 삼성에서 받아서 썼다.)  중식 / 사업장 투어R5와 근처 공원을 둘러보았다. 동호회 실을 보여줬는데 검도, 탁구, 꽃꽂이, 캘리그라피 등 40여개의 동호회실이 있다.탁구와 검도를 하고 있는 임직원들을 볼 수 있었다. 수영장도 있다고 하던데, 직접 보진 못했다. 건물 내부에 은행, 대리점, 안경점, 카페 등이 있었다.밥도 맛있고, 필요한 물건도 쉽게 구할 수 있으니 사업장 안에서 계속 살아도 될 것 같은 기분이었다.  C-Lab삼성 직원들이 좋은 아이디어가 있으면 따로 연구를 할 수 있고, 삼성전자에서는 이를 지원해준다.성과가 좋으면 스타트업으로 독립할 수 있다고 한다. 삼성전자(CE/IM부문) SW Vision 소개CE : Consumer Electronics영상디스플레이사업부, 생활가전사업부IM : IT&amp;amp;Mobile Communications무선사업부, 네트워크사업부 휴대폰에서 아웃포커싱 기능도 Segmentation 을 이용해서 나타낸다고 한다.카메라의 하드웨어를 폰의 소프트웨어로 보완하는 격이다.그래서 소프트웨어 개발자가 많이 필요하다. 이모지, 구도 추천 기능, 아마존 쇼핑 등 좋은 이야기를 많이 해주셨는데 기억이 잘 안나서 아쉽다.노트북으로 타이핑하지 못한게 너무 아쉽다.  SW 엔지니어와의 대화삼성의 좋은점에 대해서 이야기를 많이 해주셨다.  알고리즘 공부방법 소개수많은 알고리즘 공부 방법이 있겠지만, 삼성전자에서는 어떻게 소개할지가 궁금했다.공부방법은 5단계로 나누어졌다.가장 중요한 단계는 1. 문제를 바르게 읽기 라고 했다. 완전 공감한다.문제를 잘못 읽고 떨어진 코딩테스트가 수차례 있었기 때문이다.사실 오늘도 문제를 잘못 읽어서 못 풀었던 문제가 있었다. 알고리즘 문제를 풀면서 또 한가지 중요한 것은 Try &amp;amp; Error 를 지양하는 자세다.Try &amp;amp; Error : 그냥 해보고 안되면 다른 방법으로 해보고…지양하라고 하는 이유가 당장 문제를 맞출지는 몰라도 논리적인 사고를 하지 않기 때문에장기적으로 보았을 때는 실력이 늘지 않아 손해다. SW 역량 테스트A형 : 전공자라면 누구나 풀 수 있을 정도B형 : 메모리 &amp;amp; 수행 시간을 최적화하며 코딩C형은 B형을 따면서 너무 재밌었던 사람만 도전하는 것을 추천하셨다.  삼성전자(CE/IM부문) 채용제도 소개기억나는 부분을 적으면 다음과 같다. 희망하는 부서로 지원 가능 계열사 중복 지원 불가 (ex. 삼성전자, 삼성SDS) SW역량 B형 합격자는 영역테스트 면제 SW역량 A형 합격자는 우대사항에 대해서 논의중 / 확정되면 아카데미에 공지할 예정 채용제도 세션은 개인적으로 아쉬움이 남았다.채용제도 소개가 30분인데, 삼성전자가 얼마나 좋은지를 홍보하는 시간이 많이 잡아먹은 것 같다.결국 채용제도에 스킵하는 부분이 있었고,질문도 많았으나 시간관계상 몇개 못 받았던 것 같아 아쉬웠다.  경품 추첨 및 기념품 지급경품도 준다.삼성 게이밍 키보드 (3명)삼성 게이밍 모니터 32인치 (2명)삼성 갤럭시 노트9 (1명)   3학년 때 학교 동기들과 여길 왔더라면 공부를 더 열심히 하지 않았을까…" }, { "title": "2019년 8주차 회고", "url": "/2019/02/25/2019%EB%85%84-8%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "네스프레소머신", "date": "2019-02-25 00:00:00 +0000", "snippet": "네스프레소 머신네스프레소 머신을 샀다.한국제품이 아니라 병행제품을 샀다. 이유: 싸다 주문한지 한달만에 도착을 했고, 얼른 커피를 먹어보고 싶었다.그런데 기계가 동작을 하지 않았다.판매처에 문의 했더니 네스프레소 고객센터에 전화하란다. 네스프레소 고객센터에 전화해서 증상을 말하니 해결법을 몇가지 알려주었다. 물통이 제대로 끼워졌는지 확인 물을 50% 정도 채우기 - 물의 수압 문제 멀티탭 제거 - 낮은 전력으로 인한 문제 AirLock - 새 제품의 경우 공기 때문에 물이 안나올 수 있음.(5~20회 추출) 이 때만 해도 잘 해결이 될 줄 알았다.허나, 위 방법으로 30분 정도 소모했고 여전히 커피는 안나옴. 다시 고객센터에 전화했더니 불량인 것 같다고 한다.국내 미발매 제조사라서 A/S가 안된다고 함.보상판매는 가능함. (고장난 기계를 반납하고 새 기계를 약간 싸게 사는 방식) 비슷한 제품을 보상판매로 구매하려면 20만원의 추가비용을 내야 한다.결국 36만원을 주고 사려니 어이가 없었다. 다시 판매처에 전화해서 상황을 말해주었더니 자기 회사로 보내라고 한다.회사가 독일에 있으니, 독일로 보내면 독일 네스프레소에 A/S 받아서 준다고 한다. 다시 독일로 보내면… 도대체 나는 커피를 언제 먹을 수 있단 말인가??돈도 돈이지만 이 커피머신에 내 멘탈이 흔들리는 것이 너무 싫었다.  솔직히 이건 내 부주의 일지도 모르겠다.평소에 병행제품이든 한국제품이든 짝퉁만 아니면 크게 신경을 안썼다.A/S 받으러 간 기억도 별로 없고… 그래서 이번에도 그냥 싼 곳을 찾아서 구매했다. 뽑기 운이 안좋은건 이번이 처음이다.한국 제품이 비싸더라도 전자제품은 그냥 한국에서 사야겠다." }, { "title": "최대값 구하기 - Array, List", "url": "/2019/02/20/%EC%B5%9C%EB%8C%80%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-Array,-List/", "categories": "Java", "tags": "", "date": "2019-02-20 00:00:00 +0000", "snippet": "1. Array int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 1. for int result1 = -1; for(int i=0; i &amp;lt; array.length; i++) result1 = Math.max(result1, array[i]); // 2. foreach int result2 = -1; for(int i : array) result2 = Math.max(result2, i); // 3. stream int result3 = Arrays.stream(array).reduce((a, b) -&amp;gt; a &amp;gt; b ? a : b).orElse(-1); System.out.println(result1); // 10 System.out.println(result2); // 10 System.out.println(result3); // 10  2. Collections List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 1. for int result1 = -1; for (int i = 0, length = list.size(); i &amp;lt; length; i++) result1 = Math.max(result1, list.get(i)); // 2. foreach int result2 = -1; for (int i : list) result2 = Math.max(result1, i); // 3. stream int result3 = list.stream().reduce((a, b) -&amp;gt; a &amp;gt; b ? a : b).orElse(-1); // 4. Collections int result4 = Collections.max(list); System.out.println(result1); // 10 System.out.println(result2); // 10 System.out.println(result3); // 10 System.out.println(result4); // 10" }, { "title": "다익스트라, 플로이드와샬 알고리즘", "url": "/2019/02/20/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/", "categories": "Algorithm", "tags": "", "date": "2019-02-20 00:00:00 +0000", "snippet": "1. 다익스트라 알고리즘다익스트라 - 위키백과 방문 순서 : 1 - 2 - 3 - 6 - 5 - 4 어떤 노드를 먼저 방문할거냐?distance가 가장 작은 노드부터 방문.=&amp;gt; 우선순위큐 필요함. 우선순위큐가 없어도 문제해결은 가능하지만 비효율적.우선순위큐를 안쓰면 시간초과인 문제도 있었던 것 같음. 간선이 적을 경우 노드 간의 거리를 배열로 구현간선이 많을 경우 리스트로 구현  계속하는 실수다익스트라 문제를 볼 때마다 프림 알고리즘이 떠오른다.그래서 PriorityQueue 우선순위를 간선의 비용으로 하더라.어떤 Node를 방문할지에 대해 각 Node의 거리에 따른 우선순위로!!  2. 플로이드 와샬 알고리즘3중 for문이때까지 플로이드 와샬로 풀었던 문제는 1~2개 정도인 것 같다.다익스트라는 특정 노드에서 출발하여 다른 노드까지의 최단거리를 구하는 알고리즘이었다면플로이드 와샬은 모든 노드와 노드 사이의 최단거리를 구하는 알고리즘. //플로이드 와샬 for (int k = 0; k &amp;lt; N; k++) { for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; N; j++) { map[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]); } } }" }, { "title": "Stream", "url": "/2019/02/20/Stream/", "categories": "Java", "tags": "", "date": "2019-02-20 00:00:00 +0000", "snippet": "알고리즘 문제를 풀면서 Java8 로 변형count// Basic int result = 0; for (int i = N+1; i &amp;lt;= N * 2; i++) { if (isPrime[i] == true) result++; } System.out.println(result);// Java8 System.out.println(IntStream.rangeClosed(N + 1, N * 2) .filter(x -&amp;gt; isPrime[x] == true) .count()); boolean[] isPrime = new boolean[MAX_N * 2 + 1]; Arrays.fill(isPrime, true); isPrime[0] = false; isPrime[1] = false;// Basic for (int i = 2; i &amp;lt;= MAX_N; i++) { if (isPrime[i] == true) { for (int j = i * 2; j &amp;lt;= MAX_N * 2; j += i) isPrime[j] = false; } }// Java8 IntStream.rangeClosed(2,MAX_N) .filter(i -&amp;gt; isPrime[i] == true) .forEach(i -&amp;gt; { for(int j = i * 2; j &amp;lt;= MAX_N * 2; j += i) isPrime[j] = false; });-&amp;gt; 에라토스테네스의 체는 낮은 소수부터 순차적으로 걸러야 한다.Stream이 병렬처리면 사용할 수 없다.parallelStream이 아닌 Stream은 순차적으로 수행한다.  성능 차이// Basic - 6ms for (int j = 1; j &amp;lt;= num; j++) isPrime[j] = false;// Java8 - 183ms IntStream.rangeClosed(1, num) .forEach(x -&amp;gt; isPrime[x] = false);for문에 비해 성능이 떨어짐.알고리즘 풀 때 2중 Stream쓰면 느린게 체감됨." }, { "title": "최소비용신장트리 - 프림, 크루스칼", "url": "/2019/02/19/%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC-%ED%94%84%EB%A6%BC,-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC/", "categories": "Algorithm", "tags": "", "date": "2019-02-19 00:00:00 +0000", "snippet": "최소비용으로 고속도로 만들기 프림 알고리즘프림 알고리즘 - 위키백과 시작 : D (아무데서나 시작해도 결과는 같음.)1) D - A (5 cost)2) D - F (6 cost)3) A - B (7 cost)4) B - E (7 cost)5) E - C (5 cost)6) E - G (9 cost)구현 : 우선순위 큐  크루스칼 알고리즘크루스칼 알고리즘 - 위키백과1) A - D (5 cost)2) C - E (5 cost)3) D - F (6 cost)4) A - B (7 cost)5) B - E (7 cost)6) E - G (9 cost)구현 : Disjoint Set (유니온-파인드)" }, { "title": "에라토스테네스의 체", "url": "/2019/02/18/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4/", "categories": "Algorithm", "tags": "", "date": "2019-02-18 00:00:00 +0000", "snippet": "에라토스테네스의 체 - 위키 10억(1024 x 1024 x 1024) 까지의 소수를 확인할 때 필요한 메모리boolean[] isPrime = new boolean[1024*1024*1024];boolean형 10억개 -&amp;gt; 1byte * 1024 * 1024 * 1024 -&amp;gt; 1GB힙메모리가 1GB 이상 필요함.  Q. 1 ~ 123456 소수 찾기 final int MAX_N = 123456; boolean[] isPrime = new boolean[MAX_N + 1]; Arrays.fill(isPrime, true); isPrime[0] = false; // 0은 소수 X isPrime[1] = false; // 1은 소수 X IntStream.rangeClosed(2, MAX_N) .filter(i -&amp;gt; isPrime[i] == true) .forEach(i -&amp;gt; { for (int j = i * 2; j &amp;lt;= MAX_N; j += i) isPrime[j] = false; }); System.out.println(isPrime[7]); // true" }, { "title": "2019년 7주차 회고", "url": "/2019/02/17/2019%EB%85%84-7%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "넷플릭스, 취업, 개발", "date": "2019-02-17 00:00:00 +0000", "snippet": "넷플릭스넷플릭스 계정을 친구가 알려줬다.일주일 동안 프리즌 브레이크 시즌1 ~ 5 까지 다 봤다.오늘 꿈에서는 감옥을 탈출하는 꿈까지 꿨다. 평소에 아이패드로 인터넷방송이나 유튜브를 켜놓긴 하지만..넷플릭스는 더 몰두하게 한다.  취업이번엔 서류가 떨어졌다.그 회사의 기술스택이 내가 사용했던 것과 같아서 최소한 알고리즘 시험은 칠 줄 알았는데..정말 가고싶은 곳이었고 당연히 될 줄 알았는데 서류탈락했다.그런데 탈락메일을 보아도 별 감흥이 없었다.알고리즘으로 떨어질 때는 뼈 맞은 것처럼 아팠는데서류라서 마음이 오히려 가벼워진 것 같다.  개발알고리즘 은 혼자 공부하기가 수월하다고 생각한다.고민하는 시간이 결국 자신의 사고능력을 키워준다. 데이터분석 같은 경우에도 수월하다.캐글을 보면 할건 천지니까.. 지난 2018년에 알고리즘과 데이터분석 공부를 포기했다.웹개발 에 집중하기 위해서였다. 웹, 서버 개발도 혼자 공부하기 수월한가?최근 인프런에서 Node.js 강의를 듣고 있다.강의를 들으면서 결국 Node.js 를 학습한다고 할 수 있는건 없다 는 생각을 했다.프로젝트를 해야 하는데 결국 만들게 있어야 하지.. 대학교를 다니면서 코딩과는 거리를 뒀기 때문에 취업 걱정이 있었다.프로젝트로 만회하고자 했었고, 결국 결과가 있어야 했다.이제와서 드는 생각은 차라리 알고리즘이나 데이터분석을 했으면 어땠을까 라는 생각이 들지만서도..이런 후회는 아무리 파고 파도 끝이 없다. 그래서 앞으로는 무엇을 할 것인지가 고민이 된다." }, { "title": "2019년 5,6주차 회고", "url": "/2019/02/10/2019%EB%85%84-5,6%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "중학생시절, 노트북고장", "date": "2019-02-10 00:00:00 +0000", "snippet": "중학생 시절원래 사람이 지난 추억을 모두 기억하진 못하지만, 나는 유독 기억을 잘 못하는 편이다.중학생 때를 떠올려보면 추억이 거의 없다.장난기가 많아서 재밌게 보냈던 것 같았다.하지만, 생각이 달라졌다. 이번주에 중학교 친구와 가볍게 맥주를 마시며 이런저런 얘기를 나눴다.내가 중학생 때 상처가 되는 말을 친구에게 했었는데, 그 친구는 10년이 넘은 지금도 기억하고 있었다.들어보면 차마 입에 담지도 못할 말이다. 그 말을 듣고는 잠시 멍하니 있었다.물론 난 기억이 안난다.그땐 미안했다고 사과를 할 수도 없었다.기억도 못하는데 사과가 무슨 의미가 있을까 싶었다. 나에게 중학생 시절이 재밌었고 그립다 라는 말은 이제 입밖으로 꺼낼 수 없다.  노트북 고장노트북으로 커뮤니티 크롤링을 돌려놓고 깜빡 잠들었다.아침에 일어나서 노트북을 켰는데 모니터가 보이지가 않았다. 몇번을 껐다켜도 그대로였다.심장이 요동쳤다.노트북이 없으니까 할 수 있는게 아무것도 없었다. 다행히도 노트북 메모리를 닦아주었더니 모니터가 다시 돌아왔다.컴퓨터 살 돈을 모아야겠다." }, { "title": "final은 immutable한가 ?", "url": "/2019/02/02/final%EC%9D%80-immutable%ED%95%9C%EA%B0%80/", "categories": "Java", "tags": "", "date": "2019-02-02 00:00:00 +0000", "snippet": " final은 키워드이고, Immutable은 패턴이다.final은 Immutable인가?아니다 final변수의 참조주소는 변경될 수 없다. immutable객체내부의 값들이 수정될 수 없다. String.class 는 immutable이다.String 객체는 한번 선언되면 그 값이 변경되지 않기 때문  ExampleString name = &quot;Bactoria&quot;;name = &quot;Junoh&quot;;“Bactoria”객체의 value가 “Junoh”로 변경된 것 처럼 보일 수도 있지만,아래처럼 이루어진다. final은 참조를 변경하지 못한다.final Stirng name = &quot;Bactoria&quot;;name = &quot;Junoh&quot;;이펙티브자바에서 변경 불가능 클래스는 String 과 같은 immutable class를 말한다.final이랑 헷갈리지말자.  참고자료What is the difference between immutable and final in java? - 스택오버플로우" }, { "title": "2019년 4주차 회고", "url": "/2019/02/01/2019%EB%85%84-4%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "식충이, 인간실격", "date": "2019-02-01 00:00:00 +0000", "snippet": "이제 27살이다. 식충이로 살고있는데.. 빨리 벗어나고 싶다.27살에 아직까지 뚜렷한 목표가 없다.어디서부터 잘못된건지 돌이켜 생각해보면 한없이 거슬러 올라가게 된다.사람마다 남들이 모르는 상처, 고통들이 많을 거고, 나에게는 이 생각마저도 그것들 중 하나일 뿐인 것이다.내가 40살이 되면 지금의 오늘의 일들을 떠올리지 못할 것이다.이렇게 기록으로 남아있는 것들은 흐릿한 기억이라도 남아있겠지만..정말 무엇을 해야 최선인지 모르겠다.오늘은 redis를 했는데, 왜했냐고 물으면..글쎼… 왜했을까? 그냥 궁금했는데.. 레디스가 뭔지 궁금해서 봤다 라고 하면 충분한 대답이 되는걸까..매순간 후회없는 행동을 하고 싶지만, 후회라는 것이 돌이켜보았을 때 깨닫는 것임을..시간이 지나고나야 다르게 행동했으면 더 나은 삶을 살았을거라는 생각에서 오는 것 같다.그래서 후회없는 선택이란건 참으로 어렵다. 후회없는 선택이 되려면 난 항상 성공하고 행복해야 후회가 없을 것이다. 하지만 현실적으론 불가능하지..돈이라도 있으면 여행이나 다녀오고 싶다. 계획없이 아무데서나 자고 아무거나먹고..해외에서 나혼자 동떨어져서 깊은 생각을 하고 싶다…음..쿠버네티스 한 이유경험하고싶다. 여러개.. 배포도.. 근데 나는못함… 경제적으로 안됨AWS하려면 인스턴스 여러개여야 함. 비용이 듬무료로 유일한 방법이 도커. 그래서 그냥 해볼려고 함.스왑..인간실격이란 책을 읽었다.요즈음 하루를 이상하게(??) 산다.인터넷방송은 10년 전인 고1 때부터 자주 보았었고, 나의 무료한 시간들을 즐겁게 해주었다.1년간 안보던 인터넷방송을 최근에 다시 보게 되었는데 완전 빠져버렸다. 최근 박문성 해설이 인터넷방송을 시작해서 축구 경기를 자주 본다.뿐만 아니라 심심하다 싶으면 침대에 누워서 인터넷방송을 켜서 보다가 그대로 잠들어버린다.다음날 일어나면 피로도 안풀리고 몸이 무거워지는 것을 느낀다. 동영상 매체가 나쁜 것은 절대 아니다.궁금한게 있으면 이젠 지식인이 아닌 유튜브로 검색하니까..영상으로 보는 것이 더 도움이 된다. 허나, 누군가 내게 아무 생각없이 하루를 보낼 수 있는 방법이 있냐 ? 라고 묻는다면 인터넷방송이 딱이라고 답할 것이다.지난 일주일동안 인터넷방송에 빠져서 좀비처럼 지낸 것 같다.깃허브의 잔디도 텅텅 비어있다.. 큰 계기가 없으면 다음주도 시간을 흘려보낼 것 같다.시간이 한참 지나서 이번주의 시간들을 내가 어떻게 생각할지도 궁금하다." }, { "title": "2019년 3주차 회고", "url": "/2019/01/24/2019%EB%85%84-3%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "기억조작방지, 피드백", "date": "2019-01-24 00:00:00 +0000", "snippet": "내가 가장 열정적으로 코딩하던 순간은 1년 전, 백준 알고리즘 문제를 풀 때 였다.당시 알고리즘만 죽어라 했었고, 그 때 처음 개발에대한 흥미를 느꼈다. 그 후로 프로젝트를 할 때마다 그 때만큼의 열정으로 개발한 경우가 없었던 것 같다.개발이 재미가 없었던 것은 아니지만 알고리즘 할 때에는 하루 단위로 뿌듯하고, 빨리 자고 일어나 코딩하고 싶다는 생각을 하며 침대에 누워서도 알고리즘을 떠올리며 잠들었던 시절이었기에 확실히 그 때보다는 덜했다.그 이유에 대해서는 다음과 같은 결론을 내렸었다. 웹개발보다 알고리즘이 내 적성에 맞나보다. 아니면 그 당시에는 동기부여가 좀 더 있었던 것 같다. 이번주에 그 생각이 좀 바뀌었다. 지난 10월에 있었던 OKKY 컨퍼런스 TDD 제대로 알기의 강연들이 유튜브에 올라왔었는데Q&amp;amp;A에 이런 내용이 있었다. TDD는 삶의 만족도를 높여준다. 매 분 단위로 피드백을 받기 때문에 직무탈진의 정도를 낮춘다고 한다. 이 말을 듣고 알고리즘이 떠올랐다.  문제를 풀고 나서 다른 사람의 코드를 보며 피드백을 받는 과정에서 흥미를 느낀게 아닐까 ?알고리즘이 내 적성에 맞는 것이 아니라, 그저 피드백이 있었기에 거기에 빠진 것이다.다른 사람도 알고리즘에 쉽게 빠져들었을 것이라 생각하니 내 열정이 시시해보였다. 어쨌든 피드백이 그만큼 중요하다는 것인데, 회고에도 피드백이 있다.내가 회고를 쓰는 이유에는 2가지가 있다. 1. 기억 조작 방지정보라던지, 친구들이 했던 말 등이 내 기억속에서는 조금씩 변형되고 있었음을 대학교를 다니면서 많이 느꼈다.내 기억력은 믿을게 못된다. 2. 피드백매순간 사건 &amp;amp; 사고를 겪지만, 다시 돌아보는 경우는 거의 없다.일주일마다 적는 이 회고는 지난 일주일을 되짚어보게 한다.회고를 적는 이유는 피드백과 성장에 대한 기대라고 할 수 있다." }, { "title": "javax.Validation으로 request 검증하기", "url": "/2019/01/22/javax.Validation%EC%9C%BC%EB%A1%9C-request-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0/", "categories": "Spring", "tags": "", "date": "2019-01-22 00:00:00 +0000", "snippet": "API를 구현할 때, post 메소드로 body에 데이터를 받는다.이 때 값들이 유효한 값인지를 검증하여 유효하지 않으면 bad request를 보낼 수가 있다.간단하고 유용하게 사용할 수 있는 것이 javax.validation.constraints에 있는 애노테이션들이다.spring-boot-starter-web 의존성을 추가할 경우에는 딸려 들어온다. 1,2,3의 값 만을 받아야 하는 priority 필드가 있다고 하면이 때 아래처럼 사용하면 됨.UpdateTodoRequestDto.class@NoArgsConstructor@Getterpublic class UpdateTodoRequestDto { @NotNull(message = &quot;우선순위를 입력해주세요.&quot;) @Min(value = 1, message = &quot;우선순위는 1~3 사이의 값이어야 합니다.&quot;) @Max(value = 3, message = &quot;우선순위는 1~3 사이의 값이어야 합니다.&quot;) private Long priority; //...}  TodoController.class@Slf4j@CrossOrigin@RestController@RequestMapping(value = &quot;/api/todos&quot;, produces = &quot;application/hal+json&quot;)public class TodoController { @PutMapping(&quot;/{id}&quot;) public int updateTodo(@PathVariable Long id, @Valid @RequestBody UpdateTodoRequestDto dto) { log.info(&quot;PUT :: /api/todos/&quot; + id + &quot; dto :: &quot; + dto); return todoService.updateTodoWithTitleAndContentAndClosingDateAndPriority(id, dto); } ...}Controller에서 dto 앞에 @Valid 를 추가 해주어야 적용 됨.  request response  가공하기위의 response처럼 모든 데이터를 응답하지 않고 특정 필드만 응답할 수 있다.예를들어, message와 field만을 전송하고 싶다면 다음과 같이 예외처리를 해주면 된다.@ControllerAdvice // 빈등록public class GlobalExceptionHandler { @ExceptionHandler public ResponseEntity&amp;lt;String&amp;gt; notValidException(MethodArgumentNotValidException e) { ErrorDetails errorDetails = new ErrorDetails( e.getBindingResult().getFieldError().getField(), e.getBindingResult().getFieldError().getDefaultMessage()); return new ResponseEntity(errorDetails, HttpStatus.BAD_REQUEST); } @Getter private class ErrorDetails { private String field; private String message; public ErrorDetails(String field, String message) { this.field = field; this.message = message; } @Override public String toString() { return &quot;ErrorDetails{&quot; + &quot;errorField=&#39;&quot; + field + &#39;\\&#39;&#39; + &quot;, message=&#39;&quot; + message + &#39;\\&#39;&#39; + &#39;}&#39;; } }} request response간결해졌다.  테스트TodoControllerTest.class@RunWith(SpringRunner.class)@WebMvcTest(TodoController.class)public class TodoControllerTest { @Test public void 우선순위가_4인_Todo_저장요청시_BadRequest() throws Exception { //given SaveTodoRequestDto dto = SaveTodoRequestDto.builder().title(&quot;제목&quot;).content(&quot;내용&quot;).priority(4L).build(); //when mockMvc.perform(post(&quot;/api/todos&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(jsonStringFromObject(dto))) //then .andDo(print()) .andExpect(status().isBadRequest()) .andExpect(jsonPath(&quot;$.message&quot;,is(&quot;우선순위는 1~3 사이의 값이어야 합니다.&quot;))); }}" }, { "title": "Nuxt.js 배포", "url": "/2019/01/18/Nuxt.js-%EB%B0%B0%ED%8F%AC/", "categories": "Deploy", "tags": "", "date": "2019-01-18 00:00:00 +0000", "snippet": "작년 초, 개인블로그를 만들었다.당시 jojoldu님의 스프링부트로 웹 서비스 출시하기의 도움을 많이 받았다. 블로그 인프라Backend는 git push하면 배포까지 자동화였지만,Frontend는 EC2 인스턴스 내에서 빌드를 하였고,메모리 부족으로 인스턴스가 뻗어버리는 경우가 종종 있었다. 이에, 빌드하기 전에 서버를 종료시키고 메모리를 최대한 확보한 뒤 빌드를 하곤 했다.어제는 이 방법으로도 뻗어버렸다. 그래서 배포 자동화를 하기로 했다. 바뀐 블로그 인프라이제 Travis에서 빌드를 해준다.  Travis Branches배포할 때 새로운 브랜치를 만들어서 진행했다.36번의 뻘짓 이후에 배포자동화를 할 수 있었다. 뭐한다고 36번이나 빌드했을까….  Amazon S3배포할 때 EC2인스턴스로 보내야 할 파일이 무엇인지 명확하게 몰랐다.폴더 전체를 보내기에는 node_modules의 용량이 컸고, node_modules 폴더만 빼자니 적절한 zip 명령어를 찾지 못했다.결국 배포에 필요한 파일들을 쭉 나열했다. zip -r myBlog-Front .nuxt package.json static before-deploy.sh after-deploy.sh appspec.yml스크립트 이름을 계속 바꾸곤 했는데 .travis.yml에서 이름을 안바꿔줘서 배포 실패를 여러번 겪었다… 여기서 시간을 많이 낭비했다.  appspec.yml# CodeDeploy 버전 설정 (프로젝트버전이 아니기 때문에 0.0 이외에는 오류남)version: 0.0os: linuxfiles: - source: / #S3 버킷에서 복사할 .zip 위치 destination: /home/ec2-user/app/front/build/ #붙여넣기 할 위치hooks: BeforeInstall: - location: before-deploy.sh # 배포 이전에 실행시킬 스크립트 timeout: 180 runas: root AfterInstall: - location: after-deploy.sh # 배포 이후에 실행시킬 스크립트 timeout: 180 runas: root after-deploy.sh (배포 실패)#!/bin/bash /home/ec2-user/app/front/after-deploy.sh &amp;amp;after-deploy 스크립트는 배포파일을 받은 후, 서버를 실행시킨다. 잘 될 것 같았다.하지만 180초 이후에, 배포는 실패한다.이 스크립트는 180초 이내에 완료되어야 하기 때문이다.결국 180초 동안 서버가 돌아가고, 이후에는 배포 실패와 함께 서버가 종료된다.백그라운드 실행이라 상관없을 줄 알았는데 아니었다. after-deploy.sh (배포 성공)#!/bin/bash /home/ec2-user/app/front/after-deploy.sh &amp;gt; /dev/null 2&amp;gt; /dev/null &amp;lt; /dev/null &amp;amp;해결책은 aws 문서에 있었다.입력,출력,에러를 다 null로 보내버린다..이러면 after-deploy.sh 내용에 상관없이 스크립트를 실행시키는 순간 배포 성공이 떴다.쿨한 녀석이다..  배포자동화는 이번으로 3번째다.방식은 똑같은데 오랫만에 하니 가물가물했다.4번째 배포자동화때는 빨뤼빨뤼 하고싶다.무중단 배포는 사용자가 별로 없어서 할 생각이 아직 안든다" }, { "title": "2019년 2주차 회고", "url": "/2019/01/13/2019%EB%85%84-2%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "NTS탈락, 구글클라우드잼, 결혼식", "date": "2019-01-13 00:00:00 +0000", "snippet": "1. NTS 인턴 떨어짐월요일에 탈락소식을 듣고 계속 침대에 누워있었던 것 같다머리도 식힐겸 일주일동안 아무것도 안하기로 함 2. 구글 클라우드잼 쿠버네티스쿠버네티스도 월요일 시작이라..그래도 10개 강좌중 3개정도 실습했다 3. 결혼식토요일에 사촌형 결혼식을 다녀왔다오랫만에 친척들 보니까 기분이 많이 풀렸다이번 주에는 정신적으로 힘들었던 것 같다물론, 이 또한 시간이 해결해주었다3주차 때는 구글 클라우드잼 끝까지 실습하는 것이 목표다다음 공채시즌까지 시간이 많으니 뭔가 전문적으로 파고 싶다Spring Boot, Node, Vue, 쿠버네티스, redis…" }, { "title": "2019년 1주차 회고", "url": "/2019/01/07/2019%EB%85%84-1%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "NTS시험, 구글클라우드잼, 개발블로그, 이펙티브자바", "date": "2019-01-07 00:00:00 +0000", "snippet": "1. NTS 알고리즘 시험침 총 4문제 - 2시간 제한 45분동안 3문제 품 1시간15분동안 1문제를 풀지 못함. 원인 : 문제 이해를 잘못 했음… 상당히 쉬운 문제였음.  이 쉬운 문제를 못 풀었다는 생각에 자존감이 너무 떨어졌다.알고리즘을 풀면서 문제를 잘 못 읽어서 실수한 경우가 많은데도 불구하고중요한 시험에서 또 실수를 해버렸다.시험이 끝나고 멘붕이 옴.멘붕이 오니 마음이 급하고 초조했음.초조한 이유는 내가 실력이 없어서 마음에 여유가 없어서라고 생각도 해봤음.그날 저녁에 인터스텔라를 봤다.우주를 보니 마음이 조금은 가라앉더라..코딩테스트 발표도 안났는데 면접준비 보다는 면접과 관련없는 것들을 일부러 찾아서 함.redis 문서나 읽고 있음.. 2. 구글 클라우드잼 신청Google Cloud를 이용하여 쿠버네티스 사용하는 강좌같음영어로 된 강의라고 함.. 젠장!! 1/7 시작1/27 까지 퀘스트 완료하면 수료 기념품 준다고 함. 3. 개발 블로그 선택 1) 깃허브 테마 활용하여 편함. 마크다운 용이함. 어쨌든 css 수정 필요함. 2) 티스토리 글 작성하기 쉬움 마크다운 사용하기위해서는 별도의 작업 필요 3) bactoria.me 애정이 생김 자유도 높음 그러나 그만큼 할게 많아짐. 클라우드 관리도 필요함. 소액의 돈이 주기적으로 필요함 (도메인, 클라우드)  결국 bactoria.me 로 선택함.. 이유는 글쎄…. 갑자기 생각이 안난다. 4. 이펙티브 자바 3E최근에 또 이펙티브자바를 안보는 것 같음.솔직히 좀 어려움.실제로 안써봐서 머리에 잘 안들어오는 것 같기도 함." }, { "title": "2018년 1년 회고", "url": "/2019/01/07/2018%EB%85%84-1%EB%85%84-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2019-01-07 00:00:00 +0000", "snippet": "2018년 회고 2015년부터 2017년까지 나는 개발을 업으로 삼지 않겠다는 다짐으로 살아왔다.개발자에 대한 나의 편견은 이랬다. 고생만 한다. 컴퓨터만 뚝딱뚝딱치다가 하루가 끝난다. 자신만의 인생이 없다.당시 부모님이 주신 용돈으로 친구들이랑 술만 퍼먹으면서전공을 직업으로 삼지않는 나의 못된 변명이었다.  2018년 초, 삼성 알고리즘 역량테스트를 친구가 쳐보라는 말에호기심으로 알고리즘을 공부하였고, 문제를 풀면서 개발에 대한 흥미를 느끼기 시작했다.(부끄럽지만 컴퓨터공학을 전공하면서 개발에 대한 흥미를 이 때 처음 느꼈다.)  유튜브의 나는프로그래머다, 케빈TV 등을 보며 개발자들의 생활, IT업계의 판도 등을 어깨너머로 느낄 수 있었다.유튜브, 페이스북 타임라인, 개발자 회고 등을 보며 느낀 것이 있다.개발을 좋아하는 사람은 그 사람들끼리 뭉치고, 그렇게 더욱 더 성장하는.. 그런 인프라?? 라는게 있어보였다.세상은 넓은데…. 내가 이 개발자들 사이에 비좁고 들어갈 틈도 없어보였다.나도 언젠가는 그 무리에 끼어서 대화도하고, 밥도 먹고, 개발도 같이 하기를 꿈꾸었다.(그 당시 할 줄 아는것도 없고, 해온것도 없는 내가 욕망이 너무 앞섰던 것 같다.)결국 나만의 블로그를 만들어서 차곡차곡 공부하며 포스팅하면언젠가는 이들 곁에 다가가리라 라고 생각을 했다. 봄나의 첫번째 개인 프로젝트인 블로그를 만들기 시작하여5월 경에 완성했다.개인 블로그라서 티스토리보다 포스팅을 많이 하게 될 줄 알았는데오히려 더 불편했다.이 프로젝트는 블로그보다는 나에게 개발을 할 수 있도록용기내게 해준 프로젝트 정도로 생각하고 있다.  그렇게 블로그 개발이 끝나고 또 다른 목표가 생겼다.바로 우아한형제들의 우아한테크캠프였다.하지만 결국 탈락했다.불합격 통보를 받고는 진짜 세상이 허망했다. 여름대전에서 열린 딥러닝 컨퍼런스에 서포터즈 활동을 하게 되었고,운 좋게도 연사분들과 저녁식사를 함께 할 수 있었다.다들 세상에는 자신의 분야에 매진하는 사람처럼 보였다. 얼마 뒤 파이콘에서 자원봉사를 하면서다른 자원봉사자들과의 소통했을 때도 비슷했다.열심히 해야겠다는 생각을 갖게 해주었다.스탠포드의 CS231n 강의를 들으며여름에는 나름 딥러닝 공부만 했던 것 같다. 가을개강을 했다.곧 졸업을 한다는 생각에 마음이 싱숭생숭했다.딥러닝을 계속 공부하면 석사를 준비해야 하는데성적이나 경제적으로 여건이 되지 못했다.또한 내가 딥러닝 분야에 끼어들면개발하는분들에게 오히려 피해를 줄 것 같다는 생각이 들었다.그래서 딥러닝은 접기로 했다.  다시 웹서비스 개발을 생각했다.그동안 블로그를 개발하면서 미흡했던 점을 생각해보았다.개발은 했지만, 내가 공부하면서 제대로 개발을 한건가? 의구심이 들었다.개발하기에 급급해 정작 이론적으로 뭐 깊이있게 아는게 없었다.그래서 공부를 좀 더 하기로 했다.  마침 인프런에 백기선님의 스프링부트 강의를 알게 되었다.평소 백기선님의 유튜브를 보면서 도움을 많이 받았기 때문에바로 구매하며 공부했다. 공부하다가 할만한 프로젝트를 찾고 있었다.그러다가 신세경씨가 유튜브한다는 소식을 듣고 번뜩 떠올랐다.유튜브하는 연예인들을 다른사람들은 궁금하지 않을까..?하는 마음에 웹사이트를 만들었다. 겨울겨울이 된 지금 취업준비를 하고 있다.  내가 대단한 사람은 아니지만올해 초의 친구의 알고리즘 역량테스트 권유 한마디가지금의 나를 만든 것 같아, 고맙고 다행으로 생각한다." }, { "title": "페이스북 이노베이션 로드쇼 X 부산대학교 정리", "url": "/2018/11/06/%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%A1%9C%EB%93%9C%EC%87%BC-X-%EB%B6%80%EC%82%B0%EB%8C%80%ED%95%99%EA%B5%90-%EC%A0%95%EB%A6%AC/", "categories": "리뷰", "tags": "페이스북, 부산대학교", "date": "2018-11-06 00:00:00 +0000", "snippet": "Tim Bill 1.집중 영향력 리팩터링, UI 수정하는 작업 경우에 따라 영향력이 클 수도있고 적을 수도 있음. 어떤 행동이 영향력 있을지를 항상 생각 할 것. 2004년의 페이스북에는 수익모델이 없었음. 당장의 수익모델이 중요하지 않았음 대신 더 많은 사용자를 모으는데 집중함. 2.신속하게 움직여라 마크주커버그씨는 아이디어를 떠올리고 바로 실행에 옮김 즉시 행동으로 옮기지 않았다면 다른 누군가가 먼저 만들었을 수 있음. 3.누구에게나 열려있는 자신의 아이디어를 뺏길까봐 혼자 알고있을 수 있음. hacker 문화는 열려있는 문화임 아이디어 공유함으로써 아이디어가 개선되고 발전됨 훨씬 더 건강하고 가치있는 문화 workFacebook 4.대담하게 행동하라 즉시 행동으로 용기 : 두려움이 있는 상태에서도 실행하는게 용기 2006년 야후가 10억 달러에 페이스북 인수 제안을 함 거절. 당시 주커버그 20살 5.사회공헌 페이스북 모토 돈을 버는것이 아님 전세계 사람들을 가까이 연결시키는 것 페이스북의 개발 더 좋은 사회를 만들려고 노력함 Facebook Safety Check (수익창출 X)  Hacker WayDone is better than perfect=&amp;gt; 먼저 실행에 옮겨라!하지만 페이스북의 신속하게의 슬로건 안에서는완벽보다는 속도가 중요함을 말해줌.물론 품질도 중요함.하지만 이것을 완벽하게 해낼지.. 빨리 해낼지.. 골라야 한다면?=&amp;gt; 빨리 해낼것을 권장함. 여러분의 제품, 아이디어가 완벽하게 보이진 않을 수 있겠지만먼저 내보이는 것이 중요하다고 말하고 싶다.  Code wins arguments=&amp;gt; 코드가 논쟁을 이긴다!100번의 토론보다 시제품 만드는 것이 더 효과적임  “The Hacker Way is an approach to building that involves continuous improvement and iteration. Hackers believe that something can always be better, and that nothing is ever complete.”— Mark Zuckerberg" }, { "title": "가을의 푸념", "url": "/2018/09/14/%EA%B0%80%EC%9D%84%EC%9D%98-%ED%91%B8%EB%85%90/", "categories": "회고", "tags": "", "date": "2018-09-14 00:00:00 +0000", "snippet": "벌써 9월이다. :smile:대기업 공채는 한창 진행중이다.주변에는 다들 자소서를 바쁘게 쓰고 있다.그동안 감기에 시달려서 누워만 있다가 나도 공채에 자소서를 써야겠더라. 문항을 보니공모전 수상경험?없는데… 학교, 대외활동 프로젝트?도 없는데… 물론, 수업시간에 만들었던거나 졸업작품으로 아두이노 했던 건 있는데이런걸 자소서에 적기엔 너무나도 보잘 것 없다 싶어서 적지 않았다. 그러다 보니 자소서에 적을 것이 없다.한참을 생각하다가 2018년 하반기 공채는 흘려보내기로 했다. 이런식으로 있다가는 2019년 상반기 공채에도 그냥 지나가겠다 싶어서뭐라고 해야겠다는 생각이 드는 찰나에 또 나쁜 마음 이 들었다. 굳이 …?그냥 지금 그대로 하던거 계속 하면 안되나 ?어제 카페 코딩이 재밌었고 행복했는데매일 카페에서 코딩하면서 있으면 안되나 ?공모전을 굳이 나가야 하나 ?공모전만이 나의 가치를 증명하는 방법일까 ?그럼 난 4년 동안 다른 무엇을 하였나 ?왜 갑자기 이제 와서 ?세상 물정 모르다가 이제 학생이라는 방어벽이 사라지니까 마음이 조급해지는건가 ?난 도전정신이 없는건가 ?아니면 지금으로도 살만하기에 가만히 있는 것인가 ? 이런생각이 계속 든다…이런 생각은 누구나 했을 것이다.다만 여기서 어떤 결정을 내리느냐에 따라누군가는 앞으로 한발 나아가고, 누군가는 뒤로 한발 물러서는 것일 뿐난 아직도 잘 모르겠다. 뭔가 공모전을 하고싶어도 주력이 없다.블록체인, 딥러닝, 알고리즘 뭐 하나 미친듯이 판게 없는것 같다.그냥 1~2달 동안은 미친듯이 하다가 마음이 식는 것 같다.운이 없어서일까? 아니면 이것이 내가 살아가는 방식인걸까?하긴 뭐 3년 동안 개발에 대해 생각없이 그저 학교만 다니다가갑자기 이것 저것 해보고 싶은게 많아지니까 그랬나 싶다. 나는 어떤일을 하게 될까 ?" }, { "title": "1st 함께하는 딥러닝 컨퍼런스 후기", "url": "/2018/06/29/1st-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%9B%84%EA%B8%B0/", "categories": "리뷰", "tags": "", "date": "2018-06-29 00:00:00 +0000", "snippet": "안녕하세요. 2018. 06. 28 대전 UST에서 열린1st 함께하는 딥러닝 컨퍼런스 를 다녀왔습니다.운 좋게도, 서포터즈 자리가 남아있어서 서포터즈로 활동하게 되었습니다.여기에는 일기처럼 저의 느낀 점을 간단하게 적으려고 합니다.세션마다 필기를 못 해서 포스팅 할 건 없네요…ㅠ딥러닝 컨퍼런스 관련한 내용을 보러 오셨다면 김태영 케라스 블로그 를 봐주세요!!연사분들의 소개와 값진 발표자료들이 있습니다.  이번 컨퍼런스에 신청하게 된 계기는 딥러닝에 대한 전반적인 지식을 습득하고,개인 프로젝트용 아이디어 구상 목적이었습니다.( 딥러닝.. 제가 깊이 들어갈 것 같진 않습니다. ㅜ ) 딥러닝에 무지하다 보니 있는 듯 없는 듯 조용히 지원만 하려고 했었는데요.그러다 보니 적극적으로 인사를 나누지 못한 것이 아쉬움으로 남습니다.개발 쪽으로 일하다 보면 언젠가는 다시 뵐 수 있지 않을까요 ?전자, 화학, 의학 등 딥러닝을 적용할 분야의 도메인 지식을 알고 있는 것도 중요하다고 느꼈습니다.기억은 안 나지만, 어느 분이 그렇게 말씀해주신 것 같아요. ㅠㅠ마치 DB 개발자가 업무를 알아야 하는 것과 비교할 수 있을까요..대학 시절 선형대수학, 이산수학 등 열심히 할걸… 이라는 생각도 들긴 했습니다ㅋㅋ재미 없는걸 어떡해.. 컨퍼런스가 끝나고, 회식 자리에 갈까 말까 고민했었는데 안 갔으면 후회할 뻔했습니다.자기 자신만의 관심사에 열정을 쏟으면서 일궈낸 것들을 공유하는 모습이 너무 좋았던 것 같고요.저는 묵묵히 듣기만 한 것 같네요ㅋㅋ감히 여기 실명을 거론하기가 망설여지네요. 마음속으로 간직하겠습니다.딥러닝 연구하는 분들은 정말 대단하신 것 같습니다.  끝으로..지금 부산에 내려와서 후기를 끄적이고 있는데,정말 보람찬 긴 하루였습니다. 일생의 하루하루가 오늘과 같다면 얼마나 좋을까요.불과 몇 시간 전에 연사분들과 식사를 했던 것이 실감이 나지 않습니다. 부산으로 돌아오니 모든 것이 꿈만 같습니다.딥러닝에 관심 있으시면 컨퍼런스 참가하시면 도움을 많이 받을 수 있을 것 같고요.서포터즈로 활동하시면 더 좋은 경험 하실 것 같습니다.그럼 20000." }, { "title": "2018년 1, 2월 회고", "url": "/2018/03/02/2018%EB%85%84-1,-2%EC%9B%94-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "개발을직업으로", "date": "2018-03-02 00:00:00 +0000", "snippet": "대학생활을 하면서 개발 일은 절대 직업으로 삼지않겠다 다짐하고행복을 찾아 워킹홀리데이를 생각중이던 나였는데.. 삼성S/W A형 Test를 준비하기 위해 Java로 백준 알고리즘 문제를 풀었다. 삼성전자 들어갈 일이야 없겠지만 이런것도 한번 쳐보고 싶었다 랄까…DFS문제만 좀 풀 줄 알면 통과하는 테스트였는데 탈락했다. 그 후로 알고리즘 문제가 너무 재밌어서 문제를 풀다보니 1달간 200문제를 풀게 되었다. 평소에 자기전에 유튜브를 챙겨보는데 우연히 나프다를 보게 되었고, 열정 넘치는 많은 개발자들을 볼 수 있었다.특히 호주에서 프로그래밍 방송하시는 분이 있는데, 그 분의 방송을 보다가 타고 타고해서 어떤 개발자를 알게되었다.대기업에 입사하여 지금은 Naver Labs에서 근무하고 계신 분이었다.몇 일후 페이스북 타임라인에서 그 분의 열정은 느낄 수 있었다. 개발자가 끊임없이 공부하는 것이 무엇인지를 체감할 수 있었다.너무너무너무너무 멋있었다. 선망의 대상이고, 나의 롤모델을 찾은 느낌이랄까.그분은 회사 출근하기 전 새벽 4~5시에 일어나서 자기개발을 하는 분이다. 또한 자기 자신만 그런것이 아니라 페이스북 그룹을 만들어 운영하고 있다.관리자가 글을 게시하면 구성원들이 자신의 할 일을 댓글로 적는 방식이다. 새벽부터 출근 전까지…나도 몇일전에 가입신청을 했는데 바로 가입되었다. 가입된 것을 보고, 그분들과 같은 그룹에 소속됬다고 생각하니 황홀했다.사람은 자신이 이때까지 생활해왔던 환경과 주변인들의 영향을 많이 받는다는 것을 요새 다시 느끼고 있다. 그래서 주변 사람들에게 좋은영향을 미치는 것은 결국 나에게로 돌아온다. 선순환인 것이다. 나는 지금 마음이 식지않고 점점 더 부풀어오르기를 바란다. 그래서 이번 2월 23일에 Naver Factory에서 진행하는 오픈소스 세미나를 참가할 계획이다. 많은 개발자들과 대학생들이 참여하는데 기대된다. 부산에서 참석하느라 지출이 꽤 크지만 여유가 된다면 세미나는 꼭 참석하고 싶다.이랬다가 정작 일년뒤면 요리하고 있을지도 모르겠다. 정말 사소한 것 하나에 삶이 완전 달라지는게 인생이니까.내가 약간 흐트러졌을 때 그런것을 최대한 방지하고자 이 글을 남겨봤다." } ]
