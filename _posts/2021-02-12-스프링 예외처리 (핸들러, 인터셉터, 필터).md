---
layout: post
title: "스프링 예외처리 (핸들러, 인터셉터, 필터)"
date: 2021-02-12 16:36:39
categories: Spring
author: bactoria
---

스프링을 공부하다보면 아래와 같은 사진을 자주 접했었다. 


<img width="500" src="https://user-images.githubusercontent.com/25674959/107618928-ae972500-6c95-11eb-8de9-a536de83004b.png">

이 사진을 유심히 보면 아래와 같은 궁금증이 생긴다.   
- 1) `HandlerInterceptor` 에서 예외가 발생하면 어떻게 될까?
- 2) `Filter` 에서 예외가 발생하면 어떻게 될까?

이 글은 아래 내용을 다루고자 한다.  
- `핸들러 안`에서 예외가 발생하는 경우 어떻게 처리할까 ?
- `핸들러 밖`에서 예외가 발생하는 경우 어떻게 처리할까 ?
  -  `HandlerInterceptor`에서 예외 발생
  -  `Filter`에서 예외 발생

**용어정리**  
`핸들러` 는 컨트롤러(controller) 에서 @RequestMapping 어노테이션이 붙은 메서드를 의미로 사용함.   
`핸들링` 은 에러를 회복한다는 의미로 사용함.  

---

## 1. 핸들러 안에서 예외가 발생하는 경우 어떻게 처리할까 ?

### 핸들러 안에서 예외가 발생하는 경우 예시

핸들러 안에서 **비즈니스 로직** 을 수행하면서 다양한 예외( `DB 요청` / `다른 API 요청` / `외부 라이브러리 사용` 등) 가 발생할 수 있다.

&nbsp;

**1) 비즈니스 로직에서 발생하는 예외의 경우**
```java
@Service
@AllArgsConstructor
public class ChannelService {

    // ...

    public Channel getChannel(String channelId) {
        return channelRepository.findById(channelId).orElseThrow(ChannelNotFoundException::new); // channelId로 채널을 찾지 못하면 예외 발생
    }
}


public interface ChannelRepository extends JpaRepository<Channel, String> {
    Optional<Channel> findById(String id);
}
```

**어떻게 처리할까?**

클라이언트가 API서버에 채널id로 채널정보를 요청하는 부분이라고 가정해보자.  
그렇다면 사용자가 요청한 채널id는 존재하지 않는 경우이니, 이를 잘 표현하는 HTTP 상태코드와 본문을 반환하는 것이 이상적일 것이다.  

&nbsp;

**2) 외부 라이브러리 에서 예외를 발생하는 경우**
```java
package org.apache.commons.lang.math;

import ...

public class NumberUtils {
    public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException("A blank string is not a valid number");
        }  

        // ...
    }

    // ...
}
```

`createNumber(String str` 는 문자열로 들어있는 숫자를 Number 타입으로 변경시켜주는 라이브러리이다.  
(eg. `NumberUtils.createNumber("12345")`)

`NumberUtils.createNumber("abcde")` 로 인자에 숫자로 변형이 불가능한 값이 오는 경우 `NumberFormatException` 이 발생한다.  

이 라이브러리를 핸들러 내부에서 잘못 사용하는 경우에는 `NumberFormatException` 발생할 것이다.

&nbsp;

**어떻게 처리할까?**

예외가 발생하면 위의 `1)` 의 예시처럼 적절한 HTTP 상태코드와 본문을 반환할 수 있다.

하지만, 아래의 방법으로 처리하는 것도 가능하다.

```java
    // ... 비즈니스로직
    private int parseInt(String number) {
        int result = 0;
        try {
            result = NumberUtils.createNumber(number); // Apache Commons Library
        } catch (NumberFormatException e) {
            log.error(e.getMessage(), e);
        }
        return result;
    } 
```

비정상적인 값을 숫자로 변경하려고 할 때 외부 라이브러리(NumberUtils)에서는 예외를 발생시키지만, 
위 로직은 예외가 발생하면 0 값으로 처리하고 있다. 

`val numberA = parseInt("abc") // numberA는 0이다.`

위의 경우 잘못된 숫자("abc") 를 입력하여 NumberUtils에서 예외가 발생하지만, 결과는 0이 된다.

두 방법 중 어떤것이 적절한가는 비즈니스 상황에 따라 적절한 것을 선택하면 될 것이다.

&nbsp;
&nbsp;
&nbsp;


## 2. 핸들러 밖에서 예외가 발생하는 경우 어떻게 처리할까 ?

### 1) `HandlerInterceptor` 에서 예외가 발생하면 어떻게 될까?

HandlerInterceptor 는 구현할 수 있는 메서드가 총 3가지다.
1. preHandle
2. postHandle
3. afterCompletion

클라이언트의 요청 흐름은 다음과 같다. (DispatcherServlet)

`Interceptor(preHandle)` -> `Handler` -> `Interceptor(postHandle)` -> `HandlerExceptionResolver(예외 복구)` -> `View 렌더링` -> `Interceptor(afterCompletion)`

따라서 `Interceptor(preHandle)`, `Interceptor(postHandle)` 에서 예외가 발생하더라도 `@ExceptionHandler` 로 복구가 가능하다.

여기서 궁금증이 하나 더 생긴다. `Interceptor(afterCompletion)` 에서 예외가 발생하면 어떻게 처리될까?

=> `@ExceptionHandler` 로 예외를 잡지 못하며 `로그를 남길 뿐` 이다. (클라이언트에게 응답은 이루어진다)

```java
    // ...
	try {
		interceptor.afterCompletion(request, response, this.handler, ex);
	}
	catch (Throwable ex2) {
		logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
	}
```  
https://github.com/spring-projects/spring-framework/blob/5.2.x/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerExecutionChain.java#L188-L193

&nbsp;
&nbsp;

### 2) `Filter` 에서 예외가 발생하면 어떻게 될까?

필터에서 예외를 던지면 핸들링은 어디서 어떻게 할까.

=> 아래와 같이 `HTTP 상태코드 500` 으로 응답한다. 

[java.org.apache.catalina.core.StandardWrapperValve.java](https://github.com/apache/tomcat80/blob/36e43128e23d0aae0dd3d2d2e657eba9a6463d20/java/org/apache/catalina/core/StandardWrapperValve.java#L500-L505)
```java
    private void exception(Request request, Response response,
                           Throwable exception) {
        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, exception);
        response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); // 상태코드 500
        response.setError();
    }
```

단, 필터에서 예외를 던지더라도 500 상태코드로 응답하지 않는 경우가 있다. Response 객체가 이미 commit된 경우에는 상태코드를 수정할 수 없다. 즉, commit될 때의 Response를 사용자에게 전달한다.  
(핸들러 처리 이후 HttpMessageConverter가 Response를 commit)

&nbsp;
&nbsp;

이 글은 개인적으로 기록하기 위해 작성하여 독자에게 도움이 됬을지 모르겠다.  
만약 도움이 안됬다면 아래 글들을 참고하여 직접 디버깅 해보길 추천한다.  

- [13. 스프링부트 MVC - Filter 설정 by linked2ev](https://linked2ev.github.io/gitlog/2019/09/15/springboot-mvc-13-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-MVC-Filter-%EC%84%A4%EC%A0%95/)
- [Spring Boot에서 Interceptor 사용하기 by elfinlas](https://elfinlas.github.io/2017/12/28/SpringBootInterceptor/)